; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o".\FLASH M4\lpc_uart.o" --asm_dir=".\FLASH M4\\" --list_dir=".\FLASH M4\\" --depend=".\FLASH M4\lpc_uart.d" --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\Core\CM3\DeviceSupport\NXP\LPC17xx -I..\..\..\..\Drivers\include -I..\..\..\..\BoardSupport -I..\..\..\..\Core\CMSIS\Include -I..\..\..\..\Core\Device\NXP\LPC407x_8x_177x_8x\Include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\NXP\LPC407x_8x_177x_8x -D__MICROLIB -DCORE_M4 --omf_browse=".\FLASH M4\lpc_uart.crf" ..\..\..\..\Drivers\source\lpc_uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_get_pointer PROC
;;;203     **********************************************************************/
;;;204    LPC_UART_TypeDef *uart_get_pointer(UART_ID_Type UartID)
000000  4601              MOV      r1,r0
;;;205    {
;;;206    	LPC_UART_TypeDef *UARTx = NULL;
000002  2000              MOVS     r0,#0
;;;207    	switch(UartID)
000004  b121              CBZ      r1,|L1.16|
000006  2902              CMP      r1,#2
000008  d004              BEQ      |L1.20|
00000a  2903              CMP      r1,#3
00000c  d106              BNE      |L1.28|
00000e  e003              B        |L1.24|
                  |L1.16|
;;;208    	{
;;;209    		case UART_0:
;;;210    			UARTx = LPC_UART0;
000010  48f8              LDR      r0,|L1.1012|
;;;211    			break;
000012  e004              B        |L1.30|
                  |L1.20|
;;;212    		case UART_2:
;;;213    			UARTx = LPC_UART2;
000014  48f8              LDR      r0,|L1.1016|
;;;214    			break;
000016  e002              B        |L1.30|
                  |L1.24|
;;;215    		case UART_3:
;;;216    			UARTx = LPC_UART3;
000018  48f8              LDR      r0,|L1.1020|
;;;217    			break;
00001a  e000              B        |L1.30|
                  |L1.28|
;;;218    		default:
;;;219    			break;
00001c  bf00              NOP      
                  |L1.30|
00001e  bf00              NOP                            ;211
;;;220    	}
;;;221    	return UARTx;
;;;222    }
000020  4770              BX       lr
;;;223    
                          ENDP

                  uart_set_divisors PROC
;;;66      **********************************************************************/
;;;67     static Status uart_set_divisors(UART_ID_Type UartID, uint32_t baudrate)
000022  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;68     {
000026  b095              SUB      sp,sp,#0x54
000028  468a              MOV      r10,r1
;;;69     	Status errorStatus = ERROR;
00002a  2000              MOVS     r0,#0
00002c  900a              STR      r0,[sp,#0x28]
;;;70     
;;;71     	uint32_t uClk;
;;;72     	uint32_t d, m, bestd, bestm, tmp;
;;;73     	uint64_t best_divisor, divisor;
;;;74     	uint32_t current_error, best_error;
;;;75     	uint32_t recalcbaud;
;;;76     
;;;77     	/* get UART block clock */
;;;78     	uClk = CLKPWR_GetCLK(CLKPWR_CLKTYPE_PER);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLKPWR_GetCLK
000034  9009              STR      r0,[sp,#0x24]
;;;79     
;;;80     	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
;;;81     	* The formula is :
;;;82     	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
;;;83     	* It involves floating point calculations. That's the reason the formulae are adjusted with
;;;84     	* Multiply and divide method.*/
;;;85     	
;;;86     	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
;;;87     	* 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
;;;88     	best_error = 0xFFFFFFFF; /* Worst case */
000036  f04f30ff          MOV      r0,#0xffffffff
00003a  9004              STR      r0,[sp,#0x10]
;;;89     	bestd = 0;
00003c  2000              MOVS     r0,#0
00003e  9007              STR      r0,[sp,#0x1c]
;;;90     	bestm = 0;
000040  9006              STR      r0,[sp,#0x18]
;;;91     	best_divisor = 0;
000042  2100              MOVS     r1,#0
000044  460c              MOV      r4,r1
000046  460d              MOV      r5,r1
;;;92     	
;;;93     	for (m = 1 ; m <= 15 ;m++)
000048  2601              MOVS     r6,#1
00004a  e054              B        |L1.246|
                  |L1.76|
;;;94     	{
;;;95     		for (d = 0 ; d < m ; d++)
00004c  2000              MOVS     r0,#0
00004e  9008              STR      r0,[sp,#0x20]
000050  e049              B        |L1.230|
                  |L1.82|
;;;96     		{
;;;97     			divisor = ((uint64_t)uClk << 28)*m / (baudrate*(m+d));
000052  9808              LDR      r0,[sp,#0x20]
000054  4430              ADD      r0,r0,r6
000056  fb00f00a          MUL      r0,r0,r10
00005a  9002              STR      r0,[sp,#8]
00005c  2000              MOVS     r0,#0
00005e  221c              MOVS     r2,#0x1c
000060  9909              LDR      r1,[sp,#0x24]
000062  e9cd010d          STRD     r0,r1,[sp,#0x34]
000066  4608              MOV      r0,r1
000068  990d              LDR      r1,[sp,#0x34]
00006a  f7fffffe          BL       __aeabi_llsl
00006e  2200              MOVS     r2,#0
000070  fba03706          UMULL    r3,r7,r0,r6
000074  fb017106          MLA      r1,r1,r6,r7
000078  fb001002          MLA      r0,r0,r2,r1
00007c  e9cd3000          STRD     r3,r0,[sp,#0]
000080  2300              MOVS     r3,#0
000082  e89d0007          LDM      sp,{r0-r2}
000086  f7fffffe          BL       __aeabi_uldivmod
00008a  4680              MOV      r8,r0
00008c  4689              MOV      r9,r1
;;;98     			current_error = divisor & 0xFFFFFFFF;
00008e  f8cd8014          STR      r8,[sp,#0x14]
;;;99     
;;;100    			tmp = divisor>>32;
000092  2220              MOVS     r2,#0x20
000094  4640              MOV      r0,r8
000096  4649              MOV      r1,r9
000098  e9cd980b          STRD     r9,r8,[sp,#0x2c]
00009c  f7fffffe          BL       __aeabi_llsr
0000a0  4683              MOV      r11,r0
;;;101    
;;;102    			/* Adjust error */
;;;103    			if(current_error > ((uint32_t)1<<31))
0000a2  9805              LDR      r0,[sp,#0x14]
0000a4  f1b04f00          CMP      r0,#0x80000000
0000a8  d904              BLS      |L1.180|
;;;104    			{
;;;105    				current_error = -current_error;
0000aa  9805              LDR      r0,[sp,#0x14]
0000ac  4240              RSBS     r0,r0,#0
0000ae  9005              STR      r0,[sp,#0x14]
;;;106    				tmp++;
0000b0  f10b0b01          ADD      r11,r11,#1
                  |L1.180|
;;;107    			}
;;;108    
;;;109    			/* Out of range */
;;;110    			if(tmp < 1 || tmp > 65536)
0000b4  f1bb0f00          CMP      r11,#0
0000b8  d002              BEQ      |L1.192|
0000ba  f5bb3f80          CMP      r11,#0x10000
0000be  d900              BLS      |L1.194|
                  |L1.192|
;;;111    				continue;
0000c0  e00e              B        |L1.224|
                  |L1.194|
;;;112    
;;;113    			if( current_error < best_error)
0000c2  e9dd1004          LDRD     r1,r0,[sp,#0x10]
0000c6  4288              CMP      r0,r1
0000c8  d209              BCS      |L1.222|
;;;114    			{
;;;115    				best_error = current_error;
0000ca  9805              LDR      r0,[sp,#0x14]
0000cc  9004              STR      r0,[sp,#0x10]
;;;116    				best_divisor = tmp;
0000ce  2500              MOVS     r5,#0
0000d0  465c              MOV      r4,r11
;;;117    				bestd = d;
0000d2  9808              LDR      r0,[sp,#0x20]
0000d4  9007              STR      r0,[sp,#0x1c]
;;;118    				bestm = m;
0000d6  9606              STR      r6,[sp,#0x18]
;;;119    				
;;;120    				if(best_error == 0) 
0000d8  9804              LDR      r0,[sp,#0x10]
0000da  b900              CBNZ     r0,|L1.222|
;;;121    					break;
0000dc  e006              B        |L1.236|
                  |L1.222|
0000de  bf00              NOP                            ;111
                  |L1.224|
0000e0  9808              LDR      r0,[sp,#0x20]         ;95
0000e2  1c40              ADDS     r0,r0,#1              ;95
0000e4  9008              STR      r0,[sp,#0x20]         ;95
                  |L1.230|
0000e6  9808              LDR      r0,[sp,#0x20]         ;95
0000e8  42b0              CMP      r0,r6                 ;95
0000ea  d3b2              BCC      |L1.82|
                  |L1.236|
0000ec  bf00              NOP      
;;;122    			}
;;;123    		} /* end of inner for loop */
;;;124    
;;;125    		if (best_error == 0)
0000ee  9804              LDR      r0,[sp,#0x10]
0000f0  b900              CBNZ     r0,|L1.244|
;;;126    			break;
0000f2  e002              B        |L1.250|
                  |L1.244|
0000f4  1c76              ADDS     r6,r6,#1              ;93
                  |L1.246|
0000f6  2e0f              CMP      r6,#0xf               ;93
0000f8  d9a8              BLS      |L1.76|
                  |L1.250|
0000fa  bf00              NOP      
;;;127    	} /* end of outer for loop  */
;;;128    
;;;129    	/* can not find best match */
;;;130    	if(best_divisor == 0) 
0000fc  2100              MOVS     r1,#0
0000fe  4608              MOV      r0,r1
000100  4061              EORS     r1,r1,r4
000102  4068              EORS     r0,r0,r5
000104  4301              ORRS     r1,r1,r0
000106  d103              BNE      |L1.272|
;;;131    		return ERROR;
000108  2000              MOVS     r0,#0
                  |L1.266|
;;;132    
;;;133    	recalcbaud = (uClk >> 4) * bestm / (best_divisor * (bestm + bestd));
;;;134    
;;;135    	/* reuse best_error to evaluate baud error*/
;;;136    	if(baudrate > recalcbaud) 
;;;137    		best_error = baudrate - recalcbaud;
;;;138    	else 
;;;139    		best_error = recalcbaud -baudrate;
;;;140    
;;;141    	best_error = best_error * 100 / baudrate;
;;;142    
;;;143    	if (best_error < UART_ACCEPTED_BAUDRATE_ERROR)
;;;144    	{
;;;145    		if (UartID == UART_1)
;;;146    		{
;;;147    			LPC_UART1->LCR |= UART_LCR_DLAB_EN;
;;;148    			
;;;149    			LPC_UART1->DLM = UART_LOAD_DLM(best_divisor);
;;;150    			
;;;151    			LPC_UART1->DLL = UART_LOAD_DLL(best_divisor);
;;;152    			
;;;153    			/* Then reset DLAB bit */
;;;154    			LPC_UART1->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;155    			
;;;156    			LPC_UART1->FDR = (UART_FDR_MULVAL(bestm)
;;;157    													| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;158    		}
;;;159    		else if (UartID == UART_4)
;;;160    		{
;;;161    			LPC_UART4->LCR |= UART_LCR_DLAB_EN;
;;;162    			
;;;163    			LPC_UART4->DLM = UART_LOAD_DLM(best_divisor);
;;;164    			
;;;165    			LPC_UART4->DLL = UART_LOAD_DLL(best_divisor);
;;;166    			
;;;167    			/* Then reset DLAB bit */
;;;168    			LPC_UART4->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;169    			
;;;170    			LPC_UART4->FDR = (UART_FDR_MULVAL(bestm)
;;;171    													| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;172    		}
;;;173    			
;;;174    		else
;;;175    		{
;;;176                LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
;;;177    			UARTx->LCR |= UART_LCR_DLAB_EN;
;;;178    			
;;;179    			UARTx->DLM = UART_LOAD_DLM(best_divisor);
;;;180    			
;;;181    			UARTx->DLL = UART_LOAD_DLL(best_divisor);
;;;182    			
;;;183    			/* Then reset DLAB bit */
;;;184    			UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
;;;185    			
;;;186    			UARTx->FDR = (UART_FDR_MULVAL(bestm) \
;;;187    							| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
;;;188    		}
;;;189    		errorStatus = SUCCESS;
;;;190    	}
;;;191    
;;;192    	return errorStatus;
;;;193    }
00010a  b017              ADD      sp,sp,#0x5c
00010c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.272|
000110  9809              LDR      r0,[sp,#0x24]         ;133
000112  0900              LSRS     r0,r0,#4              ;133
000114  9906              LDR      r1,[sp,#0x18]         ;133
000116  fb00f701          MUL      r7,r0,r1              ;133
00011a  9807              LDR      r0,[sp,#0x1c]         ;133
00011c  4408              ADD      r0,r0,r1              ;133
00011e  2100              MOVS     r1,#0                 ;133
000120  fba02304          UMULL    r2,r3,r0,r4           ;133
000124  fb013104          MLA      r1,r1,r4,r3           ;133
000128  fb001005          MLA      r0,r0,r5,r1           ;133
00012c  4603              MOV      r3,r0                 ;133
00012e  e9cd2000          STRD     r2,r0,[sp,#0]         ;133
000132  4638              MOV      r0,r7                 ;133
000134  2100              MOVS     r1,#0                 ;133
000136  f7fffffe          BL       __aeabi_uldivmod
00013a  9003              STR      r0,[sp,#0xc]          ;133
00013c  9803              LDR      r0,[sp,#0xc]          ;136
00013e  4582              CMP      r10,r0                ;136
000140  d904              BLS      |L1.332|
000142  9803              LDR      r0,[sp,#0xc]          ;137
000144  ebaa0000          SUB      r0,r10,r0             ;137
000148  9004              STR      r0,[sp,#0x10]         ;137
00014a  e003              B        |L1.340|
                  |L1.332|
00014c  9803              LDR      r0,[sp,#0xc]          ;139
00014e  eba0000a          SUB      r0,r0,r10             ;139
000152  9004              STR      r0,[sp,#0x10]         ;139
                  |L1.340|
000154  2064              MOVS     r0,#0x64              ;141
000156  9904              LDR      r1,[sp,#0x10]         ;141
000158  4341              MULS     r1,r0,r1              ;141
00015a  fbb1f0fa          UDIV     r0,r1,r10             ;141
00015e  9004              STR      r0,[sp,#0x10]         ;141
000160  9804              LDR      r0,[sp,#0x10]         ;143
000162  2803              CMP      r0,#3                 ;143
000164  d269              BCS      |L1.570|
000166  9815              LDR      r0,[sp,#0x54]         ;145
000168  2801              CMP      r0,#1                 ;145
00016a  d11f              BNE      |L1.428|
00016c  48a4              LDR      r0,|L1.1024|
00016e  7b00              LDRB     r0,[r0,#0xc]          ;147
000170  f0400080          ORR      r0,r0,#0x80           ;147
000174  49a2              LDR      r1,|L1.1024|
000176  7308              STRB     r0,[r1,#0xc]          ;147
000178  2208              MOVS     r2,#8                 ;149
00017a  4620              MOV      r0,r4                 ;149
00017c  4629              MOV      r1,r5                 ;149
00017e  e9cd540f          STRD     r5,r4,[sp,#0x3c]      ;149
000182  f7fffffe          BL       __aeabi_llsr
000186  499e              LDR      r1,|L1.1024|
000188  7108              STRB     r0,[r1,#4]            ;149
00018a  700c              STRB     r4,[r1,#0]            ;151
00018c  4608              MOV      r0,r1                 ;154
00018e  7b00              LDRB     r0,[r0,#0xc]          ;154
000190  f000007f          AND      r0,r0,#0x7f           ;154
000194  7308              STRB     r0,[r1,#0xc]          ;154
000196  20f0              MOVS     r0,#0xf0              ;156
000198  9906              LDR      r1,[sp,#0x18]         ;156
00019a  ea001001          AND      r0,r0,r1,LSL #4       ;156
00019e  9907              LDR      r1,[sp,#0x1c]         ;156
0001a0  f001010f          AND      r1,r1,#0xf            ;156
0001a4  4308              ORRS     r0,r0,r1              ;156
0001a6  4996              LDR      r1,|L1.1024|
0001a8  6288              STR      r0,[r1,#0x28]         ;156
0001aa  e044              B        |L1.566|
                  |L1.428|
0001ac  9815              LDR      r0,[sp,#0x54]         ;159
0001ae  2804              CMP      r0,#4                 ;159
0001b0  d121              BNE      |L1.502|
0001b2  4894              LDR      r0,|L1.1028|
0001b4  68c0              LDR      r0,[r0,#0xc]          ;161
0001b6  f0400080          ORR      r0,r0,#0x80           ;161
0001ba  4992              LDR      r1,|L1.1028|
0001bc  60c8              STR      r0,[r1,#0xc]          ;161
0001be  2208              MOVS     r2,#8                 ;163
0001c0  4620              MOV      r0,r4                 ;163
0001c2  4629              MOV      r1,r5                 ;163
0001c4  e9cd5411          STRD     r5,r4,[sp,#0x44]      ;163
0001c8  f7fffffe          BL       __aeabi_llsr
0001cc  b2c0              UXTB     r0,r0                 ;163
0001ce  498d              LDR      r1,|L1.1028|
0001d0  6048              STR      r0,[r1,#4]            ;163
0001d2  b2e0              UXTB     r0,r4                 ;165
0001d4  6008              STR      r0,[r1,#0]            ;165
0001d6  4608              MOV      r0,r1                 ;168
0001d8  68c0              LDR      r0,[r0,#0xc]          ;168
0001da  f000007f          AND      r0,r0,#0x7f           ;168
0001de  60c8              STR      r0,[r1,#0xc]          ;168
0001e0  20f0              MOVS     r0,#0xf0              ;170
0001e2  9906              LDR      r1,[sp,#0x18]         ;170
0001e4  ea001001          AND      r0,r0,r1,LSL #4       ;170
0001e8  9907              LDR      r1,[sp,#0x1c]         ;170
0001ea  f001010f          AND      r1,r1,#0xf            ;170
0001ee  4308              ORRS     r0,r0,r1              ;170
0001f0  4984              LDR      r1,|L1.1028|
0001f2  6288              STR      r0,[r1,#0x28]         ;170
0001f4  e01f              B        |L1.566|
                  |L1.502|
0001f6  9815              LDR      r0,[sp,#0x54]         ;176
0001f8  f7fffffe          BL       uart_get_pointer
0001fc  4607              MOV      r7,r0                 ;176
0001fe  7b38              LDRB     r0,[r7,#0xc]          ;177
000200  f0400080          ORR      r0,r0,#0x80           ;177
000204  7338              STRB     r0,[r7,#0xc]          ;177
000206  2208              MOVS     r2,#8                 ;179
000208  4620              MOV      r0,r4                 ;179
00020a  4629              MOV      r1,r5                 ;179
00020c  e9cd5413          STRD     r5,r4,[sp,#0x4c]      ;179
000210  f7fffffe          BL       __aeabi_llsr
000214  7138              STRB     r0,[r7,#4]            ;179
000216  703c              STRB     r4,[r7,#0]            ;181
000218  7b38              LDRB     r0,[r7,#0xc]          ;184
00021a  f000007f          AND      r0,r0,#0x7f           ;184
00021e  7338              STRB     r0,[r7,#0xc]          ;184
000220  20f0              MOVS     r0,#0xf0              ;186
000222  9906              LDR      r1,[sp,#0x18]         ;186
000224  ea001001          AND      r0,r0,r1,LSL #4       ;186
000228  9907              LDR      r1,[sp,#0x1c]         ;186
00022a  f001010f          AND      r1,r1,#0xf            ;186
00022e  4308              ORRS     r0,r0,r1              ;186
000230  f8870028          STRB     r0,[r7,#0x28]         ;186
000234  bf00              NOP                            ;188
                  |L1.566|
000236  2001              MOVS     r0,#1                 ;189
000238  900a              STR      r0,[sp,#0x28]         ;189
                  |L1.570|
00023a  980a              LDR      r0,[sp,#0x28]         ;192
00023c  e765              B        |L1.266|
;;;194    /*********************************************************************//**
                          ENDP

                  UART_Init PROC
;;;245     *********************************************************************/
;;;246    void UART_Init(UART_ID_Type UartID, UART_CFG_Type *UART_ConfigStruct)
00023e  e92d41f0          PUSH     {r4-r8,lr}
;;;247    {
000242  4606              MOV      r6,r0
000244  460f              MOV      r7,r1
;;;248    	uint32_t tmp;
;;;249    	switch (UartID)
000246  2e05              CMP      r6,#5
000248  d23c              BCS      |L1.708|
00024a  e8dff006          TBB      [pc,r6]
00024e  033c              DCB      0x03,0x3c
000250  04056c00          DCB      0x04,0x05,0x6c,0x00
;;;250    	{
;;;251    		case UART_0:
;;;252    		case UART_2:
000254  bf00              NOP      
;;;253    		case UART_3:
000256  bf00              NOP      
;;;254    		{
;;;255    			LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000258  4630              MOV      r0,r6
00025a  f7fffffe          BL       uart_get_pointer
00025e  4605              MOV      r5,r0
;;;256    			if(UartID == UART_0)
000260  b926              CBNZ     r6,|L1.620|
;;;257    				/* Set up clock and power for UART module */
;;;258    				CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, ENABLE);
000262  2101              MOVS     r1,#1
000264  2008              MOVS     r0,#8
000266  f7fffffe          BL       CLKPWR_ConfigPPWR
00026a  e00c              B        |L1.646|
                  |L1.620|
;;;259    			else if(UartID == UART_2)
00026c  2e02              CMP      r6,#2
00026e  d104              BNE      |L1.634|
;;;260    				/* Set up clock and power for UART module */
;;;261    				CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, ENABLE);
000270  2101              MOVS     r1,#1
000272  0608              LSLS     r0,r1,#24
000274  f7fffffe          BL       CLKPWR_ConfigPPWR
000278  e005              B        |L1.646|
                  |L1.634|
;;;262    			else if(UartID == UART_3)
00027a  2e03              CMP      r6,#3
00027c  d103              BNE      |L1.646|
;;;263    				/* Set up clock and power for UART module */
;;;264    				CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, ENABLE);;
00027e  2101              MOVS     r1,#1
000280  0648              LSLS     r0,r1,#25
000282  f7fffffe          BL       CLKPWR_ConfigPPWR
                  |L1.646|
;;;265    			/* FIFOs are empty */
;;;266    			UARTx->FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
000286  2007              MOVS     r0,#7
000288  7228              STRB     r0,[r5,#8]
;;;267    
;;;268    			// Disable FIFO
;;;269    			UARTx->FCR = 0;
00028a  2000              MOVS     r0,#0
00028c  7228              STRB     r0,[r5,#8]
;;;270    
;;;271    			// Dummy reading
;;;272    			while (UARTx->LSR & UART_LSR_RDR)
00028e  e000              B        |L1.658|
                  |L1.656|
;;;273    			{
;;;274    				tmp = UARTx->RBR;
000290  782c              LDRB     r4,[r5,#0]
                  |L1.658|
000292  7d28              LDRB     r0,[r5,#0x14]         ;272
000294  f0100f01          TST      r0,#1                 ;272
000298  d1fa              BNE      |L1.656|
;;;275    			}
;;;276    
;;;277    			UARTx->TER = UART_TER_TXEN;
00029a  2080              MOVS     r0,#0x80
00029c  f8850030          STRB     r0,[r5,#0x30]
;;;278    
;;;279    			// Wait for current transmit complete
;;;280    			while (!(UARTx->LSR & UART_LSR_THRE));
0002a0  bf00              NOP      
                  |L1.674|
0002a2  7d28              LDRB     r0,[r5,#0x14]
0002a4  f0100f20          TST      r0,#0x20
0002a8  d0fb              BEQ      |L1.674|
;;;281    
;;;282    			// Disable Tx
;;;283    			UARTx->TER = 0;
0002aa  2000              MOVS     r0,#0
0002ac  f8850030          STRB     r0,[r5,#0x30]
;;;284    
;;;285    			// Disable interrupt
;;;286    			UARTx->IER = 0;
0002b0  6068              STR      r0,[r5,#4]
;;;287    
;;;288    			// Set LCR to default state
;;;289    			UARTx->LCR = 0;
0002b2  7328              STRB     r0,[r5,#0xc]
;;;290    
;;;291    			// Set ACR to default state
;;;292    			UARTx->ACR = 0;
0002b4  6228              STR      r0,[r5,#0x20]
;;;293    
;;;294    			// Set RS485 control to default state
;;;295    			UARTx->RS485CTRL = 0;
0002b6  f885004c          STRB     r0,[r5,#0x4c]
;;;296    
;;;297    			// Set RS485 delay timer to default state
;;;298    			UARTx->RS485DLY = 0;
0002ba  f8850054          STRB     r0,[r5,#0x54]
;;;299    
;;;300    			// Set RS485 addr match to default state
;;;301    			UARTx->ADRMATCH = 0;
0002be  f8850050          STRB     r0,[r5,#0x50]
;;;302    
;;;303    			// Dummy reading
;;;304    			tmp = UARTx->LSR;
0002c2  7d2c              LDRB     r4,[r5,#0x14]
                  |L1.708|
;;;305    		}
;;;306    		break;
0002c4  e057              B        |L1.886|
;;;307    		case UART_1:
;;;308    		{
;;;309    			/* Set up clock and power for UART module */
;;;310    			CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, ENABLE);
0002c6  2101              MOVS     r1,#1
0002c8  2010              MOVS     r0,#0x10
0002ca  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;311    
;;;312    			/* FIFOs are empty */
;;;313    			LPC_UART1->FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
0002ce  2007              MOVS     r0,#7
0002d0  494b              LDR      r1,|L1.1024|
0002d2  7208              STRB     r0,[r1,#8]
;;;314    
;;;315    			// Disable FIFO
;;;316    			LPC_UART1->FCR = 0;
0002d4  2000              MOVS     r0,#0
0002d6  7208              STRB     r0,[r1,#8]
;;;317    
;;;318    			// Dummy reading
;;;319    			while (LPC_UART1->LSR & UART_LSR_RDR)
0002d8  e001              B        |L1.734|
                  |L1.730|
;;;320    			{
;;;321    				tmp = LPC_UART1->RBR;
0002da  4849              LDR      r0,|L1.1024|
0002dc  7804              LDRB     r4,[r0,#0]
                  |L1.734|
0002de  4848              LDR      r0,|L1.1024|
0002e0  7d00              LDRB     r0,[r0,#0x14]         ;319
0002e2  f0100f01          TST      r0,#1                 ;319
0002e6  d1f8              BNE      |L1.730|
;;;322    			}
;;;323    
;;;324    			LPC_UART1->TER = UART_TER_TXEN;
0002e8  2080              MOVS     r0,#0x80
0002ea  4947              LDR      r1,|L1.1032|
0002ec  7008              STRB     r0,[r1,#0]
;;;325    
;;;326    			// Wait for current transmit complete
;;;327    			while (!(LPC_UART1->LSR & UART_LSR_THRE));
0002ee  bf00              NOP      
                  |L1.752|
0002f0  4843              LDR      r0,|L1.1024|
0002f2  7d00              LDRB     r0,[r0,#0x14]
0002f4  f0100f20          TST      r0,#0x20
0002f8  d0fa              BEQ      |L1.752|
;;;328    
;;;329    			// Disable Tx
;;;330    			LPC_UART1->TER = 0;
0002fa  2000              MOVS     r0,#0
0002fc  4942              LDR      r1,|L1.1032|
0002fe  7008              STRB     r0,[r1,#0]
;;;331    
;;;332    			// Disable interrupt
;;;333    			LPC_UART1->IER = 0;
000300  493f              LDR      r1,|L1.1024|
000302  6048              STR      r0,[r1,#4]
;;;334    
;;;335    			// Set LCR to default state
;;;336    			LPC_UART1->LCR = 0;
000304  7308              STRB     r0,[r1,#0xc]
;;;337    
;;;338    			// Set ACR to default state
;;;339    			LPC_UART1->ACR = 0;
000306  6208              STR      r0,[r1,#0x20]
;;;340    
;;;341    			// Set RS485 control to default state
;;;342    			LPC_UART1->RS485CTRL = 0;
000308  f881004c          STRB     r0,[r1,#0x4c]
;;;343    
;;;344    			// Set RS485 delay timer to default state
;;;345    			LPC_UART1->RS485DLY = 0;
00030c  493f              LDR      r1,|L1.1036|
00030e  7008              STRB     r0,[r1,#0]
;;;346    
;;;347    			// Set RS485 addr match to default state
;;;348    			LPC_UART1->ADRMATCH = 0;
000310  493b              LDR      r1,|L1.1024|
000312  f8810050          STRB     r0,[r1,#0x50]
;;;349    
;;;350    			// Dummy reading
;;;351    			tmp = LPC_UART1->LSR;
000316  4608              MOV      r0,r1
000318  7d04              LDRB     r4,[r0,#0x14]
;;;352    
;;;353    			// Set Modem Control to default state
;;;354    			LPC_UART1->MCR = 0;
00031a  f04f0000          MOV      r0,#0
00031e  7408              STRB     r0,[r1,#0x10]
;;;355    
;;;356    			//Dummy Reading to Clear Status
;;;357    			tmp = LPC_UART1->MSR;
000320  4608              MOV      r0,r1
000322  7e04              LDRB     r4,[r0,#0x18]
;;;358    		}
;;;359    		break;
000324  e027              B        |L1.886|
;;;360    		case UART_4:
;;;361    	    {
;;;362    			/* Set up clock and power for UART module */
;;;363    			CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART4, ENABLE);
000326  2101              MOVS     r1,#1
000328  0208              LSLS     r0,r1,#8
00032a  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;364    
;;;365    			/* FIFOs are empty */
;;;366    			LPC_UART4->FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
00032e  2007              MOVS     r0,#7
000330  4934              LDR      r1,|L1.1028|
000332  6088              STR      r0,[r1,#8]
;;;367    
;;;368    			// Disable FIFO
;;;369    			LPC_UART4->FCR = 0;
000334  2000              MOVS     r0,#0
000336  6088              STR      r0,[r1,#8]
;;;370    
;;;371    			// Dummy reading
;;;372    			while (LPC_UART4->LSR & UART_LSR_RDR)
000338  e001              B        |L1.830|
                  |L1.826|
;;;373    			{
;;;374    				tmp = LPC_UART4->RBR;
00033a  4832              LDR      r0,|L1.1028|
00033c  6804              LDR      r4,[r0,#0]
                  |L1.830|
00033e  4831              LDR      r0,|L1.1028|
000340  6940              LDR      r0,[r0,#0x14]         ;372
000342  f0100f01          TST      r0,#1                 ;372
000346  d1f8              BNE      |L1.826|
;;;375    			}
;;;376    
;;;377    			LPC_UART4->TER = UART4_TER_TXEN;
000348  2001              MOVS     r0,#1
00034a  492e              LDR      r1,|L1.1028|
00034c  65c8              STR      r0,[r1,#0x5c]
;;;378    
;;;379    			// Wait for current transmit complete
;;;380    			while (!(LPC_UART4->LSR & UART_LSR_THRE));
00034e  bf00              NOP      
                  |L1.848|
000350  482c              LDR      r0,|L1.1028|
000352  6940              LDR      r0,[r0,#0x14]
000354  f0100f20          TST      r0,#0x20
000358  d0fa              BEQ      |L1.848|
;;;381    
;;;382    			// Disable Tx
;;;383    			LPC_UART4->TER = 0;
00035a  2000              MOVS     r0,#0
00035c  4929              LDR      r1,|L1.1028|
00035e  65c8              STR      r0,[r1,#0x5c]
;;;384    
;;;385    			// Disable interrupt
;;;386    			LPC_UART4->IER = 0;
000360  6048              STR      r0,[r1,#4]
;;;387    
;;;388    			// Set LCR to default state
;;;389    			LPC_UART4->LCR = 0;
000362  60c8              STR      r0,[r1,#0xc]
;;;390    
;;;391    			// Set ACR to default state
;;;392    			LPC_UART4->ACR = 0;
000364  6208              STR      r0,[r1,#0x20]
;;;393    
;;;394    			// Set RS485 control to default state
;;;395    			LPC_UART4->RS485CTRL = 0;
000366  64c8              STR      r0,[r1,#0x4c]
;;;396    
;;;397    			// Set RS485 delay timer to default state
;;;398    			LPC_UART4->RS485DLY = 0;
000368  6548              STR      r0,[r1,#0x54]
;;;399    
;;;400    			// Set RS485 addr match to default state
;;;401    			LPC_UART4->ADRMATCH = 0;
00036a  6508              STR      r0,[r1,#0x50]
;;;402    
;;;403    			// Dummy reading
;;;404    			tmp = LPC_UART4->LSR;
00036c  4608              MOV      r0,r1
00036e  6944              LDR      r4,[r0,#0x14]
;;;405    
;;;406    			// Set IrDA Mode to default state
;;;407    			LPC_UART4->ICR = 0;
000370  2000              MOVS     r0,#0
000372  6248              STR      r0,[r1,#0x24]
;;;408    		}
;;;409    		break;
000374  bf00              NOP      
                  |L1.886|
000376  bf00              NOP                            ;306
;;;410    	}
;;;411    
;;;412    	// Set Line Control register ----------------------------
;;;413    
;;;414    	uart_set_divisors(UartID, (UART_ConfigStruct->Baud_rate));
000378  4630              MOV      r0,r6
00037a  6839              LDR      r1,[r7,#0]
00037c  f7fffffe          BL       uart_set_divisors
;;;415    
;;;416    	if (UartID == UART_1)
000380  2e01              CMP      r6,#1
000382  d104              BNE      |L1.910|
;;;417    	{
;;;418    		tmp = (LPC_UART1->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
000384  481e              LDR      r0,|L1.1024|
000386  7b00              LDRB     r0,[r0,#0xc]
000388  f00004c0          AND      r4,r0,#0xc0
00038c  e00e              B        |L1.940|
                  |L1.910|
;;;419    													& UART_LCR_BITMASK;
;;;420    	}
;;;421    	else if (UartID == UART_4)
00038e  2e04              CMP      r6,#4
000390  d104              BNE      |L1.924|
;;;422    	{
;;;423    		tmp = (LPC_UART4->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
000392  481c              LDR      r0,|L1.1028|
000394  68c0              LDR      r0,[r0,#0xc]
000396  f00004c0          AND      r4,r0,#0xc0
00039a  e007              B        |L1.940|
                  |L1.924|
;;;424    													& UART_LCR_BITMASK;
;;;425    	}	
;;;426    	else
;;;427    	{
;;;428    		LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
00039c  4630              MOV      r0,r6
00039e  f7fffffe          BL       uart_get_pointer
0003a2  4605              MOV      r5,r0
;;;429    		tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
0003a4  7b28              LDRB     r0,[r5,#0xc]
0003a6  f00004c0          AND      r4,r0,#0xc0
;;;430    	}
0003aa  bf00              NOP      
                  |L1.940|
;;;431    
;;;432    	switch (UART_ConfigStruct->Databits)
0003ac  7978              LDRB     r0,[r7,#5]
0003ae  b130              CBZ      r0,|L1.958|
0003b0  2801              CMP      r0,#1
0003b2  d006              BEQ      |L1.962|
0003b4  2802              CMP      r0,#2
0003b6  d007              BEQ      |L1.968|
0003b8  2803              CMP      r0,#3
0003ba  d108              BNE      |L1.974|
0003bc  e008              B        |L1.976|
                  |L1.958|
;;;433    	{
;;;434    		case UART_DATABIT_5:
;;;435    			tmp |= UART_LCR_WLEN5;
0003be  bf00              NOP      
;;;436    			break;
0003c0  e009              B        |L1.982|
                  |L1.962|
;;;437    
;;;438    		case UART_DATABIT_6:
;;;439    			tmp |= UART_LCR_WLEN6;
0003c2  f0440401          ORR      r4,r4,#1
;;;440    			break;
0003c6  e006              B        |L1.982|
                  |L1.968|
;;;441    
;;;442    		case UART_DATABIT_7:
;;;443    			tmp |= UART_LCR_WLEN7;
0003c8  f0440402          ORR      r4,r4,#2
;;;444    			break;
0003cc  e003              B        |L1.982|
                  |L1.974|
;;;445    
;;;446    		case UART_DATABIT_8:
0003ce  bf00              NOP      
                  |L1.976|
;;;447    
;;;448    		default:
;;;449    			tmp |= UART_LCR_WLEN8;
0003d0  f0440403          ORR      r4,r4,#3
;;;450    			break;
0003d4  bf00              NOP      
                  |L1.982|
0003d6  bf00              NOP                            ;436
;;;451    	}
;;;452    
;;;453    	if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
0003d8  7938              LDRB     r0,[r7,#4]
0003da  b330              CBZ      r0,|L1.1066|
;;;454    	{
;;;455    		// Do nothing...
;;;456    	}
;;;457    	else
;;;458    	{
;;;459    		tmp |= UART_LCR_PARITY_EN;
0003dc  f0440408          ORR      r4,r4,#8
;;;460    		switch (UART_ConfigStruct->Parity)
0003e0  7938              LDRB     r0,[r7,#4]
0003e2  2801              CMP      r0,#1
0003e4  d014              BEQ      |L1.1040|
0003e6  2802              CMP      r0,#2
0003e8  d014              BEQ      |L1.1044|
0003ea  2803              CMP      r0,#3
0003ec  d015              BEQ      |L1.1050|
0003ee  2804              CMP      r0,#4
0003f0  d119              BNE      |L1.1062|
0003f2  e015              B        |L1.1056|
                  |L1.1012|
                          DCD      0x4000c000
                  |L1.1016|
                          DCD      0x40098000
                  |L1.1020|
                          DCD      0x4009c000
                  |L1.1024|
                          DCD      0x40010000
                  |L1.1028|
                          DCD      0x400a4000
                  |L1.1032|
                          DCD      0x40010030
                  |L1.1036|
                          DCD      0x40010054
                  |L1.1040|
;;;461    		{
;;;462    			case UART_PARITY_ODD:
;;;463    				tmp |= UART_LCR_PARITY_ODD;
000410  bf00              NOP      
;;;464    				break;
000412  e009              B        |L1.1064|
                  |L1.1044|
;;;465    
;;;466    			case UART_PARITY_EVEN:
;;;467    				tmp |= UART_LCR_PARITY_EVEN;
000414  f0440410          ORR      r4,r4,#0x10
;;;468    				break;
000418  e006              B        |L1.1064|
                  |L1.1050|
;;;469    
;;;470    			case UART_PARITY_SP_1:
;;;471    				tmp |= UART_LCR_PARITY_F_1;
00041a  f0440420          ORR      r4,r4,#0x20
;;;472    				break;
00041e  e003              B        |L1.1064|
                  |L1.1056|
;;;473    
;;;474    			case UART_PARITY_SP_0:
;;;475    				tmp |= UART_LCR_PARITY_F_0;
000420  f0440430          ORR      r4,r4,#0x30
;;;476    				break;
000424  e000              B        |L1.1064|
                  |L1.1062|
;;;477    
;;;478    			default:
;;;479    				break;
000426  bf00              NOP      
                  |L1.1064|
000428  bf00              NOP                            ;464
                  |L1.1066|
;;;480    		}
;;;481    	}
;;;482    
;;;483    	switch (UART_ConfigStruct->Stopbits)
00042a  79b8              LDRB     r0,[r7,#6]
00042c  b128              CBZ      r0,|L1.1082|
00042e  2801              CMP      r0,#1
000430  d102              BNE      |L1.1080|
;;;484    	{
;;;485    		case UART_STOPBIT_2:
;;;486    			tmp |= UART_LCR_STOPBIT_SEL;
000432  f0440404          ORR      r4,r4,#4
;;;487    			break;
000436  e001              B        |L1.1084|
                  |L1.1080|
;;;488    
;;;489    		case UART_STOPBIT_1:
000438  bf00              NOP      
                  |L1.1082|
;;;490    
;;;491    		default:
;;;492    			// Do no thing
;;;493    			break;
00043a  bf00              NOP      
                  |L1.1084|
00043c  bf00              NOP                            ;487
;;;494    	}
;;;495    
;;;496    
;;;497    	// Write back to LCR, configure FIFO and Disable Tx
;;;498    	if (UartID == UART_1)
00043e  2e01              CMP      r6,#1
000440  d102              BNE      |L1.1096|
;;;499    	{
;;;500    		LPC_UART1->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
000442  49fa              LDR      r1,|L1.2092|
000444  730c              STRB     r4,[r1,#0xc]
000446  e00b              B        |L1.1120|
                  |L1.1096|
;;;501    	}
;;;502    	else if (UartID == UART_4)
000448  2e04              CMP      r6,#4
00044a  d103              BNE      |L1.1108|
;;;503    	{
;;;504    		LPC_UART4->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
00044c  b2e0              UXTB     r0,r4
00044e  49f8              LDR      r1,|L1.2096|
000450  60c8              STR      r0,[r1,#0xc]
000452  e005              B        |L1.1120|
                  |L1.1108|
;;;505    	}	
;;;506    	else
;;;507    	{
;;;508    		LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000454  4630              MOV      r0,r6
000456  f7fffffe          BL       uart_get_pointer
00045a  4605              MOV      r5,r0
;;;509    		UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
00045c  732c              STRB     r4,[r5,#0xc]
;;;510    	}
00045e  bf00              NOP      
                  |L1.1120|
;;;511    }
000460  e8bd81f0          POP      {r4-r8,pc}
;;;512    
                          ENDP

                  UART_TxCmd PROC
;;;1334    **********************************************************************/
;;;1335   void UART_TxCmd(UART_ID_Type UartID, FunctionalState NewState)
000464  b570              PUSH     {r4-r6,lr}
;;;1336   {
000466  4604              MOV      r4,r0
000468  460e              MOV      r6,r1
;;;1337   	if (NewState == ENABLE)
00046a  2e01              CMP      r6,#1
00046c  d11d              BNE      |L1.1194|
;;;1338   	{
;;;1339   		if (UartID == UART_1)
00046e  2c01              CMP      r4,#1
000470  d107              BNE      |L1.1154|
;;;1340   		{
;;;1341   			LPC_UART1->TER |= UART_TER_TXEN;
000472  48f0              LDR      r0,|L1.2100|
000474  7800              LDRB     r0,[r0,#0]
000476  f0400080          ORR      r0,r0,#0x80
00047a  49ec              LDR      r1,|L1.2092|
00047c  f8810030          STRB     r0,[r1,#0x30]
000480  e02f              B        |L1.1250|
                  |L1.1154|
;;;1342   		}
;;;1343   		else if (UartID == UART_4)
000482  2c04              CMP      r4,#4
000484  d106              BNE      |L1.1172|
;;;1344   		{
;;;1345               LPC_UART4->TER |= UART4_TER_TXEN;
000486  48ea              LDR      r0,|L1.2096|
000488  6dc0              LDR      r0,[r0,#0x5c]
00048a  f0400001          ORR      r0,r0,#1
00048e  49e8              LDR      r1,|L1.2096|
000490  65c8              STR      r0,[r1,#0x5c]
000492  e026              B        |L1.1250|
                  |L1.1172|
;;;1346   		}
;;;1347   		else
;;;1348   		{
;;;1349   			LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000494  4620              MOV      r0,r4
000496  f7fffffe          BL       uart_get_pointer
00049a  4605              MOV      r5,r0
;;;1350   			UARTx->TER |= UART_TER_TXEN;
00049c  f8950030          LDRB     r0,[r5,#0x30]
0004a0  f0400080          ORR      r0,r0,#0x80
0004a4  f8850030          STRB     r0,[r5,#0x30]
;;;1351   		}
0004a8  e01b              B        |L1.1250|
                  |L1.1194|
;;;1352   	}
;;;1353   	else
;;;1354   	{
;;;1355   		if (UartID == UART_1)                     
0004aa  2c01              CMP      r4,#1
0004ac  d107              BNE      |L1.1214|
;;;1356   		{
;;;1357   			LPC_UART1->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
0004ae  48e1              LDR      r0,|L1.2100|
0004b0  7800              LDRB     r0,[r0,#0]
0004b2  f04f0000          MOV      r0,#0
0004b6  49dd              LDR      r1,|L1.2092|
0004b8  f8810030          STRB     r0,[r1,#0x30]
0004bc  e011              B        |L1.1250|
                  |L1.1214|
;;;1358   		}
;;;1359   		else if (UartID == UART_4)
0004be  2c04              CMP      r4,#4
0004c0  d105              BNE      |L1.1230|
;;;1360   		{
;;;1361   			LPC_UART4->TER &= (~UART4_TER_TXEN) & UART4_TER_BITMASK;
0004c2  48db              LDR      r0,|L1.2096|
0004c4  6dc0              LDR      r0,[r0,#0x5c]
0004c6  2000              MOVS     r0,#0
0004c8  49d9              LDR      r1,|L1.2096|
0004ca  65c8              STR      r0,[r1,#0x5c]
0004cc  e009              B        |L1.1250|
                  |L1.1230|
;;;1362   		}
;;;1363   		else
;;;1364   		{
;;;1365   			LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
0004ce  4620              MOV      r0,r4
0004d0  f7fffffe          BL       uart_get_pointer
0004d4  4605              MOV      r5,r0
;;;1366   			UARTx->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
0004d6  f8950030          LDRB     r0,[r5,#0x30]
0004da  2000              MOVS     r0,#0
0004dc  f8850030          STRB     r0,[r5,#0x30]
;;;1367   		}
0004e0  bf00              NOP      
                  |L1.1250|
;;;1368   	}
;;;1369   }
0004e2  bd70              POP      {r4-r6,pc}
;;;1370   
                          ENDP

                  UART_DeInit PROC
;;;523     **********************************************************************/
;;;524    void UART_DeInit(UART_ID_Type UartID)
0004e4  b510              PUSH     {r4,lr}
;;;525    {
0004e6  4604              MOV      r4,r0
;;;526    	UART_TxCmd(UartID, DISABLE);
0004e8  2100              MOVS     r1,#0
0004ea  4620              MOV      r0,r4
0004ec  f7fffffe          BL       UART_TxCmd
;;;527    	if (UartID == UART_0)
0004f0  b924              CBNZ     r4,|L1.1276|
;;;528    	{
;;;529    		/* Set up clock and power for UART module */
;;;530    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, DISABLE);
0004f2  2100              MOVS     r1,#0
0004f4  2008              MOVS     r0,#8
0004f6  f7fffffe          BL       CLKPWR_ConfigPPWR
0004fa  e01b              B        |L1.1332|
                  |L1.1276|
;;;531    	}
;;;532    
;;;533    	else if (UartID == UART_1)
0004fc  2c01              CMP      r4,#1
0004fe  d104              BNE      |L1.1290|
;;;534    	{
;;;535    		/* Set up clock and power for UART module */
;;;536    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, DISABLE);
000500  2100              MOVS     r1,#0
000502  2010              MOVS     r0,#0x10
000504  f7fffffe          BL       CLKPWR_ConfigPPWR
000508  e014              B        |L1.1332|
                  |L1.1290|
;;;537    	}
;;;538    
;;;539    	else if (UartID == UART_2)
00050a  2c02              CMP      r4,#2
00050c  d104              BNE      |L1.1304|
;;;540    	{
;;;541    		/* Set up clock and power for UART module */
;;;542    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, DISABLE);
00050e  2100              MOVS     r1,#0
000510  05e0              LSLS     r0,r4,#23
000512  f7fffffe          BL       CLKPWR_ConfigPPWR
000516  e00d              B        |L1.1332|
                  |L1.1304|
;;;543    	}
;;;544    
;;;545    	else if (UartID == UART_3)
000518  2c03              CMP      r4,#3
00051a  d105              BNE      |L1.1320|
;;;546    	{
;;;547    		/* Set up clock and power for UART module */
;;;548    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, DISABLE);
00051c  2100              MOVS     r1,#0
00051e  f04f7000          MOV      r0,#0x2000000
000522  f7fffffe          BL       CLKPWR_ConfigPPWR
000526  e005              B        |L1.1332|
                  |L1.1320|
;;;549    	}
;;;550    	else if (UartID == UART_4)
000528  2c04              CMP      r4,#4
00052a  d103              BNE      |L1.1332|
;;;551    	{
;;;552    		/* Set up clock and power for UART module */
;;;553    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART4, DISABLE);
00052c  2100              MOVS     r1,#0
00052e  01a0              LSLS     r0,r4,#6
000530  f7fffffe          BL       CLKPWR_ConfigPPWR
                  |L1.1332|
;;;554    	}
;;;555    }
000534  bd10              POP      {r4,pc}
;;;556    
                          ENDP

                  UART_ConfigStructInit PROC
;;;566    *******************************************************************************/
;;;567    void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
000536  f44f31e1          MOV      r1,#0x1c200
;;;568    {
;;;569    	UART_InitStruct->Baud_rate = 115200;
00053a  6001              STR      r1,[r0,#0]
;;;570    
;;;571    	UART_InitStruct->Databits = UART_DATABIT_8;
00053c  2103              MOVS     r1,#3
00053e  7141              STRB     r1,[r0,#5]
;;;572    
;;;573    	UART_InitStruct->Parity = UART_PARITY_NONE;
000540  2100              MOVS     r1,#0
000542  7101              STRB     r1,[r0,#4]
;;;574    
;;;575    	UART_InitStruct->Stopbits = UART_STOPBIT_1;
000544  7181              STRB     r1,[r0,#6]
;;;576    }
000546  4770              BX       lr
;;;577    
                          ENDP

                  UART_SendByte PROC
;;;589     **********************************************************************/
;;;590    void UART_SendByte(UART_ID_Type UartID, uint8_t Data)
000548  2805              CMP      r0,#5
;;;591    {
;;;592    	switch (UartID)
00054a  d213              BCS      |L1.1396|
00054c  e8dff000          TBB      [pc,r0]
000550  0306090c          DCB      0x03,0x06,0x09,0x0c
000554  0f00              DCB      0x0f,0x00
;;;593    	{
;;;594    		case UART_0:
;;;595    			LPC_UART0->THR = Data & UART_THR_MASKBIT;
000556  4ab8              LDR      r2,|L1.2104|
000558  7011              STRB     r1,[r2,#0]
;;;596    			break;
00055a  e00b              B        |L1.1396|
;;;597    		case UART_1:
;;;598    			LPC_UART1->THR = Data & UART_THR_MASKBIT;
00055c  4ab3              LDR      r2,|L1.2092|
00055e  7011              STRB     r1,[r2,#0]
;;;599    			break;	
000560  e008              B        |L1.1396|
;;;600    		case UART_2:
;;;601    			LPC_UART2->THR = Data & UART_THR_MASKBIT;
000562  4ab6              LDR      r2,|L1.2108|
000564  7011              STRB     r1,[r2,#0]
;;;602    			break;
000566  e005              B        |L1.1396|
;;;603    		case UART_3:
;;;604    			LPC_UART3->THR = Data & UART_THR_MASKBIT;
000568  4ab5              LDR      r2,|L1.2112|
00056a  7011              STRB     r1,[r2,#0]
;;;605    			break;
00056c  e002              B        |L1.1396|
;;;606    		case UART_4:
;;;607    			LPC_UART4->THR = Data & UART_THR_MASKBIT;
00056e  4ab0              LDR      r2,|L1.2096|
000570  6011              STR      r1,[r2,#0]
;;;608    			break;
000572  bf00              NOP      
                  |L1.1396|
000574  bf00              NOP                            ;596
;;;609    	}
;;;610    
;;;611    }
000576  4770              BX       lr
;;;612    
                          ENDP

                  UART_ReceiveByte PROC
;;;623     **********************************************************************/
;;;624    uint8_t UART_ReceiveByte(UART_ID_Type UartID)
000578  4601              MOV      r1,r0
;;;625    {
;;;626    	switch (UartID)
00057a  2905              CMP      r1,#5
00057c  d214              BCS      |L1.1448|
00057e  e8dff001          TBB      [pc,r1]
000582  0306              DCB      0x03,0x06
000584  090c0f00          DCB      0x09,0x0c,0x0f,0x00
;;;627    	{
;;;628    		case UART_0:
;;;629    			return (LPC_UART0->RBR & UART_RBR_MASKBIT);
000588  48ab              LDR      r0,|L1.2104|
00058a  7800              LDRB     r0,[r0,#0]
                  |L1.1420|
;;;630    		case UART_1:
;;;631    			return (LPC_UART1->RBR & UART_RBR_MASKBIT);	
;;;632    		case UART_2:
;;;633    			return (LPC_UART2->RBR & UART_RBR_MASKBIT);
;;;634    		case UART_3:
;;;635    			return (LPC_UART3->RBR & UART_RBR_MASKBIT);
;;;636    		case UART_4:
;;;637    			return (LPC_UART4->RBR & UART_RBR_MASKBIT);
;;;638    	}
;;;639        return 0x00;
;;;640    }
00058c  4770              BX       lr
00058e  48a7              LDR      r0,|L1.2092|
000590  7800              LDRB     r0,[r0,#0]            ;631
000592  e7fb              B        |L1.1420|
000594  48a9              LDR      r0,|L1.2108|
000596  7800              LDRB     r0,[r0,#0]            ;633
000598  e7f8              B        |L1.1420|
00059a  48a9              LDR      r0,|L1.2112|
00059c  7800              LDRB     r0,[r0,#0]            ;635
00059e  e7f5              B        |L1.1420|
0005a0  48a3              LDR      r0,|L1.2096|
0005a2  6800              LDR      r0,[r0,#0]            ;637
0005a4  b2c0              UXTB     r0,r0                 ;637
0005a6  e7f1              B        |L1.1420|
                  |L1.1448|
0005a8  2000              MOVS     r0,#0                 ;639
0005aa  e7ef              B        |L1.1420|
;;;641    
                          ENDP

                  UART_Send PROC
;;;658     **********************************************************************/
;;;659    uint32_t UART_Send(UART_ID_Type UartID, uint8_t *txbuf,
0005ac  e92d4fff          PUSH     {r0-r11,lr}
;;;660    							uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;661    {
0005b0  4607              MOV      r7,r0
0005b2  4691              MOV      r9,r2
0005b4  469a              MOV      r10,r3
;;;662    	uint32_t bToSend, bSent, timeOut, fifo_cnt;
;;;663    	uint8_t *pChar = txbuf;
0005b6  9e01              LDR      r6,[sp,#4]
;;;664    	__IO uint32_t *LSR = NULL;
0005b8  f04f0b00          MOV      r11,#0
;;;665    
;;;666    	switch (UartID)
0005bc  2f05              CMP      r7,#5
0005be  d21d              BCS      |L1.1532|
0005c0  e8dff007          TBB      [pc,r7]
0005c4  03080d12          DCB      0x03,0x08,0x0d,0x12
0005c8  1700              DCB      0x17,0x00
;;;667    	{
;;;668    		case UART_0:
;;;669    			LSR = (__IO uint32_t *)&LPC_UART0->LSR;
0005ca  f8dfb26c          LDR      r11,|L1.2104|
0005ce  f10b0b14          ADD      r11,r11,#0x14
;;;670    			break;
0005d2  e013              B        |L1.1532|
;;;671    		case UART_1:
;;;672    			LSR = (__IO uint32_t *)&LPC_UART1->LSR;
0005d4  f8dfb254          LDR      r11,|L1.2092|
0005d8  f10b0b14          ADD      r11,r11,#0x14
;;;673    			break;
0005dc  e00e              B        |L1.1532|
;;;674    		case UART_2:
;;;675    			LSR = (__IO uint32_t *)&LPC_UART2->LSR;
0005de  f8dfb25c          LDR      r11,|L1.2108|
0005e2  f10b0b14          ADD      r11,r11,#0x14
;;;676    			break;
0005e6  e009              B        |L1.1532|
;;;677    		case UART_3:
;;;678    			LSR = (__IO uint32_t *)&LPC_UART3->LSR;
0005e8  f8dfb254          LDR      r11,|L1.2112|
0005ec  f10b0b14          ADD      r11,r11,#0x14
;;;679    			break;
0005f0  e004              B        |L1.1532|
;;;680    		case UART_4:
;;;681    			LSR = (__IO uint32_t *)&LPC_UART4->LSR;
0005f2  f8dfb23c          LDR      r11,|L1.2096|
0005f6  f10b0b14          ADD      r11,r11,#0x14
;;;682    			break;
0005fa  bf00              NOP      
                  |L1.1532|
0005fc  bf00              NOP                            ;670
;;;683    	}
;;;684    
;;;685    	bToSend = buflen;
0005fe  464b              MOV      r3,r9
;;;686    
;;;687    	// blocking mode
;;;688    	if (flag == BLOCKING)
000600  f1ba0f01          CMP      r10,#1
000604  d124              BNE      |L1.1616|
;;;689    	{
;;;690    		bSent = 0;
000606  2400              MOVS     r4,#0
;;;691    		while (bToSend)
000608  e01f              B        |L1.1610|
                  |L1.1546|
;;;692    		{
;;;693    			timeOut = UART_BLOCKING_TIMEOUT;
00060a  f04f38ff          MOV      r8,#0xffffffff
;;;694    
;;;695    			// Wait for THR empty with timeout
;;;696    			while (!(*LSR & UART_LSR_THRE))
00060e  e005              B        |L1.1564|
                  |L1.1552|
;;;697    			{
;;;698    				if (timeOut == 0)
000610  f1b80f00          CMP      r8,#0
000614  d100              BNE      |L1.1560|
;;;699    					break;
000616  e006              B        |L1.1574|
                  |L1.1560|
;;;700    
;;;701    				timeOut--;
000618  f1a80801          SUB      r8,r8,#1
                  |L1.1564|
00061c  f8db0000          LDR      r0,[r11,#0]           ;696
000620  f0100f20          TST      r0,#0x20              ;696
000624  d0f4              BEQ      |L1.1552|
                  |L1.1574|
000626  bf00              NOP                            ;699
;;;702    			}
;;;703    
;;;704    			// Time out!
;;;705    			if(timeOut == 0)
000628  f1b80f00          CMP      r8,#0
00062c  d100              BNE      |L1.1584|
;;;706    				break;
00062e  e00e              B        |L1.1614|
                  |L1.1584|
;;;707    
;;;708    			fifo_cnt = UART_TX_FIFO_SIZE;
000630  2510              MOVS     r5,#0x10
;;;709    
;;;710    			while (fifo_cnt && bToSend)
000632  e007              B        |L1.1604|
                  |L1.1588|
;;;711    			{
;;;712    				UART_SendByte(UartID, (*pChar++));
000634  f8161b01          LDRB     r1,[r6],#1
000638  4638              MOV      r0,r7
00063a  f7fffffe          BL       UART_SendByte
;;;713    
;;;714    				fifo_cnt--;
00063e  1e6d              SUBS     r5,r5,#1
;;;715    
;;;716    				bToSend--;
000640  1e5b              SUBS     r3,r3,#1
;;;717    
;;;718    				bSent++;
000642  1c64              ADDS     r4,r4,#1
                  |L1.1604|
000644  b10d              CBZ      r5,|L1.1610|
000646  2b00              CMP      r3,#0                 ;710
000648  d1f4              BNE      |L1.1588|
                  |L1.1610|
00064a  2b00              CMP      r3,#0                 ;691
00064c  d1dd              BNE      |L1.1546|
                  |L1.1614|
00064e  e019              B        |L1.1668|
                  |L1.1616|
;;;719    			}
;;;720    		}
;;;721    	}
;;;722    
;;;723    	// None blocking mode
;;;724    	else
;;;725    	{
;;;726    		bSent = 0;
000650  2400              MOVS     r4,#0
;;;727    		while (bToSend)
000652  e014              B        |L1.1662|
                  |L1.1620|
;;;728    		{
;;;729    			if (bToSend == 0)
000654  b903              CBNZ     r3,|L1.1624|
;;;730    				break;
000656  e014              B        |L1.1666|
                  |L1.1624|
;;;731    
;;;732    			if (!(*LSR & UART_LSR_THRE))
000658  f8db0000          LDR      r0,[r11,#0]
00065c  f0100f20          TST      r0,#0x20
000660  d100              BNE      |L1.1636|
;;;733    			{
;;;734    				break;
000662  e00e              B        |L1.1666|
                  |L1.1636|
;;;735    			}
;;;736    
;;;737    			fifo_cnt = UART_TX_FIFO_SIZE;
000664  2510              MOVS     r5,#0x10
;;;738    
;;;739    			while (fifo_cnt && bToSend)
000666  e007              B        |L1.1656|
                  |L1.1640|
;;;740    			{
;;;741    				UART_SendByte(UartID, (*pChar++));
000668  f8161b01          LDRB     r1,[r6],#1
00066c  4638              MOV      r0,r7
00066e  f7fffffe          BL       UART_SendByte
;;;742    
;;;743    				bToSend--;
000672  1e5b              SUBS     r3,r3,#1
;;;744    
;;;745    				fifo_cnt--;
000674  1e6d              SUBS     r5,r5,#1
;;;746    
;;;747    				bSent++;
000676  1c64              ADDS     r4,r4,#1
                  |L1.1656|
000678  b10d              CBZ      r5,|L1.1662|
00067a  2b00              CMP      r3,#0                 ;739
00067c  d1f4              BNE      |L1.1640|
                  |L1.1662|
00067e  2b00              CMP      r3,#0                 ;727
000680  d1e8              BNE      |L1.1620|
                  |L1.1666|
000682  bf00              NOP                            ;730
                  |L1.1668|
;;;748    			}
;;;749    		}
;;;750    	}
;;;751    
;;;752    	return bSent;
000684  4620              MOV      r0,r4
;;;753    }
000686  b004              ADD      sp,sp,#0x10
000688  e8bd8ff0          POP      {r4-r11,pc}
;;;754    
                          ENDP

                  UART_Receive PROC
;;;772     **********************************************************************/
;;;773    uint32_t UART_Receive(UART_ID_Type UartID, uint8_t *rxbuf,
00068c  e92d47f0          PUSH     {r4-r10,lr}
;;;774    								uint32_t buflen, TRANSFER_BLOCK_Type flag)
;;;775    {
000690  4605              MOV      r5,r0
000692  460f              MOV      r7,r1
000694  4690              MOV      r8,r2
000696  4699              MOV      r9,r3
;;;776    	uint32_t bToRecv, bRecv, timeOut;
;;;777    	uint8_t *pChar = rxbuf;
000698  463c              MOV      r4,r7
;;;778    	__IO uint32_t *LSR = NULL;
00069a  f04f0a00          MOV      r10,#0
;;;779    
;;;780    	switch (UartID)
00069e  2d05              CMP      r5,#5
0006a0  d21d              BCS      |L1.1758|
0006a2  e8dff005          TBB      [pc,r5]
0006a6  0308              DCB      0x03,0x08
0006a8  0d121700          DCB      0x0d,0x12,0x17,0x00
;;;781    	{
;;;782    		case UART_0:
;;;783    			LSR = (__IO uint32_t *)&LPC_UART0->LSR;
0006ac  f8dfa188          LDR      r10,|L1.2104|
0006b0  f10a0a14          ADD      r10,r10,#0x14
;;;784    			break;
0006b4  e013              B        |L1.1758|
;;;785    		case UART_1:
;;;786    			LSR = (__IO uint32_t *)&LPC_UART1->LSR;
0006b6  f8dfa174          LDR      r10,|L1.2092|
0006ba  f10a0a14          ADD      r10,r10,#0x14
;;;787    			break;
0006be  e00e              B        |L1.1758|
;;;788    		case UART_2:
;;;789    			LSR = (__IO uint32_t *)&LPC_UART2->LSR;
0006c0  f8dfa178          LDR      r10,|L1.2108|
0006c4  f10a0a14          ADD      r10,r10,#0x14
;;;790    			break;
0006c8  e009              B        |L1.1758|
;;;791    		case UART_3:
;;;792    			LSR = (__IO uint32_t *)&LPC_UART3->LSR;
0006ca  f8dfa174          LDR      r10,|L1.2112|
0006ce  f10a0a14          ADD      r10,r10,#0x14
;;;793    			break;
0006d2  e004              B        |L1.1758|
;;;794    		case UART_4:
;;;795    			LSR = (__IO uint32_t *)&LPC_UART4->LSR;
0006d4  f8dfa158          LDR      r10,|L1.2096|
0006d8  f10a0a14          ADD      r10,r10,#0x14
;;;796    			break;
0006dc  bf00              NOP      
                  |L1.1758|
0006de  bf00              NOP                            ;784
;;;797    	}
;;;798    	
;;;799    	bToRecv = buflen;
0006e0  4642              MOV      r2,r8
;;;800    
;;;801    	// Blocking mode
;;;802    	if (flag == BLOCKING)
0006e2  f1b90f01          CMP      r9,#1
0006e6  d119              BNE      |L1.1820|
;;;803    	{
;;;804    		bRecv = 0;
0006e8  2300              MOVS     r3,#0
;;;805    		while (bToRecv)
0006ea  e014              B        |L1.1814|
                  |L1.1772|
;;;806    		{
;;;807    			timeOut = UART_BLOCKING_TIMEOUT;
0006ec  f04f36ff          MOV      r6,#0xffffffff
;;;808    			while (!(*LSR & UART_LSR_RDR))
0006f0  e002              B        |L1.1784|
                  |L1.1778|
;;;809    			{
;;;810    				if (timeOut == 0)
0006f2  b906              CBNZ     r6,|L1.1782|
;;;811    					break;
0006f4  e005              B        |L1.1794|
                  |L1.1782|
;;;812    
;;;813    				timeOut--;
0006f6  1e76              SUBS     r6,r6,#1
                  |L1.1784|
0006f8  f8da0000          LDR      r0,[r10,#0]           ;808
0006fc  f0100f01          TST      r0,#1                 ;808
000700  d0f7              BEQ      |L1.1778|
                  |L1.1794|
000702  bf00              NOP                            ;811
;;;814    			}
;;;815    
;;;816    			// Time out!
;;;817    			if(timeOut == 0)
000704  b906              CBNZ     r6,|L1.1800|
;;;818    				break;
000706  e008              B        |L1.1818|
                  |L1.1800|
;;;819    
;;;820    			// Get data from the buffer
;;;821    			(*pChar++) = UART_ReceiveByte(UartID);
000708  4628              MOV      r0,r5
00070a  f7fffffe          BL       UART_ReceiveByte
00070e  f8040b01          STRB     r0,[r4],#1
;;;822    
;;;823    			bToRecv--;
000712  1e52              SUBS     r2,r2,#1
;;;824    
;;;825    			bRecv++;
000714  1c5b              ADDS     r3,r3,#1
                  |L1.1814|
000716  2a00              CMP      r2,#0                 ;805
000718  d1e8              BNE      |L1.1772|
                  |L1.1818|
00071a  e011              B        |L1.1856|
                  |L1.1820|
;;;826    		}
;;;827    	}
;;;828    	// None blocking mode
;;;829    	else
;;;830    	{
;;;831    		bRecv = 0;
00071c  2300              MOVS     r3,#0
;;;832    		while (bToRecv)
00071e  e00c              B        |L1.1850|
                  |L1.1824|
;;;833    		{
;;;834    			if (!(*LSR & UART_LSR_RDR))
000720  f8da0000          LDR      r0,[r10,#0]
000724  f0100f01          TST      r0,#1
000728  d100              BNE      |L1.1836|
;;;835    			{
;;;836    				break;
00072a  e008              B        |L1.1854|
                  |L1.1836|
;;;837    			}
;;;838    			else
;;;839    			{
;;;840    				(*pChar++) = UART_ReceiveByte(UartID);
00072c  4628              MOV      r0,r5
00072e  f7fffffe          BL       UART_ReceiveByte
000732  f8040b01          STRB     r0,[r4],#1
;;;841    
;;;842    				bRecv++;
000736  1c5b              ADDS     r3,r3,#1
;;;843    
;;;844    				bToRecv--;
000738  1e52              SUBS     r2,r2,#1
                  |L1.1850|
00073a  2a00              CMP      r2,#0                 ;832
00073c  d1f0              BNE      |L1.1824|
                  |L1.1854|
00073e  bf00              NOP                            ;836
                  |L1.1856|
;;;845    			}
;;;846    		}
;;;847    	}
;;;848    
;;;849    	return bRecv;
000740  4618              MOV      r0,r3
;;;850    }
000742  e8bd87f0          POP      {r4-r10,pc}
;;;851    
                          ENDP

                  UART_ForceBreak PROC
;;;862     **********************************************************************/
;;;863    void UART_ForceBreak(UART_ID_Type UartID)
000746  2805              CMP      r0,#5
;;;864    {
;;;865    	switch (UartID)
000748  d227              BCS      |L1.1946|
00074a  e8dff000          TBB      [pc,r0]
00074e  030a              DCB      0x03,0x0a
000750  11181f00          DCB      0x11,0x18,0x1f,0x00
;;;866    	{
;;;867    		case UART_0:
;;;868    			LPC_UART0->LCR |= UART_LCR_BREAK_EN;
000754  4938              LDR      r1,|L1.2104|
000756  7b09              LDRB     r1,[r1,#0xc]
000758  f0410140          ORR      r1,r1,#0x40
00075c  4a36              LDR      r2,|L1.2104|
00075e  7311              STRB     r1,[r2,#0xc]
;;;869    			break;
000760  e01b              B        |L1.1946|
;;;870    		case UART_1:
;;;871    			LPC_UART1->LCR |= UART_LCR_BREAK_EN;
000762  4932              LDR      r1,|L1.2092|
000764  7b09              LDRB     r1,[r1,#0xc]
000766  f0410140          ORR      r1,r1,#0x40
00076a  4a30              LDR      r2,|L1.2092|
00076c  7311              STRB     r1,[r2,#0xc]
;;;872    			break;
00076e  e014              B        |L1.1946|
;;;873    		case UART_2:
;;;874    			LPC_UART2->LCR |= UART_LCR_BREAK_EN;
000770  4932              LDR      r1,|L1.2108|
000772  7b09              LDRB     r1,[r1,#0xc]
000774  f0410140          ORR      r1,r1,#0x40
000778  4a30              LDR      r2,|L1.2108|
00077a  7311              STRB     r1,[r2,#0xc]
;;;875    			break;
00077c  e00d              B        |L1.1946|
;;;876    		case UART_3:
;;;877    			LPC_UART3->LCR |= UART_LCR_BREAK_EN;
00077e  4930              LDR      r1,|L1.2112|
000780  7b09              LDRB     r1,[r1,#0xc]
000782  f0410140          ORR      r1,r1,#0x40
000786  4a2e              LDR      r2,|L1.2112|
000788  7311              STRB     r1,[r2,#0xc]
;;;878    			break;
00078a  e006              B        |L1.1946|
;;;879    		case UART_4:
;;;880    			LPC_UART4->LCR |= UART_LCR_BREAK_EN;
00078c  4928              LDR      r1,|L1.2096|
00078e  68c9              LDR      r1,[r1,#0xc]
000790  f0410140          ORR      r1,r1,#0x40
000794  4a26              LDR      r2,|L1.2096|
000796  60d1              STR      r1,[r2,#0xc]
;;;881    			break;
000798  bf00              NOP      
                  |L1.1946|
00079a  bf00              NOP                            ;869
;;;882    	}
;;;883    }
00079c  4770              BX       lr
;;;884    
                          ENDP

                  UART_IntConfig PROC
;;;908     *********************************************************************/
;;;909    void UART_IntConfig(UART_ID_Type UartID, UART_INT_Type UARTIntCfg, FunctionalState NewState)
00079e  b570              PUSH     {r4-r6,lr}
;;;910    {
0007a0  4603              MOV      r3,r0
0007a2  460c              MOV      r4,r1
;;;911    	uint32_t tmp;
;;;912    	__IO uint32_t *IER = NULL;
0007a4  2100              MOVS     r1,#0
;;;913    	uint32_t IERMask = 0;
0007a6  468c              MOV      r12,r1
;;;914    
;;;915    	switch (UartID)
0007a8  2b05              CMP      r3,#5
0007aa  d21d              BCS      |L1.2024|
0007ac  e8dff003          TBB      [pc,r3]
0007b0  03080d12          DCB      0x03,0x08,0x0d,0x12
0007b4  1700              DCB      0x17,0x00
;;;916    	{
;;;917    		case UART_0:
;;;918    			IER = &LPC_UART0->IER;
0007b6  4920              LDR      r1,|L1.2104|
0007b8  1d09              ADDS     r1,r1,#4
;;;919    			IERMask = UART_IER_BITMASK;
0007ba  f2403c07          MOV      r12,#0x307
;;;920    			break;
0007be  e013              B        |L1.2024|
;;;921    		case UART_1:
;;;922    			IER = &LPC_UART1->IER;
0007c0  491a              LDR      r1,|L1.2092|
0007c2  1d09              ADDS     r1,r1,#4
;;;923    			IERMask = UART1_IER_BITMASK;
0007c4  f2403c8f          MOV      r12,#0x38f
;;;924    			break;
0007c8  e00e              B        |L1.2024|
;;;925    		case UART_2:
;;;926    			IER = &LPC_UART2->IER;
0007ca  491c              LDR      r1,|L1.2108|
0007cc  1d09              ADDS     r1,r1,#4
;;;927    			IERMask = UART_IER_BITMASK;
0007ce  f2403c07          MOV      r12,#0x307
;;;928    			break;
0007d2  e009              B        |L1.2024|
;;;929    		case UART_3:
;;;930    			IER = &LPC_UART3->IER;
0007d4  491a              LDR      r1,|L1.2112|
0007d6  1d09              ADDS     r1,r1,#4
;;;931    			IERMask = UART_IER_BITMASK;
0007d8  f2403c07          MOV      r12,#0x307
;;;932    			break;
0007dc  e004              B        |L1.2024|
;;;933    		case UART_4:
;;;934    			IER = &LPC_UART4->IER;
0007de  4914              LDR      r1,|L1.2096|
0007e0  1d09              ADDS     r1,r1,#4
;;;935    			IERMask = UART_IER_BITMASK;
0007e2  f2403c07          MOV      r12,#0x307
;;;936    			break;
0007e6  bf00              NOP      
                  |L1.2024|
0007e8  bf00              NOP                            ;920
;;;937    	}
;;;938    
;;;939    
;;;940    	switch(UARTIntCfg)
0007ea  2c07              CMP      r4,#7
0007ec  d215              BCS      |L1.2074|
0007ee  e8dff004          TBB      [pc,r4]
0007f2  0406              DCB      0x04,0x06
0007f4  080a0c0e          DCB      0x08,0x0a,0x0c,0x0e
0007f8  1100              DCB      0x11,0x00
;;;941    	{
;;;942    		case UART_INTCFG_RBR:
;;;943    			tmp = UART_IER_RBRINT_EN;
0007fa  2001              MOVS     r0,#1
;;;944    			break;
0007fc  e00d              B        |L1.2074|
;;;945    
;;;946    		case UART_INTCFG_THRE:
;;;947    			tmp = UART_IER_THREINT_EN;
0007fe  2002              MOVS     r0,#2
;;;948    			break;
000800  e00b              B        |L1.2074|
;;;949    
;;;950    		case UART_INTCFG_RLS:
;;;951    			tmp = UART_IER_RLSINT_EN;
000802  2004              MOVS     r0,#4
;;;952    			break;
000804  e009              B        |L1.2074|
;;;953    
;;;954    		case UART_INTCFG_MS:
;;;955    			tmp = UART1_IER_MSINT_EN;
000806  2008              MOVS     r0,#8
;;;956    			break;
000808  e007              B        |L1.2074|
;;;957    
;;;958    		case UART_INTCFG_CTS:
;;;959    			tmp = UART1_IER_CTSINT_EN;
00080a  2080              MOVS     r0,#0x80
;;;960    			break;
00080c  e005              B        |L1.2074|
;;;961    
;;;962    		case UART_INTCFG_ABEO:
;;;963    			tmp = UART_IER_ABEOINT_EN;
00080e  f44f7080          MOV      r0,#0x100
;;;964    			break;
000812  e002              B        |L1.2074|
;;;965    
;;;966    		case UART_INTCFG_ABTO:
;;;967    			tmp = UART_IER_ABTOINT_EN;
000814  f44f7000          MOV      r0,#0x200
;;;968    			break;
000818  bf00              NOP      
                  |L1.2074|
00081a  bf00              NOP                            ;944
;;;969    	}
;;;970    
;;;971    	if (NewState == ENABLE)
00081c  2a01              CMP      r2,#1
00081e  d111              BNE      |L1.2116|
;;;972    	{
;;;973    		*IER |= tmp& IERMask;
000820  680d              LDR      r5,[r1,#0]
000822  ea00060c          AND      r6,r0,r12
000826  4335              ORRS     r5,r5,r6
000828  600d              STR      r5,[r1,#0]
00082a  e010              B        |L1.2126|
                  |L1.2092|
                          DCD      0x40010000
                  |L1.2096|
                          DCD      0x400a4000
                  |L1.2100|
                          DCD      0x40010030
                  |L1.2104|
                          DCD      0x4000c000
                  |L1.2108|
                          DCD      0x40098000
                  |L1.2112|
                          DCD      0x4009c000
                  |L1.2116|
;;;974    	}
;;;975    	else
;;;976    	{
;;;977    		*IER &= (~tmp) & IERMask;
000844  680d              LDR      r5,[r1,#0]
000846  ea2c0600          BIC      r6,r12,r0
00084a  4035              ANDS     r5,r5,r6
00084c  600d              STR      r5,[r1,#0]
                  |L1.2126|
;;;978    	}
;;;979    }
00084e  bd70              POP      {r4-r6,pc}
;;;980    
                          ENDP

                  UART_GetLineStatus PROC
;;;998     *********************************************************************/
;;;999    uint8_t UART_GetLineStatus(UART_ID_Type UartID)
000850  4601              MOV      r1,r0
;;;1000   {
;;;1001   	switch (UartID)
000852  2905              CMP      r1,#5
000854  d214              BCS      |L1.2176|
000856  e8dff001          TBB      [pc,r1]
00085a  0306              DCB      0x03,0x06
00085c  090c0f00          DCB      0x09,0x0c,0x0f,0x00
;;;1002   	{
;;;1003   		case UART_0:
;;;1004   			return ((LPC_UART0->LSR) & UART_LSR_BITMASK);
000860  48fe              LDR      r0,|L1.3164|
000862  7d00              LDRB     r0,[r0,#0x14]
                  |L1.2148|
;;;1005   		case UART_1:
;;;1006   			return ((LPC_UART1->LSR) & UART_LSR_BITMASK);
;;;1007   		case UART_2:
;;;1008   			return ((LPC_UART2->LSR) & UART_LSR_BITMASK);
;;;1009   		case UART_3:
;;;1010   			return ((LPC_UART3->LSR) & UART_LSR_BITMASK);
;;;1011   		case UART_4:
;;;1012   			return ((LPC_UART4->LSR) & UART_LSR_BITMASK);
;;;1013   	}
;;;1014       return 0;
;;;1015   }
000864  4770              BX       lr
000866  48fe              LDR      r0,|L1.3168|
000868  7d00              LDRB     r0,[r0,#0x14]         ;1006
00086a  e7fb              B        |L1.2148|
00086c  48fd              LDR      r0,|L1.3172|
00086e  7d00              LDRB     r0,[r0,#0x14]         ;1008
000870  e7f8              B        |L1.2148|
000872  48fd              LDR      r0,|L1.3176|
000874  7d00              LDRB     r0,[r0,#0x14]         ;1010
000876  e7f5              B        |L1.2148|
000878  48fc              LDR      r0,|L1.3180|
00087a  6940              LDR      r0,[r0,#0x14]         ;1012
00087c  b2c0              UXTB     r0,r0                 ;1012
00087e  e7f1              B        |L1.2148|
                  |L1.2176|
000880  2000              MOVS     r0,#0                 ;1014
000882  e7ef              B        |L1.2148|
;;;1016   
                          ENDP

                  UART_GetIntId PROC
;;;1026    *********************************************************************/
;;;1027   uint32_t UART_GetIntId(UART_ID_Type UartID)
000884  4601              MOV      r1,r0
;;;1028   {
;;;1029   	switch (UartID)
000886  2905              CMP      r1,#5
000888  d222              BCS      |L1.2256|
00088a  e8dff001          TBB      [pc,r1]
00088e  0309              DCB      0x03,0x09
000890  0f151b00          DCB      0x0f,0x15,0x1b,0x00
;;;1030   	{
;;;1031   		case UART_0:
;;;1032   			return ((LPC_UART0->IIR) & UART_IIR_BITMASK);
000894  48f1              LDR      r0,|L1.3164|
000896  6880              LDR      r0,[r0,#8]
000898  f24032cf          MOV      r2,#0x3cf
00089c  4010              ANDS     r0,r0,r2
                  |L1.2206|
;;;1033   		case UART_1:
;;;1034   			return ((LPC_UART1->IIR) & UART_IIR_BITMASK);
;;;1035   		case UART_2:
;;;1036   			return ((LPC_UART2->IIR) & UART_IIR_BITMASK);
;;;1037   		case UART_3:
;;;1038   			return ((LPC_UART3->IIR) & UART_IIR_BITMASK);
;;;1039   		case UART_4:
;;;1040   			return ((LPC_UART4->IIR) & UART_IIR_BITMASK);
;;;1041   	}
;;;1042       return 0;
;;;1043   }
00089e  4770              BX       lr
0008a0  48ef              LDR      r0,|L1.3168|
0008a2  6880              LDR      r0,[r0,#8]            ;1034
0008a4  f24032cf          MOV      r2,#0x3cf             ;1034
0008a8  4010              ANDS     r0,r0,r2              ;1034
0008aa  e7f8              B        |L1.2206|
0008ac  48ed              LDR      r0,|L1.3172|
0008ae  6880              LDR      r0,[r0,#8]            ;1036
0008b0  f24032cf          MOV      r2,#0x3cf             ;1036
0008b4  4010              ANDS     r0,r0,r2              ;1036
0008b6  e7f2              B        |L1.2206|
0008b8  48eb              LDR      r0,|L1.3176|
0008ba  6880              LDR      r0,[r0,#8]            ;1038
0008bc  f24032cf          MOV      r2,#0x3cf             ;1038
0008c0  4010              ANDS     r0,r0,r2              ;1038
0008c2  e7ec              B        |L1.2206|
0008c4  48e9              LDR      r0,|L1.3180|
0008c6  6880              LDR      r0,[r0,#8]            ;1040
0008c8  f24032cf          MOV      r2,#0x3cf             ;1040
0008cc  4010              ANDS     r0,r0,r2              ;1040
0008ce  e7e6              B        |L1.2206|
                  |L1.2256|
0008d0  2000              MOVS     r0,#0                 ;1042
0008d2  e7e4              B        |L1.2206|
;;;1044   
                          ENDP

                  UART_CheckBusy PROC
;;;1054    **********************************************************************/
;;;1055   FlagStatus UART_CheckBusy(UART_ID_Type UartID)
0008d4  4601              MOV      r1,r0
;;;1056   {
;;;1057   	uint32_t LSR = 0;
0008d6  2200              MOVS     r2,#0
;;;1058   	switch (UartID)
0008d8  2905              CMP      r1,#5
0008da  d21d              BCS      |L1.2328|
0008dc  e8dff001          TBB      [pc,r1]
0008e0  03080d12          DCB      0x03,0x08,0x0d,0x12
0008e4  1700              DCB      0x17,0x00
;;;1059   	{
;;;1060   		case UART_0:
;;;1061   			LSR = (LPC_UART0)->LSR & UART_LSR_TEMT;
0008e6  48dd              LDR      r0,|L1.3164|
0008e8  7d00              LDRB     r0,[r0,#0x14]
0008ea  f0000240          AND      r2,r0,#0x40
;;;1062   			break;
0008ee  e013              B        |L1.2328|
;;;1063   		case UART_1:
;;;1064   			LSR = (LPC_UART1)->LSR & UART_LSR_TEMT;
0008f0  48db              LDR      r0,|L1.3168|
0008f2  7d00              LDRB     r0,[r0,#0x14]
0008f4  f0000240          AND      r2,r0,#0x40
;;;1065   			break;
0008f8  e00e              B        |L1.2328|
;;;1066   		case UART_2:
;;;1067   			LSR = (LPC_UART2)->LSR & UART_LSR_TEMT;
0008fa  48da              LDR      r0,|L1.3172|
0008fc  7d00              LDRB     r0,[r0,#0x14]
0008fe  f0000240          AND      r2,r0,#0x40
;;;1068   			break;
000902  e009              B        |L1.2328|
;;;1069   		case UART_3:
;;;1070   			LSR = (LPC_UART3)->LSR & UART_LSR_TEMT;
000904  48d8              LDR      r0,|L1.3176|
000906  7d00              LDRB     r0,[r0,#0x14]
000908  f0000240          AND      r2,r0,#0x40
;;;1071   			break;
00090c  e004              B        |L1.2328|
;;;1072   		case UART_4:
;;;1073   			LSR = (LPC_UART4)->LSR & UART_LSR_TEMT;
00090e  48d7              LDR      r0,|L1.3180|
000910  6940              LDR      r0,[r0,#0x14]
000912  f0000240          AND      r2,r0,#0x40
;;;1074   			break;
000916  bf00              NOP      
                  |L1.2328|
000918  bf00              NOP                            ;1062
;;;1075   	}
;;;1076   	
;;;1077   	if (LSR & UART_LSR_TEMT)
00091a  f0120f40          TST      r2,#0x40
00091e  d001              BEQ      |L1.2340|
;;;1078   	{
;;;1079   		return RESET;
000920  2000              MOVS     r0,#0
                  |L1.2338|
;;;1080   	}
;;;1081   	return SET;
;;;1082   }
000922  4770              BX       lr
                  |L1.2340|
000924  2001              MOVS     r0,#1                 ;1081
000926  e7fc              B        |L1.2338|
;;;1083   
                          ENDP

                  UART_FIFOConfig PROC
;;;1096    **********************************************************************/
;;;1097   void UART_FIFOConfig(UART_ID_Type UartID, UART_FIFO_CFG_Type *FIFOCfg)
000928  b510              PUSH     {r4,lr}
;;;1098   {
00092a  4602              MOV      r2,r0
;;;1099   	uint8_t tmp = 0;
00092c  2000              MOVS     r0,#0
;;;1100   
;;;1101   	tmp |= UART_FCR_FIFO_EN;
00092e  f0400001          ORR      r0,r0,#1
;;;1102   
;;;1103   	switch (FIFOCfg->FIFO_Level)
000932  78cb              LDRB     r3,[r1,#3]
000934  b133              CBZ      r3,|L1.2372|
000936  2b01              CMP      r3,#1
000938  d006              BEQ      |L1.2376|
00093a  2b02              CMP      r3,#2
00093c  d007              BEQ      |L1.2382|
00093e  2b03              CMP      r3,#3
000940  d108              BNE      |L1.2388|
000942  e008              B        |L1.2390|
                  |L1.2372|
;;;1104   	{
;;;1105   		case UART_FIFO_TRGLEV0:
;;;1106   			tmp |= UART_FCR_TRG_LEV0;
000944  bf00              NOP      
;;;1107   			break;
000946  e009              B        |L1.2396|
                  |L1.2376|
;;;1108   
;;;1109   		case UART_FIFO_TRGLEV1:
;;;1110   			tmp |= UART_FCR_TRG_LEV1;
000948  f0400040          ORR      r0,r0,#0x40
;;;1111   			break;
00094c  e006              B        |L1.2396|
                  |L1.2382|
;;;1112   
;;;1113   		case UART_FIFO_TRGLEV2:
;;;1114   			tmp |= UART_FCR_TRG_LEV2;
00094e  f0400080          ORR      r0,r0,#0x80
;;;1115   			break;
000952  e003              B        |L1.2396|
                  |L1.2388|
;;;1116   
;;;1117   		case UART_FIFO_TRGLEV3:
000954  bf00              NOP      
                  |L1.2390|
;;;1118   
;;;1119   		default:
;;;1120   			tmp |= UART_FCR_TRG_LEV3;
000956  f04000c0          ORR      r0,r0,#0xc0
;;;1121   			break;
00095a  bf00              NOP      
                  |L1.2396|
00095c  bf00              NOP                            ;1107
;;;1122   	}
;;;1123   
;;;1124   	if (FIFOCfg->FIFO_ResetTxBuf == ENABLE)
00095e  784b              LDRB     r3,[r1,#1]
000960  2b01              CMP      r3,#1
000962  d101              BNE      |L1.2408|
;;;1125   	{
;;;1126   		tmp |= UART_FCR_TX_RS;
000964  f0400004          ORR      r0,r0,#4
                  |L1.2408|
;;;1127   	}
;;;1128   
;;;1129   	if (FIFOCfg->FIFO_ResetRxBuf == ENABLE)
000968  780b              LDRB     r3,[r1,#0]
00096a  2b01              CMP      r3,#1
00096c  d101              BNE      |L1.2418|
;;;1130   	{
;;;1131   		tmp |= UART_FCR_RX_RS;
00096e  f0400002          ORR      r0,r0,#2
                  |L1.2418|
;;;1132   	}
;;;1133   
;;;1134   	if (FIFOCfg->FIFO_DMAMode == ENABLE)
000972  788b              LDRB     r3,[r1,#2]
000974  2b01              CMP      r3,#1
000976  d101              BNE      |L1.2428|
;;;1135   	{
;;;1136   		tmp |= UART_FCR_DMAMODE_SEL;
000978  f0400008          ORR      r0,r0,#8
                  |L1.2428|
;;;1137   	}
;;;1138   
;;;1139   
;;;1140   	//write to FIFO control register
;;;1141   	switch (UartID)
00097c  2a05              CMP      r2,#5
00097e  d21d              BCS      |L1.2492|
000980  e8dff002          TBB      [pc,r2]
000984  03080d12          DCB      0x03,0x08,0x0d,0x12
000988  1700              DCB      0x17,0x00
;;;1142   	{
;;;1143   		case UART_0:
;;;1144   			LPC_UART0->FCR = tmp & UART_FCR_BITMASK;
00098a  f00003cf          AND      r3,r0,#0xcf
00098e  4cb3              LDR      r4,|L1.3164|
000990  7223              STRB     r3,[r4,#8]
;;;1145   			break;
000992  e013              B        |L1.2492|
;;;1146   		case UART_1:
;;;1147   			LPC_UART1->FCR = tmp & UART_FCR_BITMASK;
000994  f00003cf          AND      r3,r0,#0xcf
000998  4cb1              LDR      r4,|L1.3168|
00099a  7223              STRB     r3,[r4,#8]
;;;1148   			break;
00099c  e00e              B        |L1.2492|
;;;1149   		case UART_2:
;;;1150   			LPC_UART2->FCR = tmp & UART_FCR_BITMASK;
00099e  f00003cf          AND      r3,r0,#0xcf
0009a2  4cb0              LDR      r4,|L1.3172|
0009a4  7223              STRB     r3,[r4,#8]
;;;1151   			break;
0009a6  e009              B        |L1.2492|
;;;1152   		case UART_3:
;;;1153   			LPC_UART3->FCR = tmp & UART_FCR_BITMASK;
0009a8  f00003cf          AND      r3,r0,#0xcf
0009ac  4cae              LDR      r4,|L1.3176|
0009ae  7223              STRB     r3,[r4,#8]
;;;1154   			break;
0009b0  e004              B        |L1.2492|
;;;1155   		case UART_4:
;;;1156   			LPC_UART4->FCR = tmp & UART_FCR_BITMASK;
0009b2  f00003cf          AND      r3,r0,#0xcf
0009b6  4cad              LDR      r4,|L1.3180|
0009b8  60a3              STR      r3,[r4,#8]
;;;1157   			break;
0009ba  bf00              NOP      
                  |L1.2492|
0009bc  bf00              NOP                            ;1145
;;;1158   	}
;;;1159   }
0009be  bd10              POP      {r4,pc}
;;;1160   
                          ENDP

                  UART_FIFOConfigStructInit PROC
;;;1171   *******************************************************************************/
;;;1172   void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
0009c0  2100              MOVS     r1,#0
;;;1173   {
;;;1174   	UART_FIFOInitStruct->FIFO_DMAMode = DISABLE;
0009c2  7081              STRB     r1,[r0,#2]
;;;1175   
;;;1176   	UART_FIFOInitStruct->FIFO_Level = UART_FIFO_TRGLEV0;
0009c4  70c1              STRB     r1,[r0,#3]
;;;1177   
;;;1178   	UART_FIFOInitStruct->FIFO_ResetRxBuf = ENABLE;
0009c6  2101              MOVS     r1,#1
0009c8  7001              STRB     r1,[r0,#0]
;;;1179   
;;;1180   	UART_FIFOInitStruct->FIFO_ResetTxBuf = ENABLE;
0009ca  7041              STRB     r1,[r0,#1]
;;;1181   }
0009cc  4770              BX       lr
;;;1182   
                          ENDP

                  UART_ABCmd PROC
;;;1201    **********************************************************************/
;;;1202   void UART_ABCmd(UART_ID_Type UartID, UART_AB_CFG_Type *ABConfigStruct,
0009ce  e92d41f0          PUSH     {r4-r8,lr}
;;;1203   							FunctionalState NewState)
;;;1204   {
0009d2  4607              MOV      r7,r0
0009d4  4688              MOV      r8,r1
0009d6  4615              MOV      r5,r2
;;;1205   	uint32_t tmp;
;;;1206   
;;;1207   	tmp = 0;
0009d8  2600              MOVS     r6,#0
;;;1208   	if (NewState == ENABLE)
0009da  2d01              CMP      r5,#1
0009dc  d10b              BNE      |L1.2550|
;;;1209   	{
;;;1210   		if (ABConfigStruct->ABMode == UART_AUTOBAUD_MODE1)
0009de  f8980000          LDRB     r0,[r8,#0]
0009e2  2801              CMP      r0,#1
0009e4  d101              BNE      |L1.2538|
;;;1211   		{
;;;1212   			tmp |= UART_ACR_MODE;
0009e6  f0460602          ORR      r6,r6,#2
                  |L1.2538|
;;;1213   		}
;;;1214   		if (ABConfigStruct->AutoRestart == ENABLE)
0009ea  f8980001          LDRB     r0,[r8,#1]
0009ee  2801              CMP      r0,#1
0009f0  d101              BNE      |L1.2550|
;;;1215   		{
;;;1216   			tmp |= UART_ACR_AUTO_RESTART;
0009f2  f0460604          ORR      r6,r6,#4
                  |L1.2550|
;;;1217   		}
;;;1218   	}
;;;1219   
;;;1220   	if (UartID == UART_1)
0009f6  2f01              CMP      r7,#1
0009f8  d119              BNE      |L1.2606|
;;;1221   	{
;;;1222   		if (NewState == ENABLE)
0009fa  2d01              CMP      r5,#1
0009fc  d113              BNE      |L1.2598|
;;;1223   		{
;;;1224   			// Clear DLL and DLM value
;;;1225   			LPC_UART1->LCR |= UART_LCR_DLAB_EN;
0009fe  4898              LDR      r0,|L1.3168|
000a00  7b00              LDRB     r0,[r0,#0xc]
000a02  f0400080          ORR      r0,r0,#0x80
000a06  4996              LDR      r1,|L1.3168|
000a08  7308              STRB     r0,[r1,#0xc]
;;;1226   
;;;1227   			LPC_UART1->DLL = 0;
000a0a  2000              MOVS     r0,#0
000a0c  7008              STRB     r0,[r1,#0]
;;;1228   
;;;1229   			LPC_UART1->DLM = 0;
000a0e  7108              STRB     r0,[r1,#4]
;;;1230   
;;;1231   			LPC_UART1->LCR &= ~UART_LCR_DLAB_EN;
000a10  4608              MOV      r0,r1
000a12  7b00              LDRB     r0,[r0,#0xc]
000a14  f0200080          BIC      r0,r0,#0x80
000a18  7308              STRB     r0,[r1,#0xc]
;;;1232   
;;;1233   			// FDR value must be reset to default value
;;;1234   			LPC_UART1->FDR = 0x10;
000a1a  2010              MOVS     r0,#0x10
000a1c  6288              STR      r0,[r1,#0x28]
;;;1235   
;;;1236   			LPC_UART1->ACR = UART_ACR_START | tmp;
000a1e  f0460001          ORR      r0,r6,#1
000a22  6208              STR      r0,[r1,#0x20]
000a24  e03a              B        |L1.2716|
                  |L1.2598|
;;;1237   		}
;;;1238   		else
;;;1239   		{
;;;1240   			LPC_UART1->ACR = 0;
000a26  2000              MOVS     r0,#0
000a28  498d              LDR      r1,|L1.3168|
000a2a  6208              STR      r0,[r1,#0x20]
000a2c  e036              B        |L1.2716|
                  |L1.2606|
;;;1241   		}
;;;1242   	}
;;;1243   	else if (UartID == UART_4)
000a2e  2f04              CMP      r7,#4
000a30  d119              BNE      |L1.2662|
;;;1244   	{
;;;1245   		if (NewState == ENABLE)
000a32  2d01              CMP      r5,#1
000a34  d113              BNE      |L1.2654|
;;;1246   		{
;;;1247   			// Clear DLL and DLM value
;;;1248   			LPC_UART4->LCR |= UART_LCR_DLAB_EN;
000a36  488d              LDR      r0,|L1.3180|
000a38  68c0              LDR      r0,[r0,#0xc]
000a3a  f0400080          ORR      r0,r0,#0x80
000a3e  498b              LDR      r1,|L1.3180|
000a40  60c8              STR      r0,[r1,#0xc]
;;;1249   
;;;1250   			LPC_UART4->DLL = 0;
000a42  2000              MOVS     r0,#0
000a44  6008              STR      r0,[r1,#0]
;;;1251   
;;;1252   			LPC_UART4->DLM = 0;
000a46  6048              STR      r0,[r1,#4]
;;;1253   
;;;1254   			LPC_UART4->LCR &= ~UART_LCR_DLAB_EN;
000a48  4608              MOV      r0,r1
000a4a  68c0              LDR      r0,[r0,#0xc]
000a4c  f0200080          BIC      r0,r0,#0x80
000a50  60c8              STR      r0,[r1,#0xc]
;;;1255   
;;;1256   			// FDR value must be reset to default value
;;;1257   			LPC_UART4->FDR = 0x10;
000a52  2010              MOVS     r0,#0x10
000a54  6288              STR      r0,[r1,#0x28]
;;;1258   
;;;1259   			LPC_UART4->ACR = UART_ACR_START | tmp;
000a56  f0460001          ORR      r0,r6,#1
000a5a  6208              STR      r0,[r1,#0x20]
000a5c  e01e              B        |L1.2716|
                  |L1.2654|
;;;1260   		}
;;;1261   		else
;;;1262   		{
;;;1263   			LPC_UART4->ACR = 0;
000a5e  2000              MOVS     r0,#0
000a60  4982              LDR      r1,|L1.3180|
000a62  6208              STR      r0,[r1,#0x20]
000a64  e01a              B        |L1.2716|
                  |L1.2662|
;;;1264   		}
;;;1265   	}
;;;1266   	else
;;;1267   	{
;;;1268    		LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000a66  4638              MOV      r0,r7
000a68  f7fffffe          BL       uart_get_pointer
000a6c  4604              MOV      r4,r0
;;;1269   		if (NewState == ENABLE)
000a6e  2d01              CMP      r5,#1
000a70  d111              BNE      |L1.2710|
;;;1270   		{
;;;1271   			// Clear DLL and DLM value
;;;1272   			UARTx->LCR |= UART_LCR_DLAB_EN;
000a72  7b20              LDRB     r0,[r4,#0xc]
000a74  f0400080          ORR      r0,r0,#0x80
000a78  7320              STRB     r0,[r4,#0xc]
;;;1273   
;;;1274   			UARTx->DLL = 0;
000a7a  2000              MOVS     r0,#0
000a7c  7020              STRB     r0,[r4,#0]
;;;1275   
;;;1276   			UARTx->DLM = 0;
000a7e  7120              STRB     r0,[r4,#4]
;;;1277   
;;;1278   			UARTx->LCR &= ~UART_LCR_DLAB_EN;
000a80  7b20              LDRB     r0,[r4,#0xc]
000a82  f0200080          BIC      r0,r0,#0x80
000a86  7320              STRB     r0,[r4,#0xc]
;;;1279   
;;;1280   			// FDR value must be reset to default value
;;;1281   			UARTx->FDR = 0x10;
000a88  2010              MOVS     r0,#0x10
000a8a  f8840028          STRB     r0,[r4,#0x28]
;;;1282   
;;;1283   			UARTx->ACR = UART_ACR_START | tmp;
000a8e  f0460001          ORR      r0,r6,#1
000a92  6220              STR      r0,[r4,#0x20]
000a94  e001              B        |L1.2714|
                  |L1.2710|
;;;1284   		}
;;;1285   		else
;;;1286   		{
;;;1287   			UARTx->ACR = 0;
000a96  2000              MOVS     r0,#0
000a98  6220              STR      r0,[r4,#0x20]
                  |L1.2714|
;;;1288   		}
;;;1289   	}
000a9a  bf00              NOP      
                  |L1.2716|
;;;1290   }
000a9c  e8bd81f0          POP      {r4-r8,pc}
;;;1291   
                          ENDP

                  UART_ABClearIntPending PROC
;;;1304    **********************************************************************/
;;;1305   void UART_ABClearIntPending(UART_ID_Type UartID, UART_ABEO_Type ABIntType)
000aa0  b570              PUSH     {r4-r6,lr}
;;;1306   {
000aa2  4605              MOV      r5,r0
000aa4  460c              MOV      r4,r1
;;;1307   	if (UartID == UART_1)
000aa6  2d01              CMP      r5,#1
000aa8  d105              BNE      |L1.2742|
;;;1308   	{
;;;1309   		LPC_UART1->ACR |= ABIntType;
000aaa  486d              LDR      r0,|L1.3168|
000aac  6a00              LDR      r0,[r0,#0x20]
000aae  4320              ORRS     r0,r0,r4
000ab0  496b              LDR      r1,|L1.3168|
000ab2  6208              STR      r0,[r1,#0x20]
000ab4  e00f              B        |L1.2774|
                  |L1.2742|
;;;1310   	}
;;;1311   	else if (UartID == UART_4)
000ab6  2d04              CMP      r5,#4
000ab8  d105              BNE      |L1.2758|
;;;1312   	{
;;;1313   		LPC_UART4->ACR |= ABIntType;
000aba  486c              LDR      r0,|L1.3180|
000abc  6a00              LDR      r0,[r0,#0x20]
000abe  4320              ORRS     r0,r0,r4
000ac0  496a              LDR      r1,|L1.3180|
000ac2  6208              STR      r0,[r1,#0x20]
000ac4  e007              B        |L1.2774|
                  |L1.2758|
;;;1314   	}
;;;1315   	else
;;;1316   	{	
;;;1317   		LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000ac6  4628              MOV      r0,r5
000ac8  f7fffffe          BL       uart_get_pointer
000acc  4606              MOV      r6,r0
;;;1318   		UARTx->ACR |= ABIntType;
000ace  6a30              LDR      r0,[r6,#0x20]
000ad0  4320              ORRS     r0,r0,r4
000ad2  6230              STR      r0,[r6,#0x20]
;;;1319   	}
000ad4  bf00              NOP      
                  |L1.2774|
;;;1320   }
000ad6  bd70              POP      {r4-r6,pc}
;;;1321   
                          ENDP

                  UART_IrDAInvtInputCmd PROC
;;;1380    **********************************************************************/
;;;1381   void UART_IrDAInvtInputCmd(UART_ID_Type UartID, FunctionalState NewState)
000ad8  2804              CMP      r0,#4
;;;1382   {
;;;1383   	if (UartID != UART_4)
000ada  d000              BEQ      |L1.2782|
                  |L1.2780|
;;;1384   		return;
;;;1385   	
;;;1386    	if (NewState == ENABLE)
;;;1387   	{
;;;1388   		LPC_UART4->ICR |= UART_ICR_IRDAINV;
;;;1389   	}
;;;1390   	else if (NewState == DISABLE)
;;;1391   	{
;;;1392   		LPC_UART4->ICR &= (~UART_ICR_IRDAINV) & UART_ICR_BITMASK;
;;;1393   	}
;;;1394   	
;;;1395   }
000adc  4770              BX       lr
                  |L1.2782|
000ade  2901              CMP      r1,#1                 ;1386
000ae0  d106              BNE      |L1.2800|
000ae2  4a62              LDR      r2,|L1.3180|
000ae4  6a52              LDR      r2,[r2,#0x24]         ;1388
000ae6  f0420202          ORR      r2,r2,#2              ;1388
000aea  4b60              LDR      r3,|L1.3180|
000aec  625a              STR      r2,[r3,#0x24]         ;1388
000aee  e006              B        |L1.2814|
                  |L1.2800|
000af0  b929              CBNZ     r1,|L1.2814|
000af2  4a5e              LDR      r2,|L1.3180|
000af4  6a52              LDR      r2,[r2,#0x24]         ;1392
000af6  f002023d          AND      r2,r2,#0x3d           ;1392
000afa  4b5c              LDR      r3,|L1.3180|
000afc  625a              STR      r2,[r3,#0x24]         ;1392
                  |L1.2814|
000afe  bf00              NOP      
000b00  e7ec              B        |L1.2780|
;;;1396   
                          ENDP

                  UART_IrDACmd PROC
;;;1405    **********************************************************************/
;;;1406   void UART_IrDACmd(UART_ID_Type UartID, FunctionalState NewState)
000b02  2804              CMP      r0,#4
;;;1407   {
;;;1408   	if (UartID != UART_4)
000b04  d000              BEQ      |L1.2824|
                  |L1.2822|
;;;1409   		return;
;;;1410   	
;;;1411   	if (NewState == ENABLE)
;;;1412   	{
;;;1413   		LPC_UART4->ICR |= UART_ICR_IRDAEN;
;;;1414   	}
;;;1415   	else
;;;1416   	{
;;;1417   		LPC_UART4->ICR &= (~UART_ICR_IRDAEN) & UART_ICR_BITMASK;
;;;1418   	}
;;;1419   }
000b06  4770              BX       lr
                  |L1.2824|
000b08  2901              CMP      r1,#1                 ;1411
000b0a  d106              BNE      |L1.2842|
000b0c  4a57              LDR      r2,|L1.3180|
000b0e  6a52              LDR      r2,[r2,#0x24]         ;1413
000b10  f0420201          ORR      r2,r2,#1              ;1413
000b14  4b55              LDR      r3,|L1.3180|
000b16  625a              STR      r2,[r3,#0x24]         ;1413
000b18  e005              B        |L1.2854|
                  |L1.2842|
000b1a  4a54              LDR      r2,|L1.3180|
000b1c  6a52              LDR      r2,[r2,#0x24]         ;1417
000b1e  f002023e          AND      r2,r2,#0x3e           ;1417
000b22  4b52              LDR      r3,|L1.3180|
000b24  625a              STR      r2,[r3,#0x24]         ;1417
                  |L1.2854|
000b26  bf00              NOP      
000b28  e7ed              B        |L1.2822|
;;;1420   
                          ENDP

                  UART_IrDAPulseDivConfig PROC
;;;1437    **********************************************************************/
;;;1438   void UART_IrDAPulseDivConfig(UART_ID_Type UartID, UART_IrDA_PULSE_Type PulseDiv)
000b2a  b530              PUSH     {r4,r5,lr}
;;;1439   {
;;;1440   	uint32_t tmp, tmp1;
;;;1441   
;;;1442   	if (UartID != UART_4)
000b2c  2804              CMP      r0,#4
000b2e  d000              BEQ      |L1.2866|
                  |L1.2864|
;;;1443   		return;
;;;1444   
;;;1445   	tmp1 = UART_ICR_PULSEDIV(PulseDiv);
;;;1446   
;;;1447   	tmp = LPC_UART4->ICR & (~ UART_ICR_PULSEDIV(7));
;;;1448   
;;;1449   	tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
;;;1450   
;;;1451   	LPC_UART4->ICR = tmp & UART_ICR_BITMASK;
;;;1452   }
000b30  bd30              POP      {r4,r5,pc}
                  |L1.2866|
000b32  074c              LSLS     r4,r1,#29             ;1445
000b34  0ea3              LSRS     r3,r4,#26             ;1445
000b36  4c4d              LDR      r4,|L1.3180|
000b38  6a64              LDR      r4,[r4,#0x24]         ;1447
000b3a  f0240238          BIC      r2,r4,#0x38           ;1447
000b3e  f0430404          ORR      r4,r3,#4              ;1449
000b42  4322              ORRS     r2,r2,r4              ;1449
000b44  f002043f          AND      r4,r2,#0x3f           ;1451
000b48  4d48              LDR      r5,|L1.3180|
000b4a  626c              STR      r4,[r5,#0x24]         ;1451
000b4c  bf00              NOP      
000b4e  e7ef              B        |L1.2864|
;;;1453   
                          ENDP

                  UART_FullModemForcePinState PROC
;;;1466    **********************************************************************/
;;;1467   void UART_FullModemForcePinState(UART_ID_Type UartID,
000b50  b530              PUSH     {r4,r5,lr}
;;;1468   													UART_MODEM_PIN_Type Pin,
;;;1469   													UART1_SignalState NewState)
;;;1470   {
;;;1471   	uint8_t tmp = 0;
000b52  2300              MOVS     r3,#0
;;;1472       if (UartID != UART_1)
000b54  2801              CMP      r0,#1
000b56  d000              BEQ      |L1.2906|
                  |L1.2904|
;;;1473   		return;
;;;1474   	switch (Pin)
;;;1475   	{
;;;1476   		case UART1_MODEM_PIN_DTR:
;;;1477   			tmp = UART1_MCR_DTR_CTRL;
;;;1478   			break;
;;;1479   
;;;1480   		case UART1_MODEM_PIN_RTS:
;;;1481   			tmp = UART1_MCR_RTS_CTRL;
;;;1482   			break;
;;;1483   
;;;1484   		default:
;;;1485   			break;
;;;1486   	}
;;;1487   
;;;1488   	if (NewState == ACTIVE)
;;;1489   	{
;;;1490   		LPC_UART1->MCR |= tmp;
;;;1491   	}
;;;1492   	else
;;;1493   	{
;;;1494   		LPC_UART1->MCR &= (~tmp) & UART1_MCR_BITMASK;
;;;1495   	}
;;;1496   }
000b58  bd30              POP      {r4,r5,pc}
                  |L1.2906|
000b5a  b111              CBZ      r1,|L1.2914|
000b5c  2901              CMP      r1,#1                 ;1474
000b5e  d104              BNE      |L1.2922|
000b60  e001              B        |L1.2918|
                  |L1.2914|
000b62  2301              MOVS     r3,#1                 ;1477
000b64  e002              B        |L1.2924|
                  |L1.2918|
000b66  2302              MOVS     r3,#2                 ;1481
000b68  e000              B        |L1.2924|
                  |L1.2922|
000b6a  bf00              NOP                            ;1485
                  |L1.2924|
000b6c  bf00              NOP                            ;1478
000b6e  2a01              CMP      r2,#1                 ;1488
000b70  d105              BNE      |L1.2942|
000b72  4c3b              LDR      r4,|L1.3168|
000b74  7c24              LDRB     r4,[r4,#0x10]         ;1490
000b76  431c              ORRS     r4,r4,r3              ;1490
000b78  4d39              LDR      r5,|L1.3168|
000b7a  742c              STRB     r4,[r5,#0x10]         ;1490
000b7c  e006              B        |L1.2956|
                  |L1.2942|
000b7e  4c38              LDR      r4,|L1.3168|
000b80  7c24              LDRB     r4,[r4,#0x10]         ;1494
000b82  25f3              MOVS     r5,#0xf3              ;1494
000b84  439d              BICS     r5,r5,r3              ;1494
000b86  402c              ANDS     r4,r4,r5              ;1494
000b88  4d35              LDR      r5,|L1.3168|
000b8a  742c              STRB     r4,[r5,#0x10]         ;1494
                  |L1.2956|
000b8c  bf00              NOP      
000b8e  e7e3              B        |L1.2904|
;;;1497   
                          ENDP

                  UART_FullModemConfigMode PROC
;;;1510    **********************************************************************/
;;;1511   void UART_FullModemConfigMode(UART_ID_Type UartID, UART_MODEM_MODE_Type Mode,
000b90  b530              PUSH     {r4,r5,lr}
;;;1512   											FunctionalState NewState)
;;;1513   {
000b92  4603              MOV      r3,r0
;;;1514   	uint8_t tmp;
;;;1515   
;;;1516   	if(UartID != UART_1)
000b94  2b01              CMP      r3,#1
000b96  d000              BEQ      |L1.2970|
                  |L1.2968|
;;;1517   		return;
;;;1518   	
;;;1519   	switch(Mode)
;;;1520   	{
;;;1521   		case UART1_MODEM_MODE_LOOPBACK:
;;;1522   			tmp = UART1_MCR_LOOPB_EN;
;;;1523   			break;
;;;1524   
;;;1525   		case UART1_MODEM_MODE_AUTO_RTS:
;;;1526   			tmp = UART1_MCR_AUTO_RTS_EN;
;;;1527   			break;
;;;1528   
;;;1529   		case UART1_MODEM_MODE_AUTO_CTS:
;;;1530   			tmp = UART1_MCR_AUTO_CTS_EN;
;;;1531   			break;
;;;1532   
;;;1533   		default:
;;;1534   			break;
;;;1535   	}
;;;1536   
;;;1537   	if (NewState == ENABLE)
;;;1538   	{
;;;1539   		LPC_UART1->MCR |= tmp;
;;;1540   	}
;;;1541   	else
;;;1542   	{
;;;1543   		LPC_UART1->MCR &= (~tmp) & UART1_MCR_BITMASK;
;;;1544   	}
;;;1545   }
000b98  bd30              POP      {r4,r5,pc}
                  |L1.2970|
000b9a  b121              CBZ      r1,|L1.2982|
000b9c  2901              CMP      r1,#1                 ;1519
000b9e  d004              BEQ      |L1.2986|
000ba0  2902              CMP      r1,#2                 ;1519
000ba2  d106              BNE      |L1.2994|
000ba4  e003              B        |L1.2990|
                  |L1.2982|
000ba6  2010              MOVS     r0,#0x10              ;1522
000ba8  e004              B        |L1.2996|
                  |L1.2986|
000baa  2040              MOVS     r0,#0x40              ;1526
000bac  e002              B        |L1.2996|
                  |L1.2990|
000bae  2080              MOVS     r0,#0x80              ;1530
000bb0  e000              B        |L1.2996|
                  |L1.2994|
000bb2  bf00              NOP                            ;1534
                  |L1.2996|
000bb4  bf00              NOP                            ;1523
000bb6  2a01              CMP      r2,#1                 ;1537
000bb8  d105              BNE      |L1.3014|
000bba  4c29              LDR      r4,|L1.3168|
000bbc  7c24              LDRB     r4,[r4,#0x10]         ;1539
000bbe  4304              ORRS     r4,r4,r0              ;1539
000bc0  4d27              LDR      r5,|L1.3168|
000bc2  742c              STRB     r4,[r5,#0x10]         ;1539
000bc4  e006              B        |L1.3028|
                  |L1.3014|
000bc6  4c26              LDR      r4,|L1.3168|
000bc8  7c24              LDRB     r4,[r4,#0x10]         ;1543
000bca  25f3              MOVS     r5,#0xf3              ;1543
000bcc  4385              BICS     r5,r5,r0              ;1543
000bce  402c              ANDS     r4,r4,r5              ;1543
000bd0  4d23              LDR      r5,|L1.3168|
000bd2  742c              STRB     r4,[r5,#0x10]         ;1543
                  |L1.3028|
000bd4  bf00              NOP      
000bd6  e7df              B        |L1.2968|
;;;1546   
                          ENDP

                  UART_FullModemGetStatus PROC
;;;1559    **********************************************************************/
;;;1560   uint8_t UART_FullModemGetStatus(UART_ID_Type UartID)
000bd8  4601              MOV      r1,r0
;;;1561   {
;;;1562   	if(UartID != UART_1)
000bda  2901              CMP      r1,#1
000bdc  d001              BEQ      |L1.3042|
;;;1563   		return  0;
000bde  2000              MOVS     r0,#0
                  |L1.3040|
;;;1564   	
;;;1565   	return ((LPC_UART1->MSR) & UART1_MSR_BITMASK);
;;;1566   }
000be0  4770              BX       lr
                  |L1.3042|
000be2  481f              LDR      r0,|L1.3168|
000be4  7e00              LDRB     r0,[r0,#0x18]         ;1565
000be6  e7fb              B        |L1.3040|
;;;1567   
                          ENDP

                  UART_RS485Config PROC
;;;1578    **********************************************************************/
;;;1579   void UART_RS485Config(UART_ID_Type UartID, UART1_RS485_CTRLCFG_Type *RS485ConfigStruct)
000be8  e92d5ff0          PUSH     {r4-r12,lr}
;;;1580   {
000bec  4683              MOV      r11,r0
000bee  460c              MOV      r4,r1
;;;1581   	uint32_t tmp;
;;;1582   	__IO uint32_t *RS485DLY, *ADRMATCH, *RS485CTRL, *LCR;
;;;1583   
;;;1584   	tmp = 0;
000bf0  2500              MOVS     r5,#0
;;;1585   	if (UartID == UART_1)
000bf2  f1bb0f01          CMP      r11,#1
000bf6  d108              BNE      |L1.3082|
;;;1586   	{
;;;1587   		RS485DLY = (__IO uint32_t *)&LPC_UART1->RS485DLY;
000bf8  4f19              LDR      r7,|L1.3168|
000bfa  3754              ADDS     r7,r7,#0x54
;;;1588   		ADRMATCH = (__IO uint32_t *)&LPC_UART1->ADRMATCH;
000bfc  f1a70904          SUB      r9,r7,#4
;;;1589   		LCR = (__IO uint32_t *)&LPC_UART1->LCR;
000c00  4e17              LDR      r6,|L1.3168|
000c02  360c              ADDS     r6,r6,#0xc
;;;1590           RS485CTRL =  (__IO uint32_t *)&LPC_UART1->RS485CTRL;
000c04  f1a90a04          SUB      r10,r9,#4
000c08  e018              B        |L1.3132|
                  |L1.3082|
;;;1591   	}
;;;1592   	else if (UartID == UART_4)
000c0a  f1bb0f04          CMP      r11,#4
000c0e  d108              BNE      |L1.3106|
;;;1593   	{
;;;1594   		RS485DLY = (__IO uint32_t *)&LPC_UART4->RS485DLY;
000c10  4f16              LDR      r7,|L1.3180|
000c12  3754              ADDS     r7,r7,#0x54
;;;1595   		ADRMATCH = (__IO uint32_t *)&LPC_UART4->ADRMATCH;
000c14  f1a70904          SUB      r9,r7,#4
;;;1596   		LCR = (__IO uint32_t *)&LPC_UART4->LCR;
000c18  4e14              LDR      r6,|L1.3180|
000c1a  360c              ADDS     r6,r6,#0xc
;;;1597           RS485CTRL =  (__IO uint32_t *)&LPC_UART4->RS485CTRL;
000c1c  f1a90a04          SUB      r10,r9,#4
000c20  e00c              B        |L1.3132|
                  |L1.3106|
;;;1598   	}
;;;1599   	else
;;;1600   	{
;;;1601   		LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000c22  4658              MOV      r0,r11
000c24  f7fffffe          BL       uart_get_pointer
000c28  4680              MOV      r8,r0
;;;1602   		RS485DLY = (__IO uint32_t *)&UARTx->RS485DLY;
000c2a  f1080754          ADD      r7,r8,#0x54
;;;1603   		ADRMATCH = (__IO uint32_t *)&UARTx->ADRMATCH;
000c2e  f1080950          ADD      r9,r8,#0x50
;;;1604   		LCR = (__IO uint32_t *)&UARTx->LCR;
000c32  f108060c          ADD      r6,r8,#0xc
;;;1605            RS485CTRL =  (__IO uint32_t *)&UARTx->RS485CTRL;
000c36  f1080a4c          ADD      r10,r8,#0x4c
;;;1606   	}
000c3a  bf00              NOP      
                  |L1.3132|
;;;1607   	// If Auto Direction Control is enabled -  This function is used in Master mode
;;;1608   	if (RS485ConfigStruct->AutoDirCtrl_State == ENABLE)
000c3c  78e0              LDRB     r0,[r4,#3]
000c3e  2801              CMP      r0,#1
000c40  d11b              BNE      |L1.3194|
;;;1609   	{
;;;1610   		tmp |= UART_RS485CTRL_DCTRL_EN;
000c42  f0450510          ORR      r5,r5,#0x10
;;;1611   
;;;1612   		// Set polar
;;;1613   		if (RS485ConfigStruct->DirCtrlPol_Level == SET)
000c46  7960              LDRB     r0,[r4,#5]
000c48  2801              CMP      r0,#1
000c4a  d101              BNE      |L1.3152|
;;;1614   		{
;;;1615   			tmp |= UART_RS485CTRL_OINV_1;
000c4c  f0450520          ORR      r5,r5,#0x20
                  |L1.3152|
;;;1616   		}
;;;1617   
;;;1618   		// Set pin according to. This condition is only with UART1. The others are used
;;;1619   		// OE pin as default for control the direction of RS485 buffer IC
;;;1620   		if ((RS485ConfigStruct->DirCtrlPin == UART_RS485_DIRCTRL_DTR) &&
000c50  7920              LDRB     r0,[r4,#4]
000c52  2801              CMP      r0,#1
000c54  d10f              BNE      |L1.3190|
;;;1621                (UartID == UART_1))
000c56  f1bb0f01          CMP      r11,#1
000c5a  e009              B        |L1.3184|
                  |L1.3164|
                          DCD      0x4000c000
                  |L1.3168|
                          DCD      0x40010000
                  |L1.3172|
                          DCD      0x40098000
                  |L1.3176|
                          DCD      0x4009c000
                  |L1.3180|
                          DCD      0x400a4000
                  |L1.3184|
000c70  d101              BNE      |L1.3190|
;;;1622   		{
;;;1623   			tmp |= UART_RS485CTRL_SEL_DTR;
000c72  f0450508          ORR      r5,r5,#8
                  |L1.3190|
;;;1624   		}
;;;1625   
;;;1626   		// Fill delay time
;;;1627   		*RS485DLY = RS485ConfigStruct->DelayValue & UART_RS485DLY_BITMASK;
000c76  79e0              LDRB     r0,[r4,#7]
000c78  6038              STR      r0,[r7,#0]
                  |L1.3194|
;;;1628   	}
;;;1629        
;;;1630   	// MultiDrop mode is enable
;;;1631   	if (RS485ConfigStruct->NormalMultiDropMode_State == ENABLE)
000c7a  7820              LDRB     r0,[r4,#0]
000c7c  2801              CMP      r0,#1
000c7e  d101              BNE      |L1.3204|
;;;1632   	{
;;;1633   		tmp |= UART_RS485CTRL_NMM_EN;
000c80  f0450501          ORR      r5,r5,#1
                  |L1.3204|
;;;1634   	}
;;;1635   
;;;1636   	// Auto Address Detect function
;;;1637   	if (RS485ConfigStruct->AutoAddrDetect_State == ENABLE)
000c84  78a0              LDRB     r0,[r4,#2]
000c86  2801              CMP      r0,#1
000c88  d104              BNE      |L1.3220|
;;;1638   	{
;;;1639   		tmp |= UART_RS485CTRL_AADEN;
000c8a  f0450504          ORR      r5,r5,#4
;;;1640   
;;;1641   		// Fill Match Address
;;;1642   		*ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART_RS485ADRMATCH_BITMASK;
000c8e  79a0              LDRB     r0,[r4,#6]
000c90  f8c90000          STR      r0,[r9,#0]
                  |L1.3220|
;;;1643   	}
;;;1644   
;;;1645   	// Receiver is disable
;;;1646   	if (RS485ConfigStruct->Rx_State == DISABLE)
000c94  7860              LDRB     r0,[r4,#1]
000c96  b908              CBNZ     r0,|L1.3228|
;;;1647   	{
;;;1648   		tmp |= UART_RS485CTRL_RX_DIS;
000c98  f0450502          ORR      r5,r5,#2
                  |L1.3228|
;;;1649   	}
;;;1650        
;;;1651   	// write back to RS485 control register
;;;1652   	*RS485CTRL = tmp & UART_RS485CTRL_BITMASK;
000c9c  f005003f          AND      r0,r5,#0x3f
000ca0  f8ca0000          STR      r0,[r10,#0]
;;;1653   
;;;1654   	// Enable Parity function and leave parity in stick '0' parity as default
;;;1655   	*LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
000ca4  6830              LDR      r0,[r6,#0]
000ca6  f0400038          ORR      r0,r0,#0x38
000caa  6030              STR      r0,[r6,#0]
;;;1656   }
000cac  e8bd9ff0          POP      {r4-r12,pc}
;;;1657   
                          ENDP

                  UART_RS485ReceiverCmd PROC
;;;1665    **********************************************************************/
;;;1666   void UART_RS485ReceiverCmd(UART_ID_Type UartID, FunctionalState NewState)
000cb0  e92d41f0          PUSH     {r4-r8,lr}
;;;1667   {
000cb4  4605              MOV      r5,r0
000cb6  460e              MOV      r6,r1
;;;1668   	__IO uint32_t *RS485CTRL;
;;;1669   	if (UartID == UART_1)
000cb8  2d01              CMP      r5,#1
000cba  d101              BNE      |L1.3264|
;;;1670   	{
;;;1671   		RS485CTRL = (__IO uint32_t *)&LPC_UART1->RS485DLY;
000cbc  4c39              LDR      r4,|L1.3492|
000cbe  e00a              B        |L1.3286|
                  |L1.3264|
;;;1672   	}
;;;1673   	else if (UartID == UART_4)
000cc0  2d04              CMP      r5,#4
000cc2  d101              BNE      |L1.3272|
;;;1674   	{
;;;1675   		RS485CTRL = (__IO uint32_t *)&LPC_UART4->RS485DLY;
000cc4  4c38              LDR      r4,|L1.3496|
000cc6  e006              B        |L1.3286|
                  |L1.3272|
;;;1676   	}
;;;1677   	else
;;;1678   	{
;;;1679   		LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000cc8  4628              MOV      r0,r5
000cca  f7fffffe          BL       uart_get_pointer
000cce  4607              MOV      r7,r0
;;;1680   		RS485CTRL = (__IO uint32_t *)&UARTx->RS485DLY;
000cd0  f1070454          ADD      r4,r7,#0x54
;;;1681   	}
000cd4  bf00              NOP      
                  |L1.3286|
;;;1682   	if (NewState == ENABLE)
000cd6  2e01              CMP      r6,#1
000cd8  d104              BNE      |L1.3300|
;;;1683   	{
;;;1684   		*RS485CTRL &= ~UART_RS485CTRL_RX_DIS;
000cda  6820              LDR      r0,[r4,#0]
000cdc  f0200002          BIC      r0,r0,#2
000ce0  6020              STR      r0,[r4,#0]
000ce2  e003              B        |L1.3308|
                  |L1.3300|
;;;1685   	}
;;;1686   	else
;;;1687   	{
;;;1688   		*RS485CTRL |= UART_RS485CTRL_RX_DIS;
000ce4  6820              LDR      r0,[r4,#0]
000ce6  f0400002          ORR      r0,r0,#2
000cea  6020              STR      r0,[r4,#0]
                  |L1.3308|
;;;1689   	}
;;;1690   }
000cec  e8bd81f0          POP      {r4-r8,pc}
;;;1691   
                          ENDP

                  UART_RS485Send PROC
;;;1699    **********************************************************************/
;;;1700   uint32_t UART_RS485Send(UART_ID_Type UartID, uint8_t *pDatFrm,
000cf0  e92d4fff          PUSH     {r0-r11,lr}
;;;1701   											uint32_t size, uint8_t ParityStick)
;;;1702   {
000cf4  b081              SUB      sp,sp,#4
000cf6  4606              MOV      r6,r0
000cf8  468b              MOV      r11,r1
000cfa  4699              MOV      r9,r3
;;;1703   	uint8_t tmp, save;
;;;1704   	uint32_t cnt;
;;;1705   	__IO uint32_t *LCR, *LSR;
;;;1706   	if (UartID == UART_1)
000cfc  2e01              CMP      r6,#1
000cfe  d104              BNE      |L1.3338|
;;;1707   	{
;;;1708   		LCR = (__IO uint32_t *)&LPC_UART1->LCR;
000d00  4c28              LDR      r4,|L1.3492|
000d02  3c48              SUBS     r4,r4,#0x48
;;;1709   		LSR = (__IO uint32_t *)&LPC_UART1->LSR;
000d04  4d27              LDR      r5,|L1.3492|
000d06  3d40              SUBS     r5,r5,#0x40
000d08  e00f              B        |L1.3370|
                  |L1.3338|
;;;1710   	}
;;;1711   	else if (UartID == UART_4)
000d0a  2e04              CMP      r6,#4
000d0c  d104              BNE      |L1.3352|
;;;1712   	{
;;;1713   		LCR = (__IO uint32_t *)&LPC_UART4->LCR;
000d0e  4c26              LDR      r4,|L1.3496|
000d10  3c48              SUBS     r4,r4,#0x48
;;;1714   		LSR = (__IO uint32_t *)&LPC_UART4->LSR;
000d12  4d25              LDR      r5,|L1.3496|
000d14  3d40              SUBS     r5,r5,#0x40
000d16  e008              B        |L1.3370|
                  |L1.3352|
;;;1715   	}
;;;1716   	else
;;;1717   	{
;;;1718   		LPC_UART_TypeDef *UARTx = uart_get_pointer(UartID);
000d18  4630              MOV      r0,r6
000d1a  f7fffffe          BL       uart_get_pointer
000d1e  4682              MOV      r10,r0
;;;1719   		LCR = (__IO uint32_t *)&UARTx->LCR;
000d20  f10a040c          ADD      r4,r10,#0xc
;;;1720   		LSR = (__IO uint32_t *)&UARTx->LSR;
000d24  f10a0514          ADD      r5,r10,#0x14
;;;1721   	}
000d28  bf00              NOP      
                  |L1.3370|
;;;1722   
;;;1723   	if (ParityStick)
000d2a  f1b90f00          CMP      r9,#0
000d2e  d014              BEQ      |L1.3418|
;;;1724   	{
;;;1725   		save = tmp = *LCR & UART_LCR_BITMASK;
000d30  6820              LDR      r0,[r4,#0]
000d32  b2c7              UXTB     r7,r0
000d34  46b8              MOV      r8,r7
;;;1726   
;;;1727   		tmp &= ~(UART_LCR_PARITY_EVEN);
000d36  f0280810          BIC      r8,r8,#0x10
;;;1728   
;;;1729   		*LCR = tmp;
000d3a  f8c48000          STR      r8,[r4,#0]
;;;1730   
;;;1731   		cnt = UART_Send(UartID, pDatFrm, size, BLOCKING);
000d3e  2301              MOVS     r3,#1
000d40  4659              MOV      r1,r11
000d42  4630              MOV      r0,r6
000d44  9a03              LDR      r2,[sp,#0xc]
000d46  f7fffffe          BL       UART_Send
000d4a  9000              STR      r0,[sp,#0]
;;;1732   
;;;1733   		while (!(*LSR & UART_LSR_TEMT));
000d4c  bf00              NOP      
                  |L1.3406|
000d4e  6828              LDR      r0,[r5,#0]
000d50  f0100f40          TST      r0,#0x40
000d54  d0fb              BEQ      |L1.3406|
;;;1734   
;;;1735   		*LCR = save;
000d56  6027              STR      r7,[r4,#0]
000d58  e00b              B        |L1.3442|
                  |L1.3418|
;;;1736   	}
;;;1737   	else
;;;1738   	{
;;;1739   		cnt = UART_Send(UartID, pDatFrm, size, BLOCKING);
000d5a  2301              MOVS     r3,#1
000d5c  4659              MOV      r1,r11
000d5e  4630              MOV      r0,r6
000d60  9a03              LDR      r2,[sp,#0xc]
000d62  f7fffffe          BL       UART_Send
000d66  9000              STR      r0,[sp,#0]
;;;1740   
;;;1741   		while (!(*LSR & UART_LSR_TEMT));
000d68  bf00              NOP      
                  |L1.3434|
000d6a  6828              LDR      r0,[r5,#0]
000d6c  f0100f40          TST      r0,#0x40
000d70  d0fb              BEQ      |L1.3434|
                  |L1.3442|
;;;1742   	}
;;;1743   
;;;1744   	return cnt;
000d72  9800              LDR      r0,[sp,#0]
;;;1745   }
000d74  b005              ADD      sp,sp,#0x14
000d76  e8bd8ff0          POP      {r4-r11,pc}
;;;1746   
                          ENDP

                  UART_RS485SendSlvAddr PROC
;;;1752    **********************************************************************/
;;;1753   void UART_RS485SendSlvAddr(UART_ID_Type UartID, uint8_t SlvAddr)
000d7a  b513              PUSH     {r0,r1,r4,lr}
;;;1754   {
000d7c  4604              MOV      r4,r0
;;;1755   	UART_RS485Send(UartID, &SlvAddr, 1, 1);
000d7e  2301              MOVS     r3,#1
000d80  461a              MOV      r2,r3
000d82  a901              ADD      r1,sp,#4
000d84  4620              MOV      r0,r4
000d86  f7fffffe          BL       UART_RS485Send
;;;1756   }
000d8a  bd1c              POP      {r2-r4,pc}
;;;1757   
                          ENDP

                  UART_RS485SendData PROC
;;;1764    **********************************************************************/
;;;1765   uint32_t UART_RS485SendData(UART_ID_Type UartID, uint8_t *pData, uint32_t size)
000d8c  b570              PUSH     {r4-r6,lr}
;;;1766   {
000d8e  4604              MOV      r4,r0
000d90  460d              MOV      r5,r1
000d92  4616              MOV      r6,r2
;;;1767   	return (UART_RS485Send(UartID, pData, size, 0));
000d94  2300              MOVS     r3,#0
000d96  4632              MOV      r2,r6
000d98  4629              MOV      r1,r5
000d9a  4620              MOV      r0,r4
000d9c  f7fffffe          BL       UART_RS485Send
;;;1768   }
000da0  bd70              POP      {r4-r6,pc}
;;;1769   
                          ENDP

000da2  0000              DCW      0x0000
                  |L1.3492|
                          DCD      0x40010054
                  |L1.3496|
                          DCD      0x400a4054

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\source\\lpc_uart.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_lpc_uart_c_e5efacd7____REV16|
#line 115 "..\\..\\..\\..\\Core\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_lpc_uart_c_e5efacd7____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_lpc_uart_c_e5efacd7____REVSH|
#line 129
|__asm___10_lpc_uart_c_e5efacd7____REVSH| PROC
#line 130

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
