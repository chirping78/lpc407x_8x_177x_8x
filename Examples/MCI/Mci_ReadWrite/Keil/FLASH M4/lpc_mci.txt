; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o".\FLASH M4\lpc_mci.o" --asm_dir=".\FLASH M4\\" --list_dir=".\FLASH M4\\" --depend=".\FLASH M4\lpc_mci.d" --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\Core\CM3\DeviceSupport\NXP\LPC17xx -I..\..\..\..\Drivers\include -I..\..\..\..\BoardSupport -I..\..\..\..\Core\CMSIS\Include -I..\..\..\..\Core\Device\NXP\LPC407x_8x_177x_8x\Include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\NXP\LPC407x_8x_177x_8x -D__MICROLIB -DCORE_M4 --omf_browse=".\FLASH M4\lpc_mci.crf" ..\..\..\..\Drivers\source\lpc_mci.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  MCI_SettingDma PROC
;;;180     **********************************************************************/
;;;181    uint32_t MCI_SettingDma(uint8_t* memBuf, uint32_t ChannelNum, uint32_t DMAMode )
000000  b570              PUSH     {r4-r6,lr}
;;;182    {
000002  b08a              SUB      sp,sp,#0x28
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;183    	GPDMA_Channel_CFG_Type GPDMACfg;
;;;184    
;;;185    	// Transfer size
;;;186    	GPDMACfg.TransferSize = DMA_MCI_SIZE;
00000a  f44f7000          MOV      r0,#0x200
00000e  9002              STR      r0,[sp,#8]
;;;187    	// Transfer width
;;;188    	GPDMACfg.TransferWidth = GPDMA_WIDTH_WORD;
000010  2002              MOVS     r0,#2
000012  9003              STR      r0,[sp,#0xc]
;;;189    	// Transfer type
;;;190    	GPDMACfg.TransferType = DMAMode;
000014  9406              STR      r4,[sp,#0x18]
;;;191    	// Linker List Item - unused
;;;192    	GPDMACfg.DMALLI = 0;
000016  2000              MOVS     r0,#0
000018  9009              STR      r0,[sp,#0x24]
;;;193    	
;;;194    	/* USB RAM is used for test.
;;;195    	Please note, Ethernet has its own SRAM, but GPDMA can't access
;;;196    	that. GPDMA can access USB SRAM and IRAM. Ethernet DMA controller can 
;;;197    	access both IRAM and Ethernet SRAM. */
;;;198    	GPDMACfg.ChannelNum = ChannelNum;
00001a  9601              STR      r6,[sp,#4]
;;;199    	
;;;200    	if ( DMAMode == GPDMA_TRANSFERTYPE_M2P_DEST_CTRL )
00001c  2c05              CMP      r4,#5
00001e  d107              BNE      |L1.48|
;;;201    	{
;;;202    		/* Ch0 set for M2P transfer from mempry to MCI FIFO. */
;;;203    		// Source memory
;;;204    		GPDMACfg.SrcMemAddr = (uint32_t)memBuf;
000020  9504              STR      r5,[sp,#0x10]
;;;205    		// Destination memory
;;;206    		GPDMACfg.DstMemAddr = (uint32_t)LPC_MCI->FIFO;
000022  48f7              LDR      r0,|L1.1024|
000024  9005              STR      r0,[sp,#0x14]
;;;207    
;;;208    		// Source connection 
;;;209    		GPDMACfg.SrcConn = 0;
000026  2000              MOVS     r0,#0
000028  9007              STR      r0,[sp,#0x1c]
;;;210    		// Destination connection 
;;;211    		GPDMACfg.DstConn = GPDMA_CONN_MCI;
00002a  2001              MOVS     r0,#1
00002c  9008              STR      r0,[sp,#0x20]
00002e  e00c              B        |L1.74|
                  |L1.48|
;;;212    			
;;;213    	}
;;;214    	else if ( DMAMode == GPDMA_TRANSFERTYPE_P2M_SRC_CTRL )
000030  2c06              CMP      r4,#6
000032  d107              BNE      |L1.68|
;;;215    	{
;;;216    		/* Ch0 set for P2M transfer from MCI FIFO to memory. */
;;;217    		// Source memory
;;;218    		GPDMACfg.SrcMemAddr = (uint32_t)LPC_MCI->FIFO;
000034  48f2              LDR      r0,|L1.1024|
000036  9004              STR      r0,[sp,#0x10]
;;;219    		// Destination memory
;;;220    		GPDMACfg.DstMemAddr = (uint32_t)memBuf;
000038  9505              STR      r5,[sp,#0x14]
;;;221    
;;;222    		// Source connection 
;;;223    		GPDMACfg.SrcConn = GPDMA_CONN_MCI;
00003a  2001              MOVS     r0,#1
00003c  9007              STR      r0,[sp,#0x1c]
;;;224    		// Destination connection
;;;225    		GPDMACfg.DstConn = 0;
00003e  2000              MOVS     r0,#0
000040  9008              STR      r0,[sp,#0x20]
000042  e002              B        |L1.74|
                  |L1.68|
;;;226    	}
;;;227    	else
;;;228    	{
;;;229    		return ( FALSE );
000044  2000              MOVS     r0,#0
                  |L1.70|
;;;230    	}
;;;231    
;;;232    	// Setup channel with given parameter
;;;233    	GPDMA_Setup(&GPDMACfg);
;;;234    
;;;235    	// Enable GPDMA channel 
;;;236    	GPDMA_ChannelCmd(ChannelNum, ENABLE);
;;;237    
;;;238    	/* Enable GPDMA interrupt */
;;;239    	NVIC_EnableIRQ(DMA_IRQn);
;;;240    	
;;;241    	return (TRUE);
;;;242    }
000046  b00a              ADD      sp,sp,#0x28
000048  bd70              POP      {r4-r6,pc}
                  |L1.74|
00004a  a801              ADD      r0,sp,#4              ;233
00004c  f7fffffe          BL       GPDMA_Setup
000050  2101              MOVS     r1,#1                 ;236
000052  b2f0              UXTB     r0,r6                 ;236
000054  f7fffffe          BL       GPDMA_ChannelCmd
000058  201a              MOVS     r0,#0x1a              ;239
00005a  f7fffffe          BL       NVIC_EnableIRQ
00005e  2001              MOVS     r0,#1                 ;241
000060  e7f1              B        |L1.70|
;;;243    
                          ENDP

                  MCI_DMA_IRQHandler PROC
;;;253     **********************************************************************/
;;;254    void MCI_DMA_IRQHandler (void)
000062  b510              PUSH     {r4,lr}
;;;255    {
;;;256    	// check GPDMA interrupt on channel 0
;;;257    	if (GPDMA_IntGetStatus(GPDMA_STAT_INT, MCI_DMA_WRITE_CHANNEL))
000064  2100              MOVS     r1,#0
000066  4608              MOV      r0,r1
000068  f7fffffe          BL       GPDMA_IntGetStatus
00006c  b1e0              CBZ      r0,|L1.168|
;;;258    	{
;;;259    		//check interrupt status on channel 0
;;;260    		// Check counter terminal status
;;;261    		if(GPDMA_IntGetStatus(GPDMA_STAT_INTTC, MCI_DMA_WRITE_CHANNEL))
00006e  2100              MOVS     r1,#0
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       GPDMA_IntGetStatus
000076  b140              CBZ      r0,|L1.138|
;;;262    		{
;;;263    			// Clear terminate counter Interrupt pending
;;;264    			GPDMA_ClearIntPending (GPDMA_STATCLR_INTTC, MCI_DMA_WRITE_CHANNEL);
000078  2100              MOVS     r1,#0
00007a  4608              MOV      r0,r1
00007c  f7fffffe          BL       GPDMA_ClearIntPending
;;;265    
;;;266    			dmaWrCh_TermianalCnt++;
000080  48e0              LDR      r0,|L1.1028|
000082  6800              LDR      r0,[r0,#0]  ; dmaWrCh_TermianalCnt
000084  1c40              ADDS     r0,r0,#1
000086  49df              LDR      r1,|L1.1028|
000088  6008              STR      r0,[r1,#0]  ; dmaWrCh_TermianalCnt
                  |L1.138|
;;;267    		}
;;;268    		if (GPDMA_IntGetStatus(GPDMA_STAT_INTERR, MCI_DMA_WRITE_CHANNEL))
00008a  2100              MOVS     r1,#0
00008c  2002              MOVS     r0,#2
00008e  f7fffffe          BL       GPDMA_IntGetStatus
000092  b350              CBZ      r0,|L1.234|
;;;269    		{
;;;270    			// Clear error counter Interrupt pending
;;;271    			GPDMA_ClearIntPending (GPDMA_STATCLR_INTERR, MCI_DMA_WRITE_CHANNEL);
000094  2100              MOVS     r1,#0
000096  2001              MOVS     r0,#1
000098  f7fffffe          BL       GPDMA_ClearIntPending
;;;272    
;;;273    			dmaWrCh_ErrorCnt++;
00009c  48da              LDR      r0,|L1.1032|
00009e  6800              LDR      r0,[r0,#0]  ; dmaWrCh_ErrorCnt
0000a0  1c40              ADDS     r0,r0,#1
0000a2  49d9              LDR      r1,|L1.1032|
0000a4  6008              STR      r0,[r1,#0]  ; dmaWrCh_ErrorCnt
0000a6  e020              B        |L1.234|
                  |L1.168|
;;;274    		}
;;;275    	}
;;;276    	else if (GPDMA_IntGetStatus(GPDMA_STAT_INT, MCI_DMA_READ_CHANNEL))
0000a8  2101              MOVS     r1,#1
0000aa  2000              MOVS     r0,#0
0000ac  f7fffffe          BL       GPDMA_IntGetStatus
0000b0  b1d8              CBZ      r0,|L1.234|
;;;277    	{
;;;278    		//check interrupt status on channel 0
;;;279    		// Check counter terminal status
;;;280    		if(GPDMA_IntGetStatus(GPDMA_STAT_INTTC, MCI_DMA_READ_CHANNEL))
0000b2  2101              MOVS     r1,#1
0000b4  4608              MOV      r0,r1
0000b6  f7fffffe          BL       GPDMA_IntGetStatus
0000ba  b140              CBZ      r0,|L1.206|
;;;281    		{
;;;282    			// Clear terminate counter Interrupt pending
;;;283    			GPDMA_ClearIntPending (GPDMA_STATCLR_INTTC, MCI_DMA_READ_CHANNEL);
0000bc  2101              MOVS     r1,#1
0000be  2000              MOVS     r0,#0
0000c0  f7fffffe          BL       GPDMA_ClearIntPending
;;;284    
;;;285    			dmaRdCh_TermianalCnt++;
0000c4  48d1              LDR      r0,|L1.1036|
0000c6  6800              LDR      r0,[r0,#0]  ; dmaRdCh_TermianalCnt
0000c8  1c40              ADDS     r0,r0,#1
0000ca  49d0              LDR      r1,|L1.1036|
0000cc  6008              STR      r0,[r1,#0]  ; dmaRdCh_TermianalCnt
                  |L1.206|
;;;286    		}
;;;287    		if (GPDMA_IntGetStatus(GPDMA_STAT_INTERR, MCI_DMA_READ_CHANNEL))
0000ce  2101              MOVS     r1,#1
0000d0  2002              MOVS     r0,#2
0000d2  f7fffffe          BL       GPDMA_IntGetStatus
0000d6  b140              CBZ      r0,|L1.234|
;;;288    		{
;;;289    			// Clear error counter Interrupt pending
;;;290    			GPDMA_ClearIntPending (GPDMA_STATCLR_INTERR, MCI_DMA_READ_CHANNEL);
0000d8  2101              MOVS     r1,#1
0000da  4608              MOV      r0,r1
0000dc  f7fffffe          BL       GPDMA_ClearIntPending
;;;291    
;;;292    			dmaRdCh_ErrorCnt++;
0000e0  48cb              LDR      r0,|L1.1040|
0000e2  6800              LDR      r0,[r0,#0]  ; dmaRdCh_ErrorCnt
0000e4  1c40              ADDS     r0,r0,#1
0000e6  49ca              LDR      r1,|L1.1040|
0000e8  6008              STR      r0,[r1,#0]  ; dmaRdCh_ErrorCnt
                  |L1.234|
;;;293    		}
;;;294    	}
;;;295    }
0000ea  bd10              POP      {r4,pc}
;;;296    #endif
                          ENDP

                  MCI_ReadFifo PROC
;;;306     *************************************************************************/
;;;307    int32_t MCI_ReadFifo(uint32_t * dest) 
0000ec  b510              PUSH     {r4,lr}
;;;308    {
0000ee  4684              MOV      r12,r0
;;;309    	uint8_t i;
;;;310        uint8_t start, end;
;;;311    
;;;312        if(fifo_plane == 0)
0000f0  48c8              LDR      r0,|L1.1044|
0000f2  7800              LDRB     r0,[r0,#0]  ; fifo_plane
0000f4  b910              CBNZ     r0,|L1.252|
;;;313        {
;;;314            start = 0;
0000f6  2200              MOVS     r2,#0
;;;315            end = 7;
0000f8  2307              MOVS     r3,#7
0000fa  e001              B        |L1.256|
                  |L1.252|
;;;316        }
;;;317        else
;;;318        {
;;;319            start = 8;
0000fc  2208              MOVS     r2,#8
;;;320            end = 15;
0000fe  230f              MOVS     r3,#0xf
                  |L1.256|
;;;321        }
;;;322        fifo_plane = (fifo_plane) ? 0:1;
000100  48c4              LDR      r0,|L1.1044|
000102  7800              LDRB     r0,[r0,#0]  ; fifo_plane
000104  b908              CBNZ     r0,|L1.266|
000106  2001              MOVS     r0,#1
000108  e000              B        |L1.268|
                  |L1.266|
00010a  2000              MOVS     r0,#0
                  |L1.268|
00010c  4cc1              LDR      r4,|L1.1044|
00010e  7020              STRB     r0,[r4,#0]
;;;323    
;;;324    	for (i = start; i <= end; i++) 
000110  4611              MOV      r1,r2
000112  e008              B        |L1.294|
                  |L1.276|
;;;325    	{
;;;326    		*dest = LPC_MCI->FIFO[i];
000114  48ba              LDR      r0,|L1.1024|
000116  f8500021          LDR      r0,[r0,r1,LSL #2]
00011a  f8cc0000          STR      r0,[r12,#0]
;;;327    		
;;;328    		dest++;
00011e  f10c0c04          ADD      r12,r12,#4
000122  1c48              ADDS     r0,r1,#1              ;324
000124  b2c1              UXTB     r1,r0                 ;324
                  |L1.294|
000126  4299              CMP      r1,r3                 ;324
000128  ddf4              BLE      |L1.276|
;;;329    	}
;;;330    	
;;;331    	return MCI_FUNC_OK;
00012a  2000              MOVS     r0,#0
;;;332    }
00012c  bd10              POP      {r4,pc}
;;;333    
                          ENDP

                  MCI_WriteFifo PROC
;;;341     *************************************************************************/
;;;342    int32_t MCI_WriteFifo(uint32_t * src)
00012e  b510              PUSH     {r4,lr}
;;;343    {
000130  4684              MOV      r12,r0
;;;344    	uint8_t i;
;;;345        uint8_t start, end;
;;;346    
;;;347        if(fifo_plane == 0)
000132  48b8              LDR      r0,|L1.1044|
000134  7800              LDRB     r0,[r0,#0]  ; fifo_plane
000136  b910              CBNZ     r0,|L1.318|
;;;348        {
;;;349            start = 0;
000138  2200              MOVS     r2,#0
;;;350            end = 7;
00013a  2307              MOVS     r3,#7
00013c  e001              B        |L1.322|
                  |L1.318|
;;;351        }
;;;352        else
;;;353        {
;;;354            start = 8;
00013e  2208              MOVS     r2,#8
;;;355            end = 15;
000140  230f              MOVS     r3,#0xf
                  |L1.322|
;;;356        }
;;;357        fifo_plane = (fifo_plane) ? 0:1;
000142  48b4              LDR      r0,|L1.1044|
000144  7800              LDRB     r0,[r0,#0]  ; fifo_plane
000146  b908              CBNZ     r0,|L1.332|
000148  2001              MOVS     r0,#1
00014a  e000              B        |L1.334|
                  |L1.332|
00014c  2000              MOVS     r0,#0
                  |L1.334|
00014e  4cb1              LDR      r4,|L1.1044|
000150  7020              STRB     r0,[r4,#0]
;;;358    
;;;359    	for (i = start; i <= end; i++) 
000152  4611              MOV      r1,r2
000154  e008              B        |L1.360|
                  |L1.342|
;;;360    	{
;;;361    		LPC_MCI->FIFO[i] = *src;
000156  48aa              LDR      r0,|L1.1024|
000158  f8dc4000          LDR      r4,[r12,#0]
00015c  f8404021          STR      r4,[r0,r1,LSL #2]
;;;362    		
;;;363    		src++;
000160  f10c0c04          ADD      r12,r12,#4
000164  1c48              ADDS     r0,r1,#1              ;359
000166  b2c1              UXTB     r1,r0                 ;359
                  |L1.360|
000168  4299              CMP      r1,r3                 ;359
00016a  ddf4              BLE      |L1.342|
;;;364    	}
;;;365    	
;;;366    	return MCI_FUNC_OK;
00016c  2000              MOVS     r0,#0
;;;367    }
00016e  bd10              POP      {r4,pc}
;;;368    
                          ENDP

                  MCI_TXEnable PROC
;;;376     *************************************************************************/
;;;377    void MCI_TXEnable( void )
000170  48a3              LDR      r0,|L1.1024|
;;;378    {
;;;379    #if MCI_DMA_ENABLED
;;;380    	LPC_MCI->MASK0 |= ((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));	/* Enable TX interrupts only */
000172  3880              SUBS     r0,r0,#0x80
000174  6bc0              LDR      r0,[r0,#0x3c]
000176  f240711a          MOV      r1,#0x71a
00017a  4308              ORRS     r0,r0,r1
00017c  49a0              LDR      r1,|L1.1024|
00017e  3980              SUBS     r1,r1,#0x80
000180  63c8              STR      r0,[r1,#0x3c]
;;;381    #else
;;;382    	LPC_MCI->MASK0 |= ((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK));	/* FIFO TX interrupts only */
;;;383    #endif
;;;384    
;;;385    	return;
;;;386    }
000182  4770              BX       lr
;;;387    
                          ENDP

                  MCI_TXDisable PROC
;;;395     *************************************************************************/
;;;396    void MCI_TXDisable( void )
000184  489e              LDR      r0,|L1.1024|
;;;397    {
;;;398    #if MCI_DMA_ENABLED
;;;399    	LPC_MCI->MASK0 &= ~((DATA_END_INT_MASK)|(ERR_TX_INT_MASK));	/* Enable TX interrupts only */
000186  3880              SUBS     r0,r0,#0x80
000188  6bc0              LDR      r0,[r0,#0x3c]
00018a  f240711a          MOV      r1,#0x71a
00018e  4388              BICS     r0,r0,r1
000190  499b              LDR      r1,|L1.1024|
000192  3980              SUBS     r1,r1,#0x80
000194  63c8              STR      r0,[r1,#0x3c]
;;;400    #else
;;;401    	LPC_MCI->MASK0 &= ~((FIFO_TX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_TX_INT_MASK));	/* FIFO TX interrupts only */
;;;402    #endif
;;;403    
;;;404    	return;
;;;405    }
000196  4770              BX       lr
;;;406    
                          ENDP

                  MCI_RXEnable PROC
;;;414     *************************************************************************/
;;;415    void MCI_RXEnable( void )
000198  4899              LDR      r0,|L1.1024|
;;;416    {
;;;417    #if MCI_DMA_ENABLED
;;;418    	LPC_MCI->MASK0 |= ((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));	/* Enable RX interrupts only */
00019a  3880              SUBS     r0,r0,#0x80
00019c  6bc0              LDR      r0,[r0,#0x3c]
00019e  f240712a          MOV      r1,#0x72a
0001a2  4308              ORRS     r0,r0,r1
0001a4  4996              LDR      r1,|L1.1024|
0001a6  3980              SUBS     r1,r1,#0x80
0001a8  63c8              STR      r0,[r1,#0x3c]
;;;419    #else
;;;420    	LPC_MCI->MASK0 |= ((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK));	/* FIFO RX interrupts only */
;;;421    #endif
;;;422    
;;;423    	return;
;;;424    }
0001aa  4770              BX       lr
;;;425    
                          ENDP

                  MCI_RXDisable PROC
;;;433     *************************************************************************/
;;;434    void MCI_RXDisable( void )
0001ac  4894              LDR      r0,|L1.1024|
;;;435    {
;;;436    #if MCI_DMA_ENABLED
;;;437    	LPC_MCI->MASK0 &= ~((DATA_END_INT_MASK)|(ERR_RX_INT_MASK));	/* Enable TX interrupts only */
0001ae  3880              SUBS     r0,r0,#0x80
0001b0  6bc0              LDR      r0,[r0,#0x3c]
0001b2  f240712a          MOV      r1,#0x72a
0001b6  4388              BICS     r0,r0,r1
0001b8  4991              LDR      r1,|L1.1024|
0001ba  3980              SUBS     r1,r1,#0x80
0001bc  63c8              STR      r0,[r1,#0x3c]
;;;438    #else
;;;439    	LPC_MCI->MASK0 &= ~((FIFO_RX_INT_MASK)|(DATA_END_INT_MASK)|(ERR_RX_INT_MASK));	/* FIFO TX interrupts only */
;;;440    #endif
;;;441    
;;;442    	return;
;;;443    }
0001be  4770              BX       lr
;;;444    
                          ENDP

                  MCI_GetCmdResp PROC
;;;1072    ***************************************************************************/
;;;1073   int32_t MCI_GetCmdResp(uint32_t ExpectCmdData, uint32_t ExpectResp, uint32_t *CmdResp)
0001c0  b530              PUSH     {r4,r5,lr}
;;;1074   {
0001c2  4603              MOV      r3,r0
0001c4  460c              MOV      r4,r1
;;;1075   	uint32_t CmdRespStatus = 0;
0001c6  2100              MOVS     r1,#0
;;;1076   	uint32_t LastCmdIndex;
;;;1077   
;;;1078   	if ( ExpectResp == EXPECT_NO_RESP )
0001c8  b90c              CBNZ     r4,|L1.462|
;;;1079   	{
;;;1080   		return MCI_FUNC_OK;
0001ca  2000              MOVS     r0,#0
                  |L1.460|
;;;1081   	}
;;;1082   
;;;1083   	while (1)
;;;1084   	{
;;;1085   		// Get the status of the component
;;;1086   		CmdRespStatus = LPC_MCI->STATUS;
;;;1087   
;;;1088   		if ( CmdRespStatus & (MCI_CMD_TIMEOUT) )
;;;1089   		{
;;;1090   			LPC_MCI->CLEAR = CmdRespStatus | MCI_CMD_TIMEOUT;
;;;1091   
;;;1092   			LPC_MCI->COMMAND = 0;
;;;1093   			LPC_MCI->ARGUMENT = 0xFFFFFFFF;
;;;1094   
;;;1095   			return (CmdRespStatus);
;;;1096   		}
;;;1097   
;;;1098   		if (  CmdRespStatus & MCI_CMD_CRC_FAIL )
;;;1099   		{
;;;1100   			LPC_MCI->CLEAR = CmdRespStatus | MCI_CMD_CRC_FAIL;
;;;1101   			LastCmdIndex = LPC_MCI->COMMAND & 0x003F;
;;;1102   
;;;1103   			if ( (LastCmdIndex == CMD1_SEND_OP_COND) || (LastCmdIndex == ACMD41_SEND_APP_OP_COND)
;;;1104   													|| (LastCmdIndex == CMD12_STOP_TRANSMISSION) )
;;;1105   			{
;;;1106   				LPC_MCI->COMMAND = 0;
;;;1107   				LPC_MCI->ARGUMENT = 0xFFFFFFFF;
;;;1108   				break;			/* ignore CRC error if it's a resp for SEND_OP_COND
;;;1109   								or STOP_TRANSMISSION. */
;;;1110   			}
;;;1111   			else
;;;1112   			{
;;;1113   				return (CmdRespStatus);
;;;1114   			}
;;;1115   		}
;;;1116   		else if (CmdRespStatus & MCI_CMD_RESP_END)
;;;1117   		{
;;;1118   			LPC_MCI->CLEAR = CmdRespStatus | MCI_CMD_RESP_END;
;;;1119   			break;	/* cmd response is received, expecting response */
;;;1120   		}
;;;1121           
;;;1122   	}
;;;1123   
;;;1124   	if ((LPC_MCI->RESP_CMD & 0x3F) != ExpectCmdData)
;;;1125   	{
;;;1126   		/* If the response is not R1, in the response field, the Expected Cmd data
;;;1127   		won't be the same as the CMD data in SendCmd(). Below four cmds have
;;;1128   		R2 or R3 response. We don't need to check if MCI_RESP_CMD is the same
;;;1129   		as the Expected or not. */
;;;1130   		if ((ExpectCmdData != CMD1_SEND_OP_COND) && (ExpectCmdData != ACMD41_SEND_APP_OP_COND)
;;;1131   					&& (ExpectCmdData != CMD2_ALL_SEND_CID) && (ExpectCmdData != CMD9_SEND_CSD))
;;;1132   		{
;;;1133   			CmdRespStatus = INVALID_RESPONSE;	/* Reuse error status */
;;;1134   			return (INVALID_RESPONSE);
;;;1135   		}
;;;1136   	}
;;;1137   
;;;1138   	/* Read MCI_RESP0 register assuming it's not long response. */
;;;1139   	if (CmdResp != NULL)
;;;1140   	{
;;;1141   		if (ExpectResp == EXPECT_SHORT_RESP)
;;;1142   		{
;;;1143   			*(CmdResp + 0) = LPC_MCI->RESP0;
;;;1144   			*(CmdResp + 1) = 0;
;;;1145   			*(CmdResp + 2) = 0;
;;;1146   			*(CmdResp + 3) = 0;
;;;1147   		}
;;;1148   		else if (ExpectResp == EXPECT_LONG_RESP)
;;;1149   		{
;;;1150   			*(CmdResp + 0) = LPC_MCI->RESP0;
;;;1151   			*(CmdResp + 1) = LPC_MCI->RESP1;
;;;1152   			*(CmdResp + 2) = LPC_MCI->RESP2;
;;;1153   			*(CmdResp + 3) = LPC_MCI->RESP3;
;;;1154   		}
;;;1155   		}
;;;1156   
;;;1157   	return MCI_FUNC_OK;
;;;1158   }
0001cc  bd30              POP      {r4,r5,pc}
                  |L1.462|
0001ce  e037              B        |L1.576|
                  |L1.464|
0001d0  488b              LDR      r0,|L1.1024|
0001d2  3880              SUBS     r0,r0,#0x80           ;1086
0001d4  6b41              LDR      r1,[r0,#0x34]         ;1086
0001d6  f0110f04          TST      r1,#4                 ;1088
0001da  d00a              BEQ      |L1.498|
0001dc  f0410004          ORR      r0,r1,#4              ;1090
0001e0  4d87              LDR      r5,|L1.1024|
0001e2  3d80              SUBS     r5,r5,#0x80           ;1090
0001e4  63a8              STR      r0,[r5,#0x38]         ;1090
0001e6  2000              MOVS     r0,#0                 ;1092
0001e8  60e8              STR      r0,[r5,#0xc]          ;1092
0001ea  1e40              SUBS     r0,r0,#1              ;1093
0001ec  60a8              STR      r0,[r5,#8]            ;1093
0001ee  4608              MOV      r0,r1                 ;1095
0001f0  e7ec              B        |L1.460|
                  |L1.498|
0001f2  f0110f01          TST      r1,#1                 ;1098
0001f6  d01a              BEQ      |L1.558|
0001f8  f0410001          ORR      r0,r1,#1              ;1100
0001fc  4d80              LDR      r5,|L1.1024|
0001fe  3d80              SUBS     r5,r5,#0x80           ;1100
000200  63a8              STR      r0,[r5,#0x38]         ;1100
000202  4628              MOV      r0,r5                 ;1101
000204  68c0              LDR      r0,[r0,#0xc]          ;1101
000206  f0000c3f          AND      r12,r0,#0x3f          ;1101
00020a  f1bc0f01          CMP      r12,#1                ;1103
00020e  d005              BEQ      |L1.540|
000210  f1bc0f29          CMP      r12,#0x29             ;1103
000214  d002              BEQ      |L1.540|
000216  f1bc0f0c          CMP      r12,#0xc              ;1104
00021a  d106              BNE      |L1.554|
                  |L1.540|
00021c  2000              MOVS     r0,#0                 ;1106
00021e  4d78              LDR      r5,|L1.1024|
000220  3d80              SUBS     r5,r5,#0x80           ;1106
000222  60e8              STR      r0,[r5,#0xc]          ;1106
000224  1e40              SUBS     r0,r0,#1              ;1107
000226  60a8              STR      r0,[r5,#8]            ;1107
000228  e00b              B        |L1.578|
                  |L1.554|
00022a  4608              MOV      r0,r1                 ;1113
00022c  e7ce              B        |L1.460|
                  |L1.558|
00022e  f0110f40          TST      r1,#0x40              ;1116
000232  d005              BEQ      |L1.576|
000234  f0410040          ORR      r0,r1,#0x40           ;1118
000238  4d71              LDR      r5,|L1.1024|
00023a  3d80              SUBS     r5,r5,#0x80           ;1118
00023c  63a8              STR      r0,[r5,#0x38]         ;1118
00023e  e000              B        |L1.578|
                  |L1.576|
000240  e7c6              B        |L1.464|
                  |L1.578|
000242  bf00              NOP                            ;1108
000244  486e              LDR      r0,|L1.1024|
000246  3880              SUBS     r0,r0,#0x80           ;1124
000248  6900              LDR      r0,[r0,#0x10]         ;1124
00024a  f000003f          AND      r0,r0,#0x3f           ;1124
00024e  4298              CMP      r0,r3                 ;1124
000250  d00b              BEQ      |L1.618|
000252  2b01              CMP      r3,#1                 ;1130
000254  d009              BEQ      |L1.618|
000256  2b29              CMP      r3,#0x29              ;1130
000258  d007              BEQ      |L1.618|
00025a  2b02              CMP      r3,#2                 ;1131
00025c  d005              BEQ      |L1.618|
00025e  2b09              CMP      r3,#9                 ;1131
000260  d003              BEQ      |L1.618|
000262  f04f31ff          MOV      r1,#0xffffffff        ;1133
000266  4608              MOV      r0,r1                 ;1134
000268  e7b0              B        |L1.460|
                  |L1.618|
00026a  b1e2              CBZ      r2,|L1.678|
00026c  2c01              CMP      r4,#1                 ;1141
00026e  d108              BNE      |L1.642|
000270  4863              LDR      r0,|L1.1024|
000272  3880              SUBS     r0,r0,#0x80           ;1143
000274  6940              LDR      r0,[r0,#0x14]         ;1143
000276  6010              STR      r0,[r2,#0]            ;1143
000278  2000              MOVS     r0,#0                 ;1144
00027a  6050              STR      r0,[r2,#4]            ;1144
00027c  6090              STR      r0,[r2,#8]            ;1145
00027e  60d0              STR      r0,[r2,#0xc]          ;1146
000280  e011              B        |L1.678|
                  |L1.642|
000282  2c02              CMP      r4,#2                 ;1148
000284  d10f              BNE      |L1.678|
000286  485e              LDR      r0,|L1.1024|
000288  3880              SUBS     r0,r0,#0x80           ;1150
00028a  6940              LDR      r0,[r0,#0x14]         ;1150
00028c  6010              STR      r0,[r2,#0]            ;1150
00028e  485c              LDR      r0,|L1.1024|
000290  3880              SUBS     r0,r0,#0x80           ;1151
000292  6980              LDR      r0,[r0,#0x18]         ;1151
000294  6050              STR      r0,[r2,#4]            ;1151
000296  485a              LDR      r0,|L1.1024|
000298  3880              SUBS     r0,r0,#0x80           ;1152
00029a  69c0              LDR      r0,[r0,#0x1c]         ;1152
00029c  6090              STR      r0,[r2,#8]            ;1152
00029e  4858              LDR      r0,|L1.1024|
0002a0  3880              SUBS     r0,r0,#0x80           ;1153
0002a2  6a00              LDR      r0,[r0,#0x20]         ;1153
0002a4  60d0              STR      r0,[r2,#0xc]          ;1153
                  |L1.678|
0002a6  2000              MOVS     r0,#0                 ;1157
0002a8  e790              B        |L1.460|
;;;1159   
                          ENDP

                  MCI_SendCmd PROC
;;;1004    ***************************************************************************/
;;;1005   void MCI_SendCmd(uint32_t CmdIndex, uint32_t Argument, uint32_t ExpectResp, uint32_t AllowTimeout)
0002aa  b5f0              PUSH     {r4-r7,lr}
;;;1006   {
0002ac  4604              MOV      r4,r0
0002ae  460d              MOV      r5,r1
;;;1007   	uint32_t i, CmdData = 0;
0002b0  2000              MOVS     r0,#0
;;;1008   	uint32_t CmdStatus;
;;;1009   
;;;1010   	/* the command engine must be disabled when we modify the argument
;;;1011   	or the peripheral resends */
;;;1012   	while ( (CmdStatus = LPC_MCI->STATUS) & MCI_CMD_ACTIVE )	/* Command in progress. */
0002b2  e006              B        |L1.706|
                  |L1.692|
;;;1013   	{
;;;1014   		LPC_MCI->COMMAND = 0;
0002b4  2600              MOVS     r6,#0
0002b6  4f52              LDR      r7,|L1.1024|
0002b8  3f80              SUBS     r7,r7,#0x80
0002ba  60fe              STR      r6,[r7,#0xc]
;;;1015   		LPC_MCI->CLEAR = CmdStatus | MCI_CMD_ACTIVE;
0002bc  f44c6600          ORR      r6,r12,#0x800
0002c0  63be              STR      r6,[r7,#0x38]
                  |L1.706|
0002c2  4e4f              LDR      r6,|L1.1024|
0002c4  3e80              SUBS     r6,r6,#0x80           ;1012
0002c6  f8d6c034          LDR      r12,[r6,#0x34]        ;1012
0002ca  f41c6f00          TST      r12,#0x800            ;1012
0002ce  d1f1              BNE      |L1.692|
;;;1016   	}
;;;1017   
;;;1018   	for ( i = 0; i < 0x100; i++ );
0002d0  2100              MOVS     r1,#0
0002d2  e000              B        |L1.726|
                  |L1.724|
0002d4  1c49              ADDS     r1,r1,#1
                  |L1.726|
0002d6  29ff              CMP      r1,#0xff
0002d8  d9fc              BLS      |L1.724|
;;;1019   
;;;1020   	/*set the command details, the CmdIndex should 0 through 0x3F only */
;;;1021   	CmdData |= (CmdIndex & 0x3F);	/* bit 0 through 5 only */
0002da  f004063f          AND      r6,r4,#0x3f
0002de  4330              ORRS     r0,r0,r6
;;;1022   
;;;1023   	if ( ExpectResp == EXPECT_NO_RESP )			/* no response */
0002e0  b912              CBNZ     r2,|L1.744|
;;;1024   	{
;;;1025   		CmdData &= ~((1 << 6) | (1 << 7));		/* Clear long response bit as well */
0002e2  f02000c0          BIC      r0,r0,#0xc0
0002e6  e008              B        |L1.762|
                  |L1.744|
;;;1026   	}
;;;1027   	else if ( ExpectResp == EXPECT_SHORT_RESP )	/* expect short response */
0002e8  2a01              CMP      r2,#1
0002ea  d102              BNE      |L1.754|
;;;1028   	{
;;;1029   		CmdData |= (1 << 6);
0002ec  f0400040          ORR      r0,r0,#0x40
0002f0  e003              B        |L1.762|
                  |L1.754|
;;;1030   	}
;;;1031   	else if ( ExpectResp == EXPECT_LONG_RESP )	/* expect long response */
0002f2  2a02              CMP      r2,#2
0002f4  d101              BNE      |L1.762|
;;;1032   	{
;;;1033   		CmdData |= (1 << 6) | (1 << 7);
0002f6  f04000c0          ORR      r0,r0,#0xc0
                  |L1.762|
;;;1034   	}
;;;1035   
;;;1036   	if ( AllowTimeout == ALLOW_CMD_TIMER )			/* allow timeout or not */
0002fa  2b01              CMP      r3,#1
0002fc  d102              BNE      |L1.772|
;;;1037   	{
;;;1038   		CmdData &= ~ MCI_DISABLE_CMD_TIMER;
0002fe  f4207080          BIC      r0,r0,#0x100
000302  e001              B        |L1.776|
                  |L1.772|
;;;1039   	}
;;;1040   	else
;;;1041   	{
;;;1042   		CmdData |= MCI_DISABLE_CMD_TIMER;
000304  f4407080          ORR      r0,r0,#0x100
                  |L1.776|
;;;1043   	}
;;;1044   
;;;1045   	/*send the command*/
;;;1046   	CmdData |= (1 << 10);		/* This bit needs to be set last. */
000308  f4406080          ORR      r0,r0,#0x400
;;;1047   
;;;1048   	LPC_MCI->ARGUMENT = Argument;	/* Set the argument first, finally command */
00030c  4e3c              LDR      r6,|L1.1024|
00030e  3e80              SUBS     r6,r6,#0x80
000310  60b5              STR      r5,[r6,#8]
;;;1049   
;;;1050   	LPC_MCI->COMMAND = CmdData;
000312  60f0              STR      r0,[r6,#0xc]
;;;1051   
;;;1052   	return;
;;;1053   }
000314  bdf0              POP      {r4-r7,pc}
;;;1054   
                          ENDP

                  MCI_CmdResp PROC
;;;1179    ***************************************************************************/
;;;1180   int32_t MCI_CmdResp(uint32_t CmdIndex, uint32_t Argument,
000316  e92d43f0          PUSH     {r4-r9,lr}
;;;1181   								uint32_t ExpectResp, uint32_t *CmdResp, uint32_t AllowTimeout)
;;;1182   {
00031a  4607              MOV      r7,r0
00031c  4688              MOV      r8,r1
00031e  4614              MOV      r4,r2
000320  461d              MOV      r5,r3
000322  f8dd901c          LDR      r9,[sp,#0x1c]
;;;1183   	int32_t respStatus;
;;;1184   
;;;1185   	MCI_SendCmd(CmdIndex, Argument, ExpectResp, AllowTimeout);
000326  464b              MOV      r3,r9
000328  4622              MOV      r2,r4
00032a  4641              MOV      r1,r8
00032c  4638              MOV      r0,r7
00032e  f7fffffe          BL       MCI_SendCmd
;;;1186   
;;;1187   	if((CmdResp != NULL) || (ExpectResp != EXPECT_NO_RESP))
000332  b905              CBNZ     r5,|L1.822|
000334  b134              CBZ      r4,|L1.836|
                  |L1.822|
;;;1188   	{
;;;1189   		respStatus = MCI_GetCmdResp(CmdIndex, ExpectResp, CmdResp);
000336  462a              MOV      r2,r5
000338  4621              MOV      r1,r4
00033a  4638              MOV      r0,r7
00033c  f7fffffe          BL       MCI_GetCmdResp
000340  4606              MOV      r6,r0
000342  e001              B        |L1.840|
                  |L1.836|
;;;1190   	}
;;;1191   	else
;;;1192   	{
;;;1193   		respStatus = MCI_FUNC_BAD_PARAMETERS;
000344  f06f0601          MVN      r6,#1
                  |L1.840|
;;;1194   	}
;;;1195   
;;;1196   	return respStatus;
000348  4630              MOV      r0,r6
;;;1197   }
00034a  e8bd83f0          POP      {r4-r9,pc}
;;;1198   
                          ENDP

                  MCI_GetCardStatus PROC
;;;1867    ****************************************************************************/
;;;1868   int32_t MCI_GetCardStatus(int32_t* cardStatus)
00034e  e92d43f0          PUSH     {r4-r9,lr}
;;;1869   {
000352  b085              SUB      sp,sp,#0x14
000354  4604              MOV      r4,r0
;;;1870   	uint32_t i;
;;;1871   	uint32_t retryCount;
;;;1872   	uint32_t respStatus;
;;;1873   	uint32_t respValue[4];
;;;1874   	uint32_t CmdArgument;
;;;1875   
;;;1876   	int32_t retval = MCI_FUNC_FAILED;
000356  f04f39ff          MOV      r9,#0xffffffff
;;;1877   
;;;1878   	if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
00035a  482f              LDR      r0,|L1.1048|
00035c  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
00035e  b138              CBZ      r0,|L1.880|
;;;1879   		(MCI_CardType == MCI_SDSC_V2_CARD) ||
000360  482d              LDR      r0,|L1.1048|
000362  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000364  2802              CMP      r0,#2
000366  d003              BEQ      |L1.880|
;;;1880   		(MCI_CardType == MCI_SDHC_SDXC_CARD)) 
000368  482b              LDR      r0,|L1.1048|
00036a  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
00036c  2803              CMP      r0,#3
00036e  d102              BNE      |L1.886|
                  |L1.880|
;;;1881   	{
;;;1882   		CmdArgument = CardRCA;
000370  482a              LDR      r0,|L1.1052|
000372  6806              LDR      r6,[r0,#0]  ; CardRCA
000374  e001              B        |L1.890|
                  |L1.886|
;;;1883   	}
;;;1884   	else			/* if MMC or unknown card type, use default RCA addr. */
;;;1885   	{
;;;1886   		CmdArgument = 0x00010000;
000376  f44f3680          MOV      r6,#0x10000
                  |L1.890|
;;;1887   	}
;;;1888   
;;;1889   	/* Note that, since it's called after the block write and read, this timeout
;;;1890   	is important based on the clock you set for the data communication. */
;;;1891   	retryCount = 0x20;
00037a  2520              MOVS     r5,#0x20
;;;1892   
;;;1893   	while ( retryCount > 0 )
00037c  e02b              B        |L1.982|
                  |L1.894|
;;;1894   	{
;;;1895   		/* Send SELECT_CARD command before read and write */
;;;1896   		LPC_MCI->CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
00037e  4820              LDR      r0,|L1.1024|
000380  3880              SUBS     r0,r0,#0x80
000382  6b80              LDR      r0,[r0,#0x38]
000384  f0400045          ORR      r0,r0,#0x45
000388  491d              LDR      r1,|L1.1024|
00038a  3980              SUBS     r1,r1,#0x80
00038c  6388              STR      r0,[r1,#0x38]
;;;1897   
;;;1898   		respStatus = MCI_CmdResp(CMD13_SEND_STATUS, CmdArgument, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
00038e  2001              MOVS     r0,#1
000390  ab01              ADD      r3,sp,#4
000392  4602              MOV      r2,r0
000394  4631              MOV      r1,r6
000396  9000              STR      r0,[sp,#0]
000398  200d              MOVS     r0,#0xd
00039a  f7fffffe          BL       MCI_CmdResp
00039e  4607              MOV      r7,r0
;;;1899   
;;;1900   		if(respStatus)
0003a0  b117              CBZ      r7,|L1.936|
;;;1901   		{
;;;1902   			retval = MCI_FUNC_FAILED;
0003a2  f04f39ff          MOV      r9,#0xffffffff
0003a6  e00d              B        |L1.964|
                  |L1.936|
;;;1903   		}
;;;1904   		else if(!(respValue[0] & _SHIFT(MCI_CARDSTATUS_READYFORDATA_P0S)))
0003a8  9801              LDR      r0,[sp,#4]
0003aa  f4107f80          TST      r0,#0x100
0003ae  d102              BNE      |L1.950|
;;;1905   		{
;;;1906   			retval = MCI_FUNC_NOT_READY;
0003b0  f06f0904          MVN      r9,#4
0003b4  e006              B        |L1.964|
                  |L1.950|
;;;1907   		}
;;;1908   		else
;;;1909   		{
;;;1910   			/* The ready bit should be set, it should be in either TRAN or RCV state now */
;;;1911   			if(cardStatus != NULL)
0003b6  b10c              CBZ      r4,|L1.956|
;;;1912   			{
;;;1913   				*cardStatus = respValue[0];
0003b8  9801              LDR      r0,[sp,#4]
0003ba  6020              STR      r0,[r4,#0]
                  |L1.956|
;;;1914   			}
;;;1915   
;;;1916   			return MCI_FUNC_OK;
0003bc  2000              MOVS     r0,#0
                  |L1.958|
;;;1917   		}
;;;1918   
;;;1919   		retryCount--;
;;;1920   		for ( i = 0; i < 0x10; i++ );
;;;1921   	}
;;;1922   
;;;1923   	return retval;
;;;1924   }
0003be  b005              ADD      sp,sp,#0x14
0003c0  e8bd83f0          POP      {r4-r9,pc}
                  |L1.964|
0003c4  1e6d              SUBS     r5,r5,#1              ;1919
0003c6  f04f0800          MOV      r8,#0                 ;1920
0003ca  e001              B        |L1.976|
                  |L1.972|
0003cc  f1080801          ADD      r8,r8,#1              ;1920
                  |L1.976|
0003d0  f1b80f10          CMP      r8,#0x10              ;1920
0003d4  d3fa              BCC      |L1.972|
                  |L1.982|
0003d6  2d00              CMP      r5,#0                 ;1893
0003d8  d1d1              BNE      |L1.894|
0003da  4648              MOV      r0,r9                 ;1923
0003dc  e7ef              B        |L1.958|
;;;1925   
                          ENDP

                  MCI_CheckStatus PROC
;;;458     *************************************************************************/
;;;459    int32_t MCI_CheckStatus(void)
0003de  b518              PUSH     {r3,r4,lr}
;;;460    {
;;;461    	int32_t respValue, retval = MCI_FUNC_FAILED;
0003e0  f04f34ff          MOV      r4,#0xffffffff
;;;462    
;;;463    	while (1)
0003e4  e026              B        |L1.1076|
                  |L1.998|
;;;464    	{
;;;465    		if (MCI_GetCardStatus(&respValue) != MCI_FUNC_OK)
0003e6  4668              MOV      r0,sp
0003e8  f7fffffe          BL       MCI_GetCardStatus
0003ec  b100              CBZ      r0,|L1.1008|
;;;466    		{
;;;467    			break;
0003ee  e022              B        |L1.1078|
                  |L1.1008|
;;;468    		}
;;;469    		else
;;;470    		{
;;;471    			/* The only valid state is TRANS per MMC and SD state diagram.
;;;472    			RCV state may be seen, but, it happens only when TX_ACTIVE or
;;;473    			RX_ACTIVE occurs before the WRITE_BLOCK and READ_BLOCK cmds are
;;;474    			being sent, which is not a valid sequence. */
;;;475    			if(!(respValue & _SHIFT(MCI_CARDSTATUS_READYFORDATA_P0S)))
0003f0  9800              LDR      r0,[sp,#0]
0003f2  f4107f80          TST      r0,#0x100
0003f6  d113              BNE      |L1.1056|
;;;476    			{
;;;477    				retval = MCI_FUNC_NOT_READY;
0003f8  f06f0404          MVN      r4,#4
0003fc  e01a              B        |L1.1076|
0003fe  0000              DCW      0x0000
                  |L1.1024|
                          DCD      0x400c0080
                  |L1.1028|
                          DCD      dmaWrCh_TermianalCnt
                  |L1.1032|
                          DCD      dmaWrCh_ErrorCnt
                  |L1.1036|
                          DCD      dmaRdCh_TermianalCnt
                  |L1.1040|
                          DCD      dmaRdCh_ErrorCnt
                  |L1.1044|
                          DCD      fifo_plane
                  |L1.1048|
                          DCD      MCI_CardType
                  |L1.1052|
                          DCD      CardRCA
                  |L1.1056|
;;;478    			}
;;;479    			else if(CARDSTATEOF(respValue) != MCI_CARDSTATE_TRAN)
000420  9800              LDR      r0,[sp,#0]
000422  f3c02043          UBFX     r0,r0,#9,#4
000426  2804              CMP      r0,#4
000428  d002              BEQ      |L1.1072|
;;;480    			{
;;;481    				/* Should be in STANDBY state now and ready */
;;;482    				retval = MCI_FUNC_ERR_STATE;
00042a  f06f0403          MVN      r4,#3
00042e  e001              B        |L1.1076|
                  |L1.1072|
;;;483    			}
;;;484    			else
;;;485    			{
;;;486    				return MCI_FUNC_OK;
000430  2000              MOVS     r0,#0
                  |L1.1074|
;;;487    			}
;;;488    		}
;;;489    	}
;;;490    
;;;491    	return retval;
;;;492    }
000432  bd18              POP      {r3,r4,pc}
                  |L1.1076|
000434  e7d7              B        |L1.998|
                  |L1.1078|
000436  bf00              NOP                            ;467
000438  4620              MOV      r0,r4                 ;491
00043a  e7fa              B        |L1.1074|
;;;493    
                          ENDP

                  MCI_CmdProcess PROC
;;;504     *************************************************************************/
;;;505    void MCI_CmdProcess( void )
00043c  49f9              LDR      r1,|L1.2084|
;;;506    {
;;;507    	uint32_t MCIStatus;
;;;508    
;;;509    	MCIStatus = LPC_MCI->STATUS;
00043e  6b48              LDR      r0,[r1,#0x34]
;;;510    
;;;511    	if ( MCIStatus &  MCI_CMD_CRC_FAIL )
000440  f0100f01          TST      r0,#1
000444  d002              BEQ      |L1.1100|
;;;512    	{
;;;513    		LPC_MCI->CLEAR =  MCI_CMD_CRC_FAIL;
000446  2101              MOVS     r1,#1
000448  4af6              LDR      r2,|L1.2084|
00044a  6391              STR      r1,[r2,#0x38]
                  |L1.1100|
;;;514    	}
;;;515    
;;;516    	if ( MCIStatus &  MCI_CMD_TIMEOUT )
00044c  f0100f04          TST      r0,#4
000450  d002              BEQ      |L1.1112|
;;;517    	{
;;;518    		LPC_MCI->CLEAR =  MCI_CMD_TIMEOUT;
000452  2104              MOVS     r1,#4
000454  4af3              LDR      r2,|L1.2084|
000456  6391              STR      r1,[r2,#0x38]
                  |L1.1112|
;;;519    	}
;;;520    
;;;521    	/* Cmd Resp End or Cmd Sent */
;;;522    	if ( MCIStatus &  MCI_CMD_RESP_END )
000458  f0100f40          TST      r0,#0x40
00045c  d002              BEQ      |L1.1124|
;;;523    	{
;;;524    		LPC_MCI->CLEAR =  MCI_CMD_RESP_END;
00045e  2140              MOVS     r1,#0x40
000460  4af0              LDR      r2,|L1.2084|
000462  6391              STR      r1,[r2,#0x38]
                  |L1.1124|
;;;525    	}
;;;526    
;;;527    	if ( MCIStatus &  MCI_CMD_SENT )
000464  f0100f80          TST      r0,#0x80
000468  d002              BEQ      |L1.1136|
;;;528    	{
;;;529    		LPC_MCI->CLEAR =  MCI_CMD_SENT;
00046a  2180              MOVS     r1,#0x80
00046c  4aed              LDR      r2,|L1.2084|
00046e  6391              STR      r1,[r2,#0x38]
                  |L1.1136|
;;;530    	}
;;;531    
;;;532    	if ( MCIStatus &  MCI_CMD_ACTIVE )
000470  f4106f00          TST      r0,#0x800
000474  d003              BEQ      |L1.1150|
;;;533    	{
;;;534    		LPC_MCI->CLEAR =  MCI_CMD_ACTIVE;
000476  f44f6100          MOV      r1,#0x800
00047a  4aea              LDR      r2,|L1.2084|
00047c  6391              STR      r1,[r2,#0x38]
                  |L1.1150|
;;;535    	}
;;;536    
;;;537    	return;
;;;538    }
00047e  4770              BX       lr
;;;539    
                          ENDP

                  MCI_DataErrorProcess PROC
;;;547     *************************************************************************/
;;;548    void MCI_DataErrorProcess( void )
000480  49e8              LDR      r1,|L1.2084|
;;;549    {
;;;550    	uint32_t MCIStatus;
;;;551    
;;;552    	MCIStatus = LPC_MCI->STATUS;
000482  6b48              LDR      r0,[r1,#0x34]
;;;553    
;;;554    	if ( MCIStatus &  MCI_DATA_CRC_FAIL )
000484  f0100f02          TST      r0,#2
000488  d002              BEQ      |L1.1168|
;;;555    	{
;;;556    		LPC_MCI->CLEAR = MCI_DATA_CRC_FAIL;
00048a  2102              MOVS     r1,#2
00048c  4ae5              LDR      r2,|L1.2084|
00048e  6391              STR      r1,[r2,#0x38]
                  |L1.1168|
;;;557    	}
;;;558    
;;;559    	if ( MCIStatus &  MCI_DATA_TIMEOUT )
000490  f0100f08          TST      r0,#8
000494  d002              BEQ      |L1.1180|
;;;560    	{
;;;561    		LPC_MCI->CLEAR =  MCI_DATA_TIMEOUT;
000496  2108              MOVS     r1,#8
000498  4ae2              LDR      r2,|L1.2084|
00049a  6391              STR      r1,[r2,#0x38]
                  |L1.1180|
;;;562    	}
;;;563    
;;;564    	/* Underrun or overrun */
;;;565    	if ( MCIStatus &  MCI_TX_UNDERRUN )
00049c  f0100f10          TST      r0,#0x10
0004a0  d002              BEQ      |L1.1192|
;;;566    	{
;;;567    		LPC_MCI->CLEAR = MCI_TX_UNDERRUN;
0004a2  2110              MOVS     r1,#0x10
0004a4  4adf              LDR      r2,|L1.2084|
0004a6  6391              STR      r1,[r2,#0x38]
                  |L1.1192|
;;;568    	}
;;;569    
;;;570    	if ( MCIStatus &  MCI_RX_OVERRUN )
0004a8  f0100f20          TST      r0,#0x20
0004ac  d002              BEQ      |L1.1204|
;;;571    	{
;;;572    		LPC_MCI->CLEAR =  MCI_RX_OVERRUN;
0004ae  2120              MOVS     r1,#0x20
0004b0  4adc              LDR      r2,|L1.2084|
0004b2  6391              STR      r1,[r2,#0x38]
                  |L1.1204|
;;;573    	}
;;;574    
;;;575    	/* Start bit error on data signal */
;;;576    	if ( MCIStatus &  MCI_START_BIT_ERR )
0004b4  f4107f00          TST      r0,#0x200
0004b8  d003              BEQ      |L1.1218|
;;;577    	{
;;;578    		LPC_MCI->CLEAR =  MCI_START_BIT_ERR;
0004ba  f44f7100          MOV      r1,#0x200
0004be  4ad9              LDR      r2,|L1.2084|
0004c0  6391              STR      r1,[r2,#0x38]
                  |L1.1218|
;;;579    	}
;;;580    
;;;581        Mci_Data_Xfer_End = 0;
0004c2  2100              MOVS     r1,#0
0004c4  4ad8              LDR      r2,|L1.2088|
0004c6  6011              STR      r1,[r2,#0]  ; Mci_Data_Xfer_End
;;;582        Mci_Data_Xfer_ERR = MCIStatus;
0004c8  49d8              LDR      r1,|L1.2092|
0004ca  6008              STR      r0,[r1,#0]  ; Mci_Data_Xfer_ERR
;;;583    	return;
;;;584    }
0004cc  4770              BX       lr
;;;585    
                          ENDP

                  MCI_DATA_END_InterruptService PROC
;;;599     *************************************************************************/
;;;600    void MCI_DATA_END_InterruptService( void )
0004ce  b500              PUSH     {lr}
;;;601    {
;;;602    	uint32_t MCIStatus;
;;;603    
;;;604    	MCIStatus = LPC_MCI->STATUS;
0004d0  48d4              LDR      r0,|L1.2084|
0004d2  6b42              LDR      r2,[r0,#0x34]
;;;605    	if ( MCIStatus &  MCI_DATA_END )		/* Data end, and Data block end  */
0004d4  f4127f80          TST      r2,#0x100
0004d8  d00c              BEQ      |L1.1268|
;;;606    	{
;;;607    		LPC_MCI->CLEAR = MCI_DATA_END;
0004da  1580              ASRS     r0,r0,#22
0004dc  49d1              LDR      r1,|L1.2084|
0004de  6388              STR      r0,[r1,#0x38]
;;;608    
;;;609    		Mci_Data_Xfer_End = 0;
0004e0  2000              MOVS     r0,#0
0004e2  49d1              LDR      r1,|L1.2088|
0004e4  6008              STR      r0,[r1,#0]  ; Mci_Data_Xfer_End
;;;610    
;;;611            Mci_Data_Xfer_ERR = 0;
0004e6  49d1              LDR      r1,|L1.2092|
0004e8  6008              STR      r0,[r1,#0]  ; Mci_Data_Xfer_ERR
;;;612    
;;;613    		MCI_TXDisable();
0004ea  f7fffffe          BL       MCI_TXDisable
;;;614    		
;;;615    		MCI_RXDisable();
0004ee  f7fffffe          BL       MCI_RXDisable
                  |L1.1266|
;;;616    
;;;617    		return;
;;;618    	}
;;;619    
;;;620    	if ( MCIStatus &  MCI_DATA_BLK_END )
;;;621    	{
;;;622    		LPC_MCI->CLEAR =  MCI_DATA_BLK_END;
;;;623    
;;;624    		//MCI_TXDisable();
;;;625    
;;;626    		return;
;;;627    	}
;;;628    
;;;629    	/* Tx active  */
;;;630    	if ( MCIStatus & MCI_TX_ACTIVE )
;;;631    	{
;;;632    
;;;633    	}
;;;634    
;;;635    	/* Rx active  */
;;;636    	if ( MCIStatus & MCI_RX_ACTIVE )
;;;637    	{
;;;638    
;;;639    	}
;;;640    
;;;641    	return;
;;;642    }
0004f2  bd00              POP      {pc}
                  |L1.1268|
0004f4  f4126f80          TST      r2,#0x400             ;620
0004f8  d004              BEQ      |L1.1284|
0004fa  f44f6080          MOV      r0,#0x400             ;622
0004fe  49c9              LDR      r1,|L1.2084|
000500  6388              STR      r0,[r1,#0x38]         ;622
000502  e7f6              B        |L1.1266|
                  |L1.1284|
000504  bf00              NOP                            ;641
000506  e7f4              B        |L1.1266|
;;;643    
                          ENDP

                  MCI_FIFOInterruptService PROC
;;;655     **********************************************************************/
;;;656    void MCI_FIFOInterruptService( void )
000508  4770              BX       lr
;;;657    {
;;;658    #if !MCI_DMA_ENABLED
;;;659    	uint32_t MCIStatus;
;;;660    
;;;661    	MCIStatus = LPC_MCI->STATUS;
;;;662    
;;;663    	if ( MCIStatus & (FIFO_TX_INT_MASK ) )
;;;664    	{
;;;665    		/* empty is multiple of 512 block size */
;;;666    		if ( MCIStatus & MCI_TX_HALF_EMPTY )
;;;667    		{
;;;668    			//There's no data, return
;;;669    			if(dataSrcBlock == NULL)
;;;670    				return;
;;;671    
;;;672    			/* write 8 words to fifo */
;;;673    			MCI_WriteFifo((uint32_t *)&dataSrcBlock[txBlockCnt]);
;;;674    
;;;675    			txBlockCnt += 32;
;;;676    		}
;;;677    
;;;678    		if (txBlockCnt == BLOCK_LENGTH)	/* block complete */
;;;679    		{
;;;680    			dataSrcBlock += BLOCK_LENGTH;
;;;681    
;;;682    			txBlockCnt = 0;
;;;683    
;;;684    			/* disable FIFO int until next block write */
;;;685    			//LPC_MCI->MASK0 &= ~(FIFO_TX_INT_MASK);
;;;686    
;;;687    			/* wait for SD card to complete sending data i.e MCI_DATA_BLK_END interrupt */
;;;688    		}
;;;689    	}
;;;690    	else if ( MCIStatus & (FIFO_RX_INT_MASK) )
;;;691    	{
;;;692    		/* if using RX_HALF_FULL remove one ReadFIFO below */
;;;693    		if ( MCIStatus & MCI_RX_HALF_FULL )
;;;694    		{
;;;695    			//There's no store data, return
;;;696    			if(dataDestBlock == NULL)
;;;697    				return;
;;;698    
;;;699    			/* read 8 words from fifo */
;;;700    			MCI_ReadFifo((uint32_t *)&dataDestBlock[rxBlockCnt]);
;;;701    
;;;702    			rxBlockCnt += 32;
;;;703    		}
;;;704    
;;;705    		/* block complete */
;;;706    		if (rxBlockCnt == BLOCK_LENGTH)
;;;707    		{
;;;708    			dataDestBlock += BLOCK_LENGTH;
;;;709    
;;;710    			rxBlockCnt = 0;
;;;711    		}
;;;712    	}
;;;713    #endif
;;;714    
;;;715    	return;
;;;716    }
;;;717    
                          ENDP

                  MCI_IRQHandler PROC
;;;729     **********************************************************************/
;;;730    void MCI_IRQHandler (void)
00050a  b500              PUSH     {lr}
;;;731    {
;;;732    	uint32_t MCI_Status;
;;;733    
;;;734    	MCI_Status = LPC_MCI->STATUS;
00050c  48c5              LDR      r0,|L1.2084|
00050e  6b43              LDR      r3,[r0,#0x34]
;;;735    
;;;736    	/* handle MCI_STATUS interrupt */
;;;737    	if ( MCI_Status & DATA_ERR_INT_MASK )
000510  f240203a          MOV      r0,#0x23a
000514  4203              TST      r3,r0
000516  d002              BEQ      |L1.1310|
;;;738    	{
;;;739    		MCI_DataErrorProcess();
000518  f7fffffe          BL       MCI_DataErrorProcess
                  |L1.1308|
;;;740    
;;;741    		return;
;;;742    	}
;;;743    
;;;744    	if ( MCI_Status & DATA_END_INT_MASK )
;;;745    	{
;;;746    		MCI_DATA_END_InterruptService();
;;;747    
;;;748    		return;
;;;749    	}
;;;750    	else if ( MCI_Status & FIFO_INT_MASK )
;;;751    	{
;;;752    		MCI_FIFOInterruptService();
;;;753    
;;;754    		return;
;;;755    	}
;;;756    	else if ( MCI_Status & CMD_INT_MASK )
;;;757    	{
;;;758    		MCI_CmdProcess();
;;;759    
;;;760    		return;
;;;761    	}
;;;762    }
00051c  bd00              POP      {pc}
                  |L1.1310|
00051e  f4136fa0          TST      r3,#0x500             ;744
000522  d002              BEQ      |L1.1322|
000524  f7fffffe          BL       MCI_DATA_END_InterruptService
000528  e7f8              B        |L1.1308|
                  |L1.1322|
00052a  48c1              LDR      r0,|L1.2096|
00052c  4203              TST      r3,r0                 ;750
00052e  d002              BEQ      |L1.1334|
000530  f7fffffe          BL       MCI_FIFOInterruptService
000534  e7f2              B        |L1.1308|
                  |L1.1334|
000536  f64000c5          MOV      r0,#0x8c5             ;756
00053a  4203              TST      r3,r0                 ;756
00053c  d002              BEQ      |L1.1348|
00053e  f7fffffe          BL       MCI_CmdProcess
000542  e7eb              B        |L1.1308|
                  |L1.1348|
000544  bf00              NOP      
000546  e7e9              B        |L1.1308|
;;;763    
                          ENDP

                  MCI_Set_MCIClock PROC
;;;782     **********************************************************************/
;;;783    void MCI_Set_MCIClock( uint32_t ClockRate )
000548  b510              PUSH     {r4,lr}
;;;784    {
00054a  4601              MOV      r1,r0
;;;785    	uint32_t i, ClkValue = 0;
00054c  2000              MOVS     r0,#0
;;;786    
;;;787    	if ( ClockRate == MCI_SLOW_RATE )
00054e  2901              CMP      r1,#1
000550  d102              BNE      |L1.1368|
;;;788    	{
;;;789    		/* slow clock */
;;;790    		ClkValue |= MCLKDIV_SLOW;
000552  f040003b          ORR      r0,r0,#0x3b
000556  e002              B        |L1.1374|
                  |L1.1368|
;;;791    	}
;;;792    	else if (ClockRate == MCI_NORMAL_RATE)
000558  2902              CMP      r1,#2
00055a  d100              BNE      |L1.1374|
;;;793    	{
;;;794    		/* normal clock */
;;;795    		ClkValue |= MCLKDIV_NORMAL;
00055c  bf00              NOP      
                  |L1.1374|
;;;796    	}
;;;797    
;;;798    	LPC_MCI->CLOCK &= ~(0xFF); /* clear clock divider */
00055e  4bb1              LDR      r3,|L1.2084|
000560  685b              LDR      r3,[r3,#4]
000562  f02303ff          BIC      r3,r3,#0xff
000566  4caf              LDR      r4,|L1.2084|
000568  6063              STR      r3,[r4,#4]
;;;799    
;;;800    	LPC_MCI->CLOCK |= (1 << 8)  | ClkValue;
00056a  4623              MOV      r3,r4
00056c  685b              LDR      r3,[r3,#4]
00056e  f4407480          ORR      r4,r0,#0x100
000572  4323              ORRS     r3,r3,r4
000574  4cab              LDR      r4,|L1.2084|
000576  6063              STR      r3,[r4,#4]
;;;801    
;;;802    	for ( i = 0; i < 0x10; i++ );	/* delay 3MCLK + 2PCLK before next write */
000578  2200              MOVS     r2,#0
00057a  e000              B        |L1.1406|
                  |L1.1404|
00057c  1c52              ADDS     r2,r2,#1
                  |L1.1406|
00057e  2a10              CMP      r2,#0x10
000580  d3fc              BCC      |L1.1404|
;;;803    
;;;804    	return;
;;;805    }
000582  bd10              POP      {r4,pc}
;;;806    
                          ENDP

                  MCI_Cmd_SendACMD PROC
;;;1328    ****************************************************************************/
;;;1329   int32_t MCI_Cmd_SendACMD( void )
000584  e92d41f0          PUSH     {r4-r8,lr}
;;;1330   {
000588  b085              SUB      sp,sp,#0x14
;;;1331   	uint32_t i, retryCount;
;;;1332   	uint32_t CmdArgument;
;;;1333   	uint32_t respStatus;
;;;1334   	uint32_t respValue[4];
;;;1335   
;;;1336   	int32_t retval = MCI_FUNC_FAILED;
00058a  f04f38ff          MOV      r8,#0xffffffff
;;;1337   
;;;1338   	if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
00058e  48a9              LDR      r0,|L1.2100|
000590  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000592  b138              CBZ      r0,|L1.1444|
;;;1339   		(MCI_CardType == MCI_SDSC_V2_CARD) ||
000594  48a7              LDR      r0,|L1.2100|
000596  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000598  2802              CMP      r0,#2
00059a  d003              BEQ      |L1.1444|
;;;1340   		(MCI_CardType == MCI_SDHC_SDXC_CARD)) 
00059c  48a5              LDR      r0,|L1.2100|
00059e  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
0005a0  2803              CMP      r0,#3
0005a2  d102              BNE      |L1.1450|
                  |L1.1444|
;;;1341   	{
;;;1342   		CmdArgument = CardRCA;	/* Use the address from SET_RELATIVE_ADDR cmd */
0005a4  48a4              LDR      r0,|L1.2104|
0005a6  6805              LDR      r5,[r0,#0]  ; CardRCA
0005a8  e000              B        |L1.1452|
                  |L1.1450|
;;;1343   	}
;;;1344   	else			/* if MMC or unknown card type, use 0x0. */
;;;1345   	{
;;;1346   		CmdArgument = 0x00000000;
0005aa  2500              MOVS     r5,#0
                  |L1.1452|
;;;1347   	}
;;;1348   
;;;1349   	retryCount = 20;
0005ac  2414              MOVS     r4,#0x14
;;;1350   
;;;1351   	while ( retryCount > 0 )
0005ae  e01b              B        |L1.1512|
                  |L1.1456|
;;;1352   	{
;;;1353   		respStatus = MCI_CmdResp(CMD55_APP_CMD, CmdArgument, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
0005b0  2001              MOVS     r0,#1
0005b2  ab01              ADD      r3,sp,#4
0005b4  4602              MOV      r2,r0
0005b6  4629              MOV      r1,r5
0005b8  9000              STR      r0,[sp,#0]
0005ba  2037              MOVS     r0,#0x37
0005bc  f7fffffe          BL       MCI_CmdResp
0005c0  4606              MOV      r6,r0
;;;1354   
;;;1355   		if(respStatus != 0)
0005c2  b116              CBZ      r6,|L1.1482|
;;;1356   		{
;;;1357   			retval = MCI_FUNC_FAILED;
0005c4  f04f38ff          MOV      r8,#0xffffffff
0005c8  e008              B        |L1.1500|
                  |L1.1482|
;;;1358   		}
;;;1359   		else if (respValue[0] & CARD_STATUS_ACMD_ENABLE)
0005ca  9801              LDR      r0,[sp,#4]
0005cc  f0100f20          TST      r0,#0x20
0005d0  d002              BEQ      |L1.1496|
;;;1360   		{
;;;1361   			retval = MCI_FUNC_OK;
0005d2  f04f0800          MOV      r8,#0
;;;1362   			break;
0005d6  e009              B        |L1.1516|
                  |L1.1496|
;;;1363   		}
;;;1364   		else
;;;1365   		{
;;;1366   			retval = MCI_FUNC_NOT_READY;
0005d8  f06f0804          MVN      r8,#4
                  |L1.1500|
;;;1367   		}
;;;1368   
;;;1369   		for ( i = 0; i < 0x20; i++ );
0005dc  2700              MOVS     r7,#0
0005de  e000              B        |L1.1506|
                  |L1.1504|
0005e0  1c7f              ADDS     r7,r7,#1
                  |L1.1506|
0005e2  2f20              CMP      r7,#0x20
0005e4  d3fc              BCC      |L1.1504|
;;;1370   
;;;1371   		retryCount--;
0005e6  1e64              SUBS     r4,r4,#1
                  |L1.1512|
0005e8  2c00              CMP      r4,#0                 ;1351
0005ea  d1e1              BNE      |L1.1456|
                  |L1.1516|
0005ec  bf00              NOP                            ;1362
;;;1372   	}
;;;1373   
;;;1374   	return retval;
0005ee  4640              MOV      r0,r8
;;;1375   }
0005f0  b005              ADD      sp,sp,#0x14
0005f2  e8bd81f0          POP      {r4-r8,pc}
;;;1376   
                          ENDP

                  MCI_Acmd_SendBusWidth PROC
;;;1995    ****************************************************************************/
;;;1996   int32_t MCI_Acmd_SendBusWidth( uint32_t buswidth )
0005f6  e92d41f0          PUSH     {r4-r8,lr}
;;;1997   {
0005fa  b085              SUB      sp,sp,#0x14
0005fc  4605              MOV      r5,r0
;;;1998   	uint32_t i, retryCount;
;;;1999   	uint32_t respStatus;
;;;2000   	uint32_t respValue[4];
;;;2001   
;;;2002   	int32_t retval = MCI_FUNC_FAILED;
0005fe  f04f38ff          MOV      r8,#0xffffffff
;;;2003   
;;;2004   	retryCount = 0x20;			/* reset retry counter */
000602  2720              MOVS     r7,#0x20
;;;2005   
;;;2006   	while ( retryCount > 0 )
000604  e028              B        |L1.1624|
                  |L1.1542|
;;;2007   	{
;;;2008   		if (MCI_Cmd_SendACMD() == MCI_FUNC_OK)
000606  f7fffffe          BL       MCI_Cmd_SendACMD
00060a  b9f8              CBNZ     r0,|L1.1612|
;;;2009   		{
;;;2010   			respStatus = MCI_CmdResp(ACMD6_SET_BUS_WIDTH, buswidth, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
00060c  2001              MOVS     r0,#1
00060e  ab01              ADD      r3,sp,#4
000610  4602              MOV      r2,r0
000612  4629              MOV      r1,r5
000614  9000              STR      r0,[sp,#0]
000616  2006              MOVS     r0,#6
000618  f7fffffe          BL       MCI_CmdResp
00061c  4604              MOV      r4,r0
;;;2011   
;;;2012   			if(respStatus)
00061e  b114              CBZ      r4,|L1.1574|
;;;2013   			{
;;;2014   				retval = MCI_FUNC_FAILED;
000620  f04f38ff          MOV      r8,#0xffffffff
000624  e012              B        |L1.1612|
                  |L1.1574|
;;;2015   			}
;;;2016   			else if(!(respValue[0] & _SHIFT(MCI_CARDSTATUS_READYFORDATA_P0S)))
000626  9801              LDR      r0,[sp,#4]
000628  f4107f80          TST      r0,#0x100
00062c  d102              BNE      |L1.1588|
;;;2017   			{
;;;2018   				retval = MCI_FUNC_NOT_READY;
00062e  f06f0804          MVN      r8,#4
000632  e00b              B        |L1.1612|
                  |L1.1588|
;;;2019   			}
;;;2020   			else if((CARDSTATEOF(respValue[0]) != MCI_CARDSTATE_TRAN))
000634  9801              LDR      r0,[sp,#4]
000636  f3c02043          UBFX     r0,r0,#9,#4
00063a  2804              CMP      r0,#4
00063c  d002              BEQ      |L1.1604|
;;;2021   			{
;;;2022   				retval = MCI_FUNC_ERR_STATE;
00063e  f06f0803          MVN      r8,#3
000642  e003              B        |L1.1612|
                  |L1.1604|
;;;2023   			}
;;;2024   			else
;;;2025   			{
;;;2026   				return MCI_FUNC_OK;
000644  2000              MOVS     r0,#0
                  |L1.1606|
;;;2027   			}
;;;2028   		}
;;;2029   
;;;2030   		for ( i = 0; i < 0x20; i++ );
;;;2031   
;;;2032   		retryCount--;
;;;2033   	}
;;;2034   
;;;2035   	return retval;
;;;2036   }
000646  b005              ADD      sp,sp,#0x14
000648  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1612|
00064c  2600              MOVS     r6,#0                 ;2030
00064e  e000              B        |L1.1618|
                  |L1.1616|
000650  1c76              ADDS     r6,r6,#1              ;2030
                  |L1.1618|
000652  2e20              CMP      r6,#0x20              ;2030
000654  d3fc              BCC      |L1.1616|
000656  1e7f              SUBS     r7,r7,#1              ;2032
                  |L1.1624|
000658  2f00              CMP      r7,#0                 ;2006
00065a  d1d4              BNE      |L1.1542|
00065c  4640              MOV      r0,r8                 ;2035
00065e  e7f2              B        |L1.1606|
;;;2037   
                          ENDP

                  MCI_SetBusWidth PROC
;;;814     *************************************************************************/
;;;815    int32_t MCI_SetBusWidth( uint32_t width )
000660  b530              PUSH     {r4,r5,lr}
;;;816    {
000662  4604              MOV      r4,r0
;;;817    	uint32_t i;
;;;818    
;;;819    	for ( i = 0; i < 0x10; i++ );	/* delay 3MCLK + 2PCLK  */
000664  2500              MOVS     r5,#0
000666  e000              B        |L1.1642|
                  |L1.1640|
000668  1c6d              ADDS     r5,r5,#1
                  |L1.1642|
00066a  2d10              CMP      r5,#0x10
00066c  d3fc              BCC      |L1.1640|
;;;820    
;;;821    	if ( width == SD_1_BIT )
00066e  b934              CBNZ     r4,|L1.1662|
;;;822    	{
;;;823    		LPC_MCI->CLOCK &=  ~(1 << 11);	/* 1 bit bus */
000670  486c              LDR      r0,|L1.2084|
000672  6840              LDR      r0,[r0,#4]
000674  f4206000          BIC      r0,r0,#0x800
000678  496a              LDR      r1,|L1.2084|
00067a  6048              STR      r0,[r1,#4]
00067c  e007              B        |L1.1678|
                  |L1.1662|
;;;824    	}
;;;825    	else if ( width == SD_4_BIT )
00067e  2c01              CMP      r4,#1
000680  d105              BNE      |L1.1678|
;;;826    	{
;;;827    		LPC_MCI->CLOCK |=  (1 << 11);/* 4 bit bus */
000682  4868              LDR      r0,|L1.2084|
000684  6840              LDR      r0,[r0,#4]
000686  f4406000          ORR      r0,r0,#0x800
00068a  4966              LDR      r1,|L1.2084|
00068c  6048              STR      r0,[r1,#4]
                  |L1.1678|
;;;828    	}
;;;829    
;;;830    	if ( MCI_Acmd_SendBusWidth( BUS_WIDTH_4BITS ) != MCI_FUNC_OK )
00068e  200a              MOVS     r0,#0xa
000690  f7fffffe          BL       MCI_Acmd_SendBusWidth
000694  b110              CBZ      r0,|L1.1692|
;;;831    	{
;;;832    		return(MCI_FUNC_FAILED);
000696  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1690|
;;;833    	}
;;;834    
;;;835    	return MCI_FUNC_OK;
;;;836    }
00069a  bd30              POP      {r4,r5,pc}
                  |L1.1692|
00069c  2000              MOVS     r0,#0                 ;835
00069e  e7fc              B        |L1.1690|
;;;837    
                          ENDP

                  MCI_Cmd_SendOpCond PROC
;;;1225    ****************************************************************************/
;;;1226   int32_t MCI_Cmd_SendOpCond( void )
0006a0  b5f0              PUSH     {r4-r7,lr}
;;;1227   {
0006a2  b085              SUB      sp,sp,#0x14
;;;1228   	uint32_t i, retryCount;
;;;1229   	uint32_t respStatus;
;;;1230   	uint32_t respValue[4];
;;;1231   
;;;1232   	int32_t retval = MCI_FUNC_FAILED;
0006a4  f04f37ff          MOV      r7,#0xffffffff
;;;1233   
;;;1234   	retryCount = 0x200;			/* reset retry counter */
0006a8  f44f7600          MOV      r6,#0x200
;;;1235   
;;;1236   	while ( retryCount > 0 )
0006ac  e01c              B        |L1.1768|
                  |L1.1710|
;;;1237   	{
;;;1238   		respStatus = MCI_CmdResp(CMD1_SEND_OP_COND, OCR_INDEX, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
0006ae  2001              MOVS     r0,#1
0006b0  ab01              ADD      r3,sp,#4
0006b2  4602              MOV      r2,r0
0006b4  4961              LDR      r1,|L1.2108|
0006b6  9000              STR      r0,[sp,#0]
0006b8  f7fffffe          BL       MCI_CmdResp
0006bc  4604              MOV      r4,r0
;;;1239   
;;;1240   		if(respStatus & MCI_CMD_TIMEOUT)
0006be  f0140f04          TST      r4,#4
0006c2  d002              BEQ      |L1.1738|
;;;1241   		{
;;;1242   			retval = MCI_FUNC_TIMEOUT;
0006c4  f06f0702          MVN      r7,#2
0006c8  e008              B        |L1.1756|
                  |L1.1738|
;;;1243   		}
;;;1244   		else if ((respValue[0] & 0x80000000) == 0)
0006ca  9801              LDR      r0,[sp,#4]
0006cc  f0104f00          TST      r0,#0x80000000
0006d0  d102              BNE      |L1.1752|
;;;1245   		{
;;;1246   			//The card has not finished the power up routine
;;;1247   			retval = MCI_FUNC_BUS_NOT_IDLE;
0006d2  f06f0702          MVN      r7,#2
0006d6  e001              B        |L1.1756|
                  |L1.1752|
;;;1248   		}
;;;1249   		else
;;;1250   		{
;;;1251   			retval = MCI_FUNC_OK;
0006d8  2700              MOVS     r7,#0
;;;1252   			break;
0006da  e007              B        |L1.1772|
                  |L1.1756|
;;;1253   		}
;;;1254   
;;;1255   		for ( i = 0; i < 0x20; i++ );
0006dc  2500              MOVS     r5,#0
0006de  e000              B        |L1.1762|
                  |L1.1760|
0006e0  1c6d              ADDS     r5,r5,#1
                  |L1.1762|
0006e2  2d20              CMP      r5,#0x20
0006e4  d3fc              BCC      |L1.1760|
;;;1256   
;;;1257   		retryCount--;
0006e6  1e76              SUBS     r6,r6,#1
                  |L1.1768|
0006e8  2e00              CMP      r6,#0                 ;1236
0006ea  d1e0              BNE      |L1.1710|
                  |L1.1772|
0006ec  bf00              NOP                            ;1252
;;;1258   	}
;;;1259   
;;;1260   	return(retval);
0006ee  4638              MOV      r0,r7
;;;1261   }
0006f0  b005              ADD      sp,sp,#0x14
0006f2  bdf0              POP      {r4-r7,pc}
;;;1262   
                          ENDP

                  MCI_SetOutputMode PROC
;;;973     ***************************************************************************/
;;;974    void MCI_SetOutputMode(uint32_t mode)
0006f4  2801              CMP      r0,#1
;;;975    {
;;;976    	if(mode == MCI_OUTPUT_MODE_OPENDRAIN)
0006f6  d106              BNE      |L1.1798|
;;;977    	{
;;;978    		/* Set Open Drain output control for MMC */
;;;979    		LPC_MCI->POWER |= (1 << MCI_PWRCTRL_OPENDRAIN_POS) & MCI_PWRCTRL_BMASK;
0006f8  494a              LDR      r1,|L1.2084|
0006fa  6809              LDR      r1,[r1,#0]
0006fc  f0410140          ORR      r1,r1,#0x40
000700  4a48              LDR      r2,|L1.2084|
000702  6011              STR      r1,[r2,#0]
000704  e005              B        |L1.1810|
                  |L1.1798|
;;;980    	}
;;;981    	else
;;;982    	{
;;;983    		/* Clear Open Drain output control for SD */
;;;984    		LPC_MCI->POWER &= (~(1 << MCI_PWRCTRL_OPENDRAIN_POS) & MCI_PWRCTRL_BMASK);
000706  4947              LDR      r1,|L1.2084|
000708  6809              LDR      r1,[r1,#0]
00070a  f0010183          AND      r1,r1,#0x83
00070e  4a45              LDR      r2,|L1.2084|
000710  6011              STR      r1,[r2,#0]
                  |L1.1810|
;;;985    	}
;;;986    }
000712  4770              BX       lr
;;;987    
                          ENDP

                  MCI_Acmd_SendOpCond PROC
;;;1390    ****************************************************************************/
;;;1391   int32_t MCI_Acmd_SendOpCond(uint8_t hcsVal)
000714  e92d43f0          PUSH     {r4-r9,lr}
;;;1392   {
000718  b085              SUB      sp,sp,#0x14
00071a  4606              MOV      r6,r0
;;;1393   	uint32_t i, retryCount;
;;;1394   	uint32_t respStatus, argument;
;;;1395   	uint32_t respValue[4];
;;;1396   
;;;1397   	int32_t retval = MCI_FUNC_FAILED;
00071c  f04f39ff          MOV      r9,#0xffffffff
;;;1398   
;;;1399   	argument = OCR_INDEX | (hcsVal << MCI_ACMD41_HCS_POS);
000720  4846              LDR      r0,|L1.2108|
000722  ea407886          ORR      r8,r0,r6,LSL #30
;;;1400   
;;;1401   	/* timeout on SEND_OP_COND command on MMC, now, try SEND_APP_OP_COND
;;;1402   	command to SD */
;;;1403   	retryCount = 0x200;			/* reset retry counter */
000726  f44f7700          MOV      r7,#0x200
;;;1404   
;;;1405   	while ( retryCount > 0 )
00072a  e031              B        |L1.1936|
                  |L1.1836|
;;;1406   	{
;;;1407   		/* Clear Open Drain output control for SD */
;;;1408   		MCI_SetOutputMode(MCI_OUTPUT_MODE_PUSHPULL);
00072c  2000              MOVS     r0,#0
00072e  f7fffffe          BL       MCI_SetOutputMode
;;;1409   
;;;1410   		for ( i = 0; i < 0x3000; i++ );
000732  2400              MOVS     r4,#0
000734  e000              B        |L1.1848|
                  |L1.1846|
000736  1c64              ADDS     r4,r4,#1
                  |L1.1848|
000738  f5b45f40          CMP      r4,#0x3000
00073c  d3fb              BCC      |L1.1846|
;;;1411   
;;;1412   		if ((retval = MCI_Cmd_SendACMD()) == MCI_FUNC_OK)
00073e  f7fffffe          BL       MCI_Cmd_SendACMD
000742  ea5f0900          MOVS     r9,r0
000746  d11d              BNE      |L1.1924|
;;;1413   		{
;;;1414   			respStatus = MCI_CmdResp(ACMD41_SEND_APP_OP_COND, argument, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
000748  2001              MOVS     r0,#1
00074a  ab01              ADD      r3,sp,#4
00074c  4602              MOV      r2,r0
00074e  4641              MOV      r1,r8
000750  9000              STR      r0,[sp,#0]
000752  2029              MOVS     r0,#0x29
000754  f7fffffe          BL       MCI_CmdResp
000758  4605              MOV      r5,r0
;;;1415   
;;;1416   			if(respStatus & MCI_CMD_TIMEOUT)
00075a  f0150f04          TST      r5,#4
00075e  d002              BEQ      |L1.1894|
;;;1417   			{
;;;1418   				retval = MCI_FUNC_TIMEOUT;
000760  f06f0902          MVN      r9,#2
000764  e00e              B        |L1.1924|
                  |L1.1894|
;;;1419   			}
;;;1420   			else if (!(respValue[0] & 0x80000000))
000766  9801              LDR      r0,[sp,#4]
000768  f0104f00          TST      r0,#0x80000000
00076c  d102              BNE      |L1.1908|
;;;1421   			{
;;;1422   				retval = MCI_FUNC_BUS_NOT_IDLE;
00076e  f06f0902          MVN      r9,#2
000772  e007              B        |L1.1924|
                  |L1.1908|
;;;1423   			}
;;;1424   			else
;;;1425   			{
;;;1426   				CCS = (respValue[0]&(1<<30)) ? 1:0;
000774  9801              LDR      r0,[sp,#4]
000776  f3c07080          UBFX     r0,r0,#30,#1
00077a  4931              LDR      r1,|L1.2112|
00077c  7008              STRB     r0,[r1,#0]
;;;1427   				retval = MCI_FUNC_OK;
00077e  f04f0900          MOV      r9,#0
;;;1428   				break;
000782  e007              B        |L1.1940|
                  |L1.1924|
;;;1429   			}
;;;1430   		}
;;;1431   
;;;1432   		for ( i = 0; i < 0x20; i++ );
000784  2400              MOVS     r4,#0
000786  e000              B        |L1.1930|
                  |L1.1928|
000788  1c64              ADDS     r4,r4,#1
                  |L1.1930|
00078a  2c20              CMP      r4,#0x20
00078c  d3fc              BCC      |L1.1928|
;;;1433   
;;;1434   		retryCount--;
00078e  1e7f              SUBS     r7,r7,#1
                  |L1.1936|
000790  2f00              CMP      r7,#0                 ;1405
000792  d1cb              BNE      |L1.1836|
                  |L1.1940|
000794  bf00              NOP                            ;1428
;;;1435   	}
;;;1436   
;;;1437   	return retval;
000796  4648              MOV      r0,r9
;;;1438   }
000798  b005              ADD      sp,sp,#0x14
00079a  e8bd83f0          POP      {r4-r9,pc}
;;;1439   
                          ENDP

                  MCI_Cmd_SendIfCond PROC
;;;1270    ****************************************************************************/
;;;1271   int32_t MCI_Cmd_SendIfCond(void)
00079e  e92d47f0          PUSH     {r4-r10,lr}
;;;1272   {
0007a2  b085              SUB      sp,sp,#0x14
;;;1273   	uint32_t i, retryCount;
;;;1274   	uint32_t CmdArgument;
;;;1275   	uint32_t respStatus;
;;;1276   	uint32_t respValue[4];
;;;1277   
;;;1278   	int32_t retval = MCI_FUNC_FAILED;
0007a4  f04f3aff          MOV      r10,#0xffffffff
;;;1279   
;;;1280   	uint8_t voltageSupplied = 0x01;//in range 2.7-3.6V
0007a8  2701              MOVS     r7,#1
;;;1281   	uint8_t checkPattern = 0xAA;
0007aa  f04f08aa          MOV      r8,#0xaa
;;;1282   
;;;1283   	CmdArgument = (voltageSupplied << MCI_CMD8_VOLTAGESUPPLIED_POS) | checkPattern;
0007ae  ea482907          ORR      r9,r8,r7,LSL #8
;;;1284   
;;;1285   	retryCount = 20;
0007b2  2614              MOVS     r6,#0x14
;;;1286   
;;;1287   	while ( retryCount > 0 )
0007b4  e026              B        |L1.2052|
                  |L1.1974|
;;;1288   	{
;;;1289   		respStatus = MCI_CmdResp(CMD8_SEND_IF_COND, CmdArgument, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
0007b6  2001              MOVS     r0,#1
0007b8  ab01              ADD      r3,sp,#4
0007ba  4602              MOV      r2,r0
0007bc  4649              MOV      r1,r9
0007be  9000              STR      r0,[sp,#0]
0007c0  2008              MOVS     r0,#8
0007c2  f7fffffe          BL       MCI_CmdResp
0007c6  4604              MOV      r4,r0
;;;1290   
;;;1291   		if(respStatus & MCI_CMD_TIMEOUT)
0007c8  f0140f04          TST      r4,#4
0007cc  d002              BEQ      |L1.2004|
;;;1292   		{
;;;1293   			//Consider as no response
;;;1294   			retval = MCI_FUNC_TIMEOUT;
0007ce  f06f0a02          MVN      r10,#2
0007d2  e011              B        |L1.2040|
                  |L1.2004|
;;;1295   		}
;;;1296   		else if ((respValue[0] & MCI_CMD8_CHECKPATTERN_BMASK) != checkPattern)
0007d4  9801              LDR      r0,[sp,#4]
0007d6  b2c0              UXTB     r0,r0
0007d8  4540              CMP      r0,r8
0007da  d002              BEQ      |L1.2018|
;;;1297   		{
;;;1298   			retval = MCI_FUNC_FAILED;
0007dc  f04f3aff          MOV      r10,#0xffffffff
0007e0  e00a              B        |L1.2040|
                  |L1.2018|
;;;1299   		}
;;;1300   		else if (((respValue[0] >> MCI_CMD8_VOLTAGESUPPLIED_POS) & MCI_CMD8_VOLTAGESUPPLIED_BMASK)
0007e2  9801              LDR      r0,[sp,#4]
0007e4  f3c02007          UBFX     r0,r0,#8,#8
0007e8  42b8              CMP      r0,r7
0007ea  d002              BEQ      |L1.2034|
;;;1301   						!= voltageSupplied)
;;;1302   		{
;;;1303   			retval = MCI_FUNC_BAD_PARAMETERS;
0007ec  f06f0a01          MVN      r10,#1
0007f0  e002              B        |L1.2040|
                  |L1.2034|
;;;1304   		}
;;;1305   		else
;;;1306   		{
;;;1307   			retval = MCI_FUNC_OK;
0007f2  f04f0a00          MOV      r10,#0
;;;1308   			break;
0007f6  e007              B        |L1.2056|
                  |L1.2040|
;;;1309   		}
;;;1310   
;;;1311   		for ( i = 0; i < 0x20; i++ );
0007f8  2500              MOVS     r5,#0
0007fa  e000              B        |L1.2046|
                  |L1.2044|
0007fc  1c6d              ADDS     r5,r5,#1
                  |L1.2046|
0007fe  2d20              CMP      r5,#0x20
000800  d3fc              BCC      |L1.2044|
;;;1312   
;;;1313   		retryCount--;
000802  1e76              SUBS     r6,r6,#1
                  |L1.2052|
000804  2e00              CMP      r6,#0                 ;1287
000806  d1d6              BNE      |L1.1974|
                  |L1.2056|
000808  bf00              NOP                            ;1308
;;;1314   	}
;;;1315   
;;;1316   	return retval;
00080a  4650              MOV      r0,r10
;;;1317   }
00080c  b005              ADD      sp,sp,#0x14
00080e  e8bd87f0          POP      {r4-r10,pc}
;;;1318   
                          ENDP

                  MCI_CardReset PROC
;;;1208    ***************************************************************************/
;;;1209   int32_t MCI_CardReset(void)
000812  b500              PUSH     {lr}
;;;1210   {
;;;1211   	/* Because CMD0 command to put the device to idle state does not need response 
;;;1212   	since, it's only sending commad */
;;;1213   	MCI_SendCmd(CMD0_GO_IDLE_STATE, 0x00000000, EXPECT_NO_RESP, 0);
000814  2300              MOVS     r3,#0
000816  461a              MOV      r2,r3
000818  4619              MOV      r1,r3
00081a  4618              MOV      r0,r3
00081c  f7fffffe          BL       MCI_SendCmd
;;;1214   
;;;1215   	return MCI_FUNC_OK;
000820  2000              MOVS     r0,#0
;;;1216   }
000822  bd00              POP      {pc}
                  |L1.2084|
                          DCD      0x400c0000
                  |L1.2088|
                          DCD      Mci_Data_Xfer_End
                  |L1.2092|
                          DCD      Mci_Data_Xfer_ERR
                  |L1.2096|
                          DCD      0x000fc400
                  |L1.2100|
                          DCD      MCI_CardType
                  |L1.2104|
                          DCD      CardRCA
                  |L1.2108|
                          DCD      0x00ff8000
                  |L1.2112|
                          DCD      ||CCS||
                          ENDP

                  MCI_CardInit PROC
;;;1455    ****************************************************************************/
;;;1456   int32_t MCI_CardInit( void )
000844  b530              PUSH     {r4,r5,lr}
;;;1457   {
;;;1458   	uint32_t i;
;;;1459   	int32_t retval = MCI_FUNC_FAILED;
000846  f04f34ff          MOV      r4,#0xffffffff
;;;1460   
;;;1461   	MCI_CardType = MCI_CARD_UNKNOWN;
00084a  20ff              MOVS     r0,#0xff
00084c  49f9              LDR      r1,|L1.3124|
00084e  7008              STRB     r0,[r1,#0]
;;;1462   
;;;1463   	if (MCI_CardReset() != MCI_FUNC_OK)
000850  f7fffffe          BL       MCI_CardReset
000854  b108              CBZ      r0,|L1.2138|
;;;1464   	{
;;;1465   		return MCI_FUNC_FAILED;
000856  4620              MOV      r0,r4
                  |L1.2136|
;;;1466   	}
;;;1467   
;;;1468   	/* Clear Open Drain output control for SD */
;;;1469   	MCI_SetOutputMode(MCI_OUTPUT_MODE_PUSHPULL);
;;;1470   
;;;1471   	for ( i = 0; i < 0x3000; i++ );
;;;1472   
;;;1473   	retval = MCI_Cmd_SendIfCond();
;;;1474   
;;;1475   	if(retval == MCI_FUNC_BAD_PARAMETERS)
;;;1476   	{
;;;1477   		//Unknow card is unusable
;;;1478   		return retval;
;;;1479   	}
;;;1480   
;;;1481   	if(retval == MCI_FUNC_OK) /* Ver2.00 or later*/
;;;1482   	{
;;;1483   		//Check in case of High Capacity Supporting Host
;;;1484   		if ((retval = MCI_Acmd_SendOpCond(1)) == MCI_FUNC_OK)
;;;1485   		{
;;;1486               MCI_CardType = MCI_SDSC_V2_CARD;//SDSC
;;;1487               
;;;1488               if(CCS )
;;;1489               {
;;;1490       			MCI_CardType = MCI_SDHC_SDXC_CARD;//SDHC or SDXC 
;;;1491               }
;;;1492   
;;;1493   			return MCI_FUNC_OK;	/* Found the card, it's a hD */
;;;1494   		}
;;;1495   	}
;;;1496   
;;;1497   	if(retval != MCI_FUNC_OK) /* voltage mismatch (ver2.00)or ver1.X SD Card or not SD Card*/
;;;1498   	{
;;;1499   		
;;;1500   		//Check in case of Standard Capacity Supporting Host
;;;1501   		if ((retval = MCI_Acmd_SendOpCond(0)) == MCI_FUNC_OK)
;;;1502   		{
;;;1503   			MCI_CardType = MCI_SDSC_V1_CARD;//Support Standard Capacity only
;;;1504   
;;;1505   			return MCI_FUNC_OK;	/* Found the card, it's a SD */
;;;1506   		}
;;;1507   	}
;;;1508   
;;;1509   	if(retval != MCI_FUNC_OK)
;;;1510   	{
;;;1511   		/* Set Open Drain output control for MMC */
;;;1512   		MCI_SetOutputMode(MCI_OUTPUT_MODE_OPENDRAIN);
;;;1513   
;;;1514   		for ( i = 0; i < 0x3000; i++ );
;;;1515   
;;;1516   		/* Try CMD1 first for MMC, if it's timeout, try CMD55 and CMD41 for SD,
;;;1517   		if both failed, initialization faIlure, bailout. */
;;;1518   		if (MCI_Cmd_SendOpCond() == MCI_FUNC_OK)
;;;1519   		{
;;;1520   			MCI_CardType = MCI_MMC_CARD;
;;;1521   
;;;1522   			return MCI_FUNC_OK;	/* Found the card, it's a MMC */
;;;1523   		}
;;;1524   	}
;;;1525   
;;;1526   	/* tried both MMC and SD card, give up */
;;;1527   	return MCI_FUNC_OK;
;;;1528   }
000858  bd30              POP      {r4,r5,pc}
                  |L1.2138|
00085a  2000              MOVS     r0,#0                 ;1469
00085c  f7fffffe          BL       MCI_SetOutputMode
000860  2500              MOVS     r5,#0                 ;1471
000862  e000              B        |L1.2150|
                  |L1.2148|
000864  1c6d              ADDS     r5,r5,#1              ;1471
                  |L1.2150|
000866  f5b55f40          CMP      r5,#0x3000            ;1471
00086a  d3fb              BCC      |L1.2148|
00086c  f7fffffe          BL       MCI_Cmd_SendIfCond
000870  4604              MOV      r4,r0                 ;1473
000872  1ca0              ADDS     r0,r4,#2              ;1475
000874  d101              BNE      |L1.2170|
000876  4620              MOV      r0,r4                 ;1478
000878  e7ee              B        |L1.2136|
                  |L1.2170|
00087a  b974              CBNZ     r4,|L1.2202|
00087c  2001              MOVS     r0,#1                 ;1484
00087e  f7fffffe          BL       MCI_Acmd_SendOpCond
000882  0004              MOVS     r4,r0                 ;1484
000884  d109              BNE      |L1.2202|
000886  2002              MOVS     r0,#2                 ;1486
000888  49ea              LDR      r1,|L1.3124|
00088a  7008              STRB     r0,[r1,#0]            ;1486
00088c  48ea              LDR      r0,|L1.3128|
00088e  7800              LDRB     r0,[r0,#0]            ;1488  ; CCS
000890  b108              CBZ      r0,|L1.2198|
000892  2003              MOVS     r0,#3                 ;1490
000894  7008              STRB     r0,[r1,#0]            ;1490
                  |L1.2198|
000896  2000              MOVS     r0,#0                 ;1493
000898  e7de              B        |L1.2136|
                  |L1.2202|
00089a  b13c              CBZ      r4,|L1.2220|
00089c  2000              MOVS     r0,#0                 ;1501
00089e  f7fffffe          BL       MCI_Acmd_SendOpCond
0008a2  0004              MOVS     r4,r0                 ;1501
0008a4  d102              BNE      |L1.2220|
0008a6  49e3              LDR      r1,|L1.3124|
0008a8  7008              STRB     r0,[r1,#0]            ;1503
0008aa  e7d5              B        |L1.2136|
                  |L1.2220|
0008ac  b184              CBZ      r4,|L1.2256|
0008ae  2001              MOVS     r0,#1                 ;1512
0008b0  f7fffffe          BL       MCI_SetOutputMode
0008b4  2500              MOVS     r5,#0                 ;1514
0008b6  e000              B        |L1.2234|
                  |L1.2232|
0008b8  1c6d              ADDS     r5,r5,#1              ;1514
                  |L1.2234|
0008ba  f5b55f40          CMP      r5,#0x3000            ;1514
0008be  d3fb              BCC      |L1.2232|
0008c0  f7fffffe          BL       MCI_Cmd_SendOpCond
0008c4  b920              CBNZ     r0,|L1.2256|
0008c6  2001              MOVS     r0,#1                 ;1520
0008c8  49da              LDR      r1,|L1.3124|
0008ca  7008              STRB     r0,[r1,#0]            ;1520
0008cc  2000              MOVS     r0,#0                 ;1522
0008ce  e7c3              B        |L1.2136|
                  |L1.2256|
0008d0  2000              MOVS     r0,#0                 ;1527
0008d2  e7c1              B        |L1.2136|
;;;1529   
                          ENDP

                  MCI_Init PROC
;;;847     ***************************************************************************/
;;;848    int32_t MCI_Init(uint8_t powerActiveLevel )
0008d4  b570              PUSH     {r4-r6,lr}
;;;849    {
0008d6  4605              MOV      r5,r0
;;;850    	uint32_t i;
;;;851    
;;;852    	MCI_CardType = MCI_CARD_UNKNOWN;
0008d8  20ff              MOVS     r0,#0xff
0008da  49d6              LDR      r1,|L1.3124|
0008dc  7008              STRB     r0,[r1,#0]
;;;853    
;;;854    	// Following block of code added to ensure card VCC drops to zero
;;;855        // before card is initialized
;;;856      
;;;857       // Force all MCI control pins to basic I/O mode
;;;858       LPC_IOCON->P1_2  &= ~0x1F; /* SD_CLK @ P1.2 */
0008de  48d7              LDR      r0,|L1.3132|
0008e0  6800              LDR      r0,[r0,#0]
0008e2  f020001f          BIC      r0,r0,#0x1f
0008e6  49d6              LDR      r1,|L1.3136|
0008e8  f8c10088          STR      r0,[r1,#0x88]
;;;859       LPC_IOCON->P1_3  &= ~0x1F; /* SD_CMD @ P1.3 */
0008ec  4608              MOV      r0,r1
0008ee  f8d0008c          LDR      r0,[r0,#0x8c]
0008f2  f020001f          BIC      r0,r0,#0x1f
0008f6  f8c1008c          STR      r0,[r1,#0x8c]
;;;860       LPC_IOCON->P1_5  &= ~0x1F; /* SD_PWR @ P1.5 */
0008fa  4608              MOV      r0,r1
0008fc  f8d00094          LDR      r0,[r0,#0x94]
000900  f020001f          BIC      r0,r0,#0x1f
000904  f8c10094          STR      r0,[r1,#0x94]
;;;861       LPC_IOCON->P1_6  &= ~0x1F; /* SD_DAT_0 @ P1.6 */
000908  4608              MOV      r0,r1
00090a  f8d00098          LDR      r0,[r0,#0x98]
00090e  f020001f          BIC      r0,r0,#0x1f
000912  f8c10098          STR      r0,[r1,#0x98]
;;;862       LPC_IOCON->P1_7  &= ~0x1F; /* SD_DAT_1 @ P1.7 */
000916  4608              MOV      r0,r1
000918  f8d0009c          LDR      r0,[r0,#0x9c]
00091c  f020001f          BIC      r0,r0,#0x1f
000920  f8c1009c          STR      r0,[r1,#0x9c]
;;;863       LPC_IOCON->P1_11 &= ~0x1F; /* SD_DAT_2 @ P1.11 */
000924  4608              MOV      r0,r1
000926  f8d000ac          LDR      r0,[r0,#0xac]
00092a  f020001f          BIC      r0,r0,#0x1f
00092e  f8c100ac          STR      r0,[r1,#0xac]
;;;864       LPC_IOCON->P1_12 &= 0x1F; /* SD_DAT_3 @ P1.12 */
000932  4608              MOV      r0,r1
000934  f8d000b0          LDR      r0,[r0,#0xb0]
000938  f000001f          AND      r0,r0,#0x1f
00093c  f8c100b0          STR      r0,[r1,#0xb0]
;;;865    
;;;866       // Set all MCI pins to outputs
;;;867       LPC_GPIO1->DIR |= 0x18EC;
000940  48c0              LDR      r0,|L1.3140|
000942  6a00              LDR      r0,[r0,#0x20]
000944  f64101ec          MOV      r1,#0x18ec
000948  ea400001          ORR      r0,r0,r1
00094c  49bd              LDR      r1,|L1.3140|
00094e  6208              STR      r0,[r1,#0x20]
;;;868      
;;;869       // Force all pins low (except power control pin)
;;;870       LPC_GPIO1->CLR = 0x1000;
000950  f44f5080          MOV      r0,#0x1000
000954  63c8              STR      r0,[r1,#0x3c]
;;;871       LPC_GPIO1->CLR = 0x0800;
000956  f44f6000          MOV      r0,#0x800
00095a  63c8              STR      r0,[r1,#0x3c]
;;;872       LPC_GPIO1->CLR = 0x0080;
00095c  f04f0080          MOV      r0,#0x80
000960  63c8              STR      r0,[r1,#0x3c]
;;;873       LPC_GPIO1->CLR = 0x0040;
000962  f04f0040          MOV      r0,#0x40
000966  63c8              STR      r0,[r1,#0x3c]
;;;874      
;;;875       LPC_GPIO1->SET = 0x0020;
000968  f04f0020          MOV      r0,#0x20
00096c  6388              STR      r0,[r1,#0x38]
;;;876      
;;;877       LPC_GPIO1->CLR = 0x0008;
00096e  f04f0008          MOV      r0,#8
000972  63c8              STR      r0,[r1,#0x3c]
;;;878       LPC_GPIO1->CLR = 0x0004;
000974  f04f0004          MOV      r0,#4
000978  63c8              STR      r0,[r1,#0x3c]
;;;879    
;;;880       // Crude delay of 50ms at 120MHz
;;;881       for ( i = 0; i < 0x100000; i++ );
00097a  f04f0400          MOV      r4,#0
00097e  e000              B        |L1.2434|
                  |L1.2432|
000980  1c64              ADDS     r4,r4,#1
                  |L1.2434|
000982  f5b41f80          CMP      r4,#0x100000
000986  d3fb              BCC      |L1.2432|
;;;882    
;;;883    	LPC_SC->PCONP |= ( 1 << 28 );			/* Enable clock to the MCI block */
000988  48af              LDR      r0,|L1.3144|
00098a  6800              LDR      r0,[r0,#0]
00098c  f0405080          ORR      r0,r0,#0x10000000
000990  49ae              LDR      r1,|L1.3148|
000992  f8c100c4          STR      r0,[r1,#0xc4]
;;;884    
;;;885    	if ( LPC_MCI->CLOCK & (1 << 8) )
000996  48ae              LDR      r0,|L1.3152|
000998  6840              LDR      r0,[r0,#4]
00099a  f4107f80          TST      r0,#0x100
00099e  d005              BEQ      |L1.2476|
;;;886    	{
;;;887    		LPC_MCI->CLOCK &= ~(1 << 8);
0009a0  48ab              LDR      r0,|L1.3152|
0009a2  6840              LDR      r0,[r0,#4]
0009a4  f4207080          BIC      r0,r0,#0x100
0009a8  49a9              LDR      r1,|L1.3152|
0009aa  6048              STR      r0,[r1,#4]
                  |L1.2476|
;;;888    	}
;;;889    
;;;890    	if ( LPC_MCI->POWER & 0x02 )
0009ac  48a8              LDR      r0,|L1.3152|
0009ae  6800              LDR      r0,[r0,#0]
0009b0  f0100f02          TST      r0,#2
0009b4  d002              BEQ      |L1.2492|
;;;891    	{
;;;892    		LPC_MCI->POWER = 0x00;
0009b6  2000              MOVS     r0,#0
0009b8  49a5              LDR      r1,|L1.3152|
0009ba  6008              STR      r0,[r1,#0]
                  |L1.2492|
;;;893    	}
;;;894    
;;;895    	for ( i = 0; i < 0x1000; i++ );
0009bc  2400              MOVS     r4,#0
0009be  e000              B        |L1.2498|
                  |L1.2496|
0009c0  1c64              ADDS     r4,r4,#1
                  |L1.2498|
0009c2  f5b45f80          CMP      r4,#0x1000
0009c6  d3fb              BCC      |L1.2496|
;;;896    
;;;897    	/* Disable all interrupts for now */
;;;898    	LPC_MCI->MASK0 = 0;
0009c8  2000              MOVS     r0,#0
0009ca  49a1              LDR      r1,|L1.3152|
0009cc  63c8              STR      r0,[r1,#0x3c]
;;;899    
;;;900    	//SD_CLK
;;;901    	PINSEL_ConfigPin(1, 2, 2);
0009ce  2202              MOVS     r2,#2
0009d0  4611              MOV      r1,r2
0009d2  2001              MOVS     r0,#1
0009d4  f7fffffe          BL       PINSEL_ConfigPin
;;;902    
;;;903    	//SD_CMD
;;;904    	PINSEL_ConfigPin(1, 3, 2);
0009d8  2202              MOVS     r2,#2
0009da  2103              MOVS     r1,#3
0009dc  2001              MOVS     r0,#1
0009de  f7fffffe          BL       PINSEL_ConfigPin
;;;905    
;;;906    	//SD_PWR
;;;907    	PINSEL_ConfigPin(1, 5, 2);
0009e2  2202              MOVS     r2,#2
0009e4  2105              MOVS     r1,#5
0009e6  2001              MOVS     r0,#1
0009e8  f7fffffe          BL       PINSEL_ConfigPin
;;;908    
;;;909    	//SD_DAT_0
;;;910    	PINSEL_ConfigPin(1, 6, 2);
0009ec  2202              MOVS     r2,#2
0009ee  2106              MOVS     r1,#6
0009f0  2001              MOVS     r0,#1
0009f2  f7fffffe          BL       PINSEL_ConfigPin
;;;911    
;;;912    	//SD_DAT_1
;;;913    	PINSEL_ConfigPin(1, 7, 2);
0009f6  2202              MOVS     r2,#2
0009f8  2107              MOVS     r1,#7
0009fa  2001              MOVS     r0,#1
0009fc  f7fffffe          BL       PINSEL_ConfigPin
;;;914    
;;;915    	//SD_DAT_2
;;;916    	PINSEL_ConfigPin(1, 11, 2);
000a00  2202              MOVS     r2,#2
000a02  210b              MOVS     r1,#0xb
000a04  2001              MOVS     r0,#1
000a06  f7fffffe          BL       PINSEL_ConfigPin
;;;917    
;;;918    	//SD_DAT_3
;;;919    	PINSEL_ConfigPin(1, 12, 2);
000a0a  2202              MOVS     r2,#2
000a0c  210c              MOVS     r1,#0xc
000a0e  2001              MOVS     r0,#1
000a10  f7fffffe          BL       PINSEL_ConfigPin
;;;920    
;;;921    	// SD_PWR is active high (follows the output of the SD Card interface block).
;;;922    	if(powerActiveLevel == LOW_LVL)
000a14  b93d              CBNZ     r5,|L1.2598|
;;;923    	{
;;;924    		LPC_SC->SCS &= ~ 0x08;//Becase on EA board SD_PWR is active low
000a16  488f              LDR      r0,|L1.3156|
000a18  6800              LDR      r0,[r0,#0]
000a1a  f0200008          BIC      r0,r0,#8
000a1e  498b              LDR      r1,|L1.3148|
000a20  f8c101a0          STR      r0,[r1,#0x1a0]
000a24  e006              B        |L1.2612|
                  |L1.2598|
;;;925    	}
;;;926    	else
;;;927    	{
;;;928    		LPC_SC->SCS |= 0x08;
000a26  488b              LDR      r0,|L1.3156|
000a28  6800              LDR      r0,[r0,#0]
000a2a  f0400008          ORR      r0,r0,#8
000a2e  4987              LDR      r1,|L1.3148|
000a30  f8c101a0          STR      r0,[r1,#0x1a0]
                  |L1.2612|
;;;929    	}
;;;930    
;;;931    	//Setting for timeout problem
;;;932    	LPC_MCI->DATATMR = 0x1FFFFFFF;
000a34  f06f4060          MVN      r0,#0xe0000000
000a38  4985              LDR      r1,|L1.3152|
000a3a  6248              STR      r0,[r1,#0x24]
;;;933    
;;;934    	/*set up clocking default mode, clear any registers as needed */
;;;935    	LPC_MCI->COMMAND = 0;
000a3c  f04f0000          MOV      r0,#0
000a40  60c8              STR      r0,[r1,#0xc]
;;;936    	LPC_MCI->DATACTRL = 0;
000a42  62c8              STR      r0,[r1,#0x2c]
;;;937    	LPC_MCI->CLEAR = 0x7FF;		/* clear all pending interrupts */
000a44  f24070ff          MOV      r0,#0x7ff
000a48  6388              STR      r0,[r1,#0x38]
;;;938    
;;;939    	LPC_MCI->POWER = 0x02;		/* power up */
000a4a  f04f0002          MOV      r0,#2
000a4e  6008              STR      r0,[r1,#0]
;;;940    	while ( !(LPC_MCI->POWER & 0x02) );
000a50  bf00              NOP      
                  |L1.2642|
000a52  487f              LDR      r0,|L1.3152|
000a54  6800              LDR      r0,[r0,#0]
000a56  f0100f02          TST      r0,#2
000a5a  d0fa              BEQ      |L1.2642|
;;;941    
;;;942    	for ( i = 0; i < 0x100; i++ );
000a5c  2400              MOVS     r4,#0
000a5e  e000              B        |L1.2658|
                  |L1.2656|
000a60  1c64              ADDS     r4,r4,#1
                  |L1.2658|
000a62  2cff              CMP      r4,#0xff
000a64  d9fc              BLS      |L1.2656|
;;;943    
;;;944    	/* During identification phase, the clock should be less than
;;;945    	400Khz. Once we pass this phase, the normal clock can be set up
;;;946    	to 25Mhz on SD card and 20Mhz on MMC card. */
;;;947    	MCI_Set_MCIClock(MCI_SLOW_RATE );
000a66  2001              MOVS     r0,#1
000a68  f7fffffe          BL       MCI_Set_MCIClock
;;;948    
;;;949    	LPC_MCI->POWER |= 0x01;		/* bit 1 is set already, from power up to power on */
000a6c  4878              LDR      r0,|L1.3152|
000a6e  6800              LDR      r0,[r0,#0]
000a70  f0400001          ORR      r0,r0,#1
000a74  4976              LDR      r1,|L1.3152|
000a76  6008              STR      r0,[r1,#0]
;;;950    
;;;951    	for ( i = 0; i < 0x2000; i++ );
000a78  2400              MOVS     r4,#0
000a7a  e000              B        |L1.2686|
                  |L1.2684|
000a7c  1c64              ADDS     r4,r4,#1
                  |L1.2686|
000a7e  f5b45f00          CMP      r4,#0x2000
000a82  d3fb              BCC      |L1.2684|
;;;952    
;;;953    	NVIC_EnableIRQ(MCI_IRQn);
000a84  201d              MOVS     r0,#0x1d
000a86  f7fffffe          BL       NVIC_EnableIRQ
;;;954    
;;;955    	MCI_CardInit();
000a8a  f7fffffe          BL       MCI_CardInit
;;;956    
;;;957    	/* During the initialization phase, to simplify the process, the CMD related
;;;958    	interrupts are disabled. The DATA related interrupts are enabled when
;;;959    	the FIFOs are used and just before WRITE_BLOCK READ_BLOCK cmds are issues, and
;;;960    	disabled after the data block has been written and read. Please also note,
;;;961    	before WRITE_BLOCK only TX related data interrupts are enabled, and before
;;;962    	READ_BLOCK only RX related data interrupts are enabled. */
;;;963    	return MCI_FUNC_OK;
000a8e  2000              MOVS     r0,#0
;;;964    }
000a90  bd70              POP      {r4-r6,pc}
;;;965    
                          ENDP

                  MCI_GetCardType PROC
;;;1537    ****************************************************************************/
;;;1538   en_Mci_CardType MCI_GetCardType(void)
000a92  4868              LDR      r0,|L1.3124|
;;;1539   {
;;;1540   	return MCI_CardType;
000a94  f9900000          LDRSB    r0,[r0,#0]  ; MCI_CardType
;;;1541   }
000a98  4770              BX       lr
;;;1542   
                          ENDP

                  MCI_GetCID PROC
;;;1552    ****************************************************************************/
;;;1553   int32_t MCI_GetCID(st_Mci_CardId* cidValue)
000a9a  b5f0              PUSH     {r4-r7,lr}
;;;1554   {
000a9c  b085              SUB      sp,sp,#0x14
000a9e  4604              MOV      r4,r0
;;;1555   	uint32_t i, retryCount;
;;;1556   	uint32_t respStatus;
;;;1557   	uint32_t respValue[4];
;;;1558   
;;;1559   	/* This command is normally after CMD1(MMC) or ACMD41(SD). */
;;;1560   	retryCount = 0x200;// 0x20;			/* reset retry counter */
000aa0  f44f7700          MOV      r7,#0x200
;;;1561   
;;;1562   	while ( retryCount > 0 )
000aa4  e039              B        |L1.2842|
                  |L1.2726|
;;;1563   	{
;;;1564   #if 1
;;;1565   		respStatus = MCI_CmdResp(CMD2_ALL_SEND_CID, 0, EXPECT_LONG_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
000aa6  2001              MOVS     r0,#1
000aa8  ab01              ADD      r3,sp,#4
000aaa  2202              MOVS     r2,#2
000aac  2100              MOVS     r1,#0
000aae  9000              STR      r0,[sp,#0]
000ab0  4610              MOV      r0,r2
000ab2  f7fffffe          BL       MCI_CmdResp
000ab6  4605              MOV      r5,r0
;;;1566   
;;;1567   		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
;;;1568   		//if ((!(respStatus & MCI_CMD_TIMEOUT)) && (!(respStatus & MCI_CMD_CRC_FAIL)))
;;;1569   		if (!(respStatus & MCI_CMD_TIMEOUT))
000ab8  f0150f04          TST      r5,#4
000abc  d127              BNE      |L1.2830|
;;;1570   		{
;;;1571   			// Parsing the data retrieved
;;;1572   			if(cidValue != NULL)
000abe  b31c              CBZ      r4,|L1.2824|
;;;1573   			{
;;;1574   				cidValue->MID = (respValue[0] >> MCI_CID_MANUFACTURER_ID_WPOS) & MCI_CID_MANUFACTURER_ID_WBMASK;
000ac0  9801              LDR      r0,[sp,#4]
000ac2  0e00              LSRS     r0,r0,#24
000ac4  7020              STRB     r0,[r4,#0]
;;;1575   
;;;1576   				cidValue->OID = (respValue[0] >> MCI_CID_OEMAPPLICATION_ID_WPOS) & MCI_CID_OEMAPPLICATION_ID_WBMASK;
000ac6  9801              LDR      r0,[sp,#4]
000ac8  f3c0200f          UBFX     r0,r0,#8,#16
000acc  8060              STRH     r0,[r4,#2]
;;;1577   
;;;1578   				cidValue->PNM_H = (respValue[0] >> MCI_CID_PRODUCTNAME_ID_H_WPOS) & MCI_CID_PRODUCTNAME_ID_H_WBMASK;
000ace  9801              LDR      r0,[sp,#4]
000ad0  7120              STRB     r0,[r4,#4]
;;;1579   
;;;1580   				cidValue->PNM_L = (respValue[1] >> MCI_CID_PRODUCTNAME_ID_L_WPOS) & MCI_CID_PRODUCTNAME_ID_L_WBMASK;
000ad2  9802              LDR      r0,[sp,#8]
000ad4  60a0              STR      r0,[r4,#8]
;;;1581   
;;;1582   				cidValue->PRV = (respValue[2] >> MCI_CID_PRODUCTREVISION_ID_WPOS) & MCI_CID_PRODUCTREVISION_ID_WBMASK;
000ad6  9803              LDR      r0,[sp,#0xc]
000ad8  0e00              LSRS     r0,r0,#24
000ada  7320              STRB     r0,[r4,#0xc]
;;;1583   
;;;1584   				cidValue->PSN = (((respValue[2] >> MCI_CID_PRODUCTSERIALNUM_ID_H_WPOS) & MCI_CID_PRODUCTSERIALNUM_ID_H_WBMASK) << 8)
000adc  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000ae0  0e00              LSRS     r0,r0,#24
000ae2  f361201f          BFI      r0,r1,#8,#24
000ae6  6120              STR      r0,[r4,#0x10]
;;;1585   											| ((respValue[3] >> MCI_CID_PRODUCTSERIALNUM_ID_L_WPOS) & MCI_CID_PRODUCTSERIALNUM_ID_L_WBMASK);
;;;1586   
;;;1587   				cidValue->reserved = (respValue[3] >> MCI_CID_RESERVED_ID_WPOS) & MCI_CID_RESERVED_ID_WBMASK;
000ae8  9804              LDR      r0,[sp,#0x10]
000aea  f3c05004          UBFX     r0,r0,#20,#5
000aee  7520              STRB     r0,[r4,#0x14]
;;;1588   
;;;1589   				cidValue->MDT = (respValue[3] >> MCI_CID_MANUFACTURINGDATE_ID_WPOS) & MCI_CID_MANUFACTURINGDATE_ID_WBMASK;
000af0  9804              LDR      r0,[sp,#0x10]
000af2  f3c0200b          UBFX     r0,r0,#8,#12
000af6  82e0              STRH     r0,[r4,#0x16]
;;;1590   
;;;1591   				cidValue->CRC = (respValue[3] >> MCI_CID_CHECKSUM_ID_WPOS) & MCI_CID_CHECKSUM_ID_WBMASK;
000af8  9804              LDR      r0,[sp,#0x10]
000afa  f3c00046          UBFX     r0,r0,#1,#7
000afe  7620              STRB     r0,[r4,#0x18]
;;;1592   
;;;1593   				cidValue->unused = (respValue[3] >> MCI_CID_UNUSED_ID_WPOS) & MCI_CID_UNUSED_ID_WBMASK;
000b00  9804              LDR      r0,[sp,#0x10]
000b02  f0000001          AND      r0,r0,#1
000b06  7660              STRB     r0,[r4,#0x19]
                  |L1.2824|
;;;1594   
;;;1595   			}
;;;1596   
;;;1597   			return  MCI_FUNC_OK;	/* response is back and correct. */
000b08  2000              MOVS     r0,#0
                  |L1.2826|
;;;1598   		}
;;;1599   #else
;;;1600   		respCmdValue[0] = 0x00000000;
;;;1601   		respCmdValue[1] = 0x00000000;
;;;1602   		respCmdValue[2] = 0x00000000;
;;;1603   		respCmdValue[3] = 0x00000000;
;;;1604   
;;;1605   		respStatus = MCI_CmdResp(CMD2_ALL_SEND_CID, 0, EXPECT_LONG_RESP, (uint32_t *)&respCmdValue[0], ALLOW_CMD_TIMER);
;;;1606   
;;;1607   		/* bit 0 and bit 2 must be zero, or it's timeout or CRC error */
;;;1608   		if (!(respStatus & MCI_CMD_TIMEOUT))
;;;1609   		{
;;;1610   			// Parsing the data retrieved
;;;1611   			if(cidValue != NULL)
;;;1612   			{
;;;1613   				cidValue->MID = (respCmdValue[0] >> MCI_CID_MANUFACTURER_ID_WPOS) & MCI_CID_MANUFACTURER_ID_WBMASK;
;;;1614   
;;;1615   				cidValue->OID = (respCmdValue[0] >> MCI_CID_OEMAPPLICATION_ID_WPOS) & MCI_CID_OEMAPPLICATION_ID_WBMASK;
;;;1616   
;;;1617   				cidValue->PNM_H = (respCmdValue[0] >> MCI_CID_PRODUCTNAME_ID_H_WPOS) & MCI_CID_PRODUCTNAME_ID_H_WBMASK;
;;;1618   
;;;1619   				cidValue->PNM_L = (respCmdValue[1] >> MCI_CID_PRODUCTNAME_ID_L_WPOS) & MCI_CID_PRODUCTNAME_ID_L_WBMASK;
;;;1620   
;;;1621   				cidValue->PRV = (respCmdValue[2] >> MCI_CID_PRODUCTREVISION_ID_WPOS) & MCI_CID_PRODUCTREVISION_ID_WBMASK;
;;;1622   
;;;1623   				cidValue->PSN = (((respCmdValue[2] >> MCI_CID_PRODUCTSERIALNUM_ID_H_WPOS) & MCI_CID_PRODUCTSERIALNUM_ID_H_WBMASK) << 8)
;;;1624   											| (respCmdValue[3] >> MCI_CID_PRODUCTSERIALNUM_ID_L_WPOS) & MCI_CID_PRODUCTSERIALNUM_ID_L_WBMASK;
;;;1625   
;;;1626   				cidValue->reserved = (respCmdValue[3] >> MCI_CID_RESERVED_ID_WPOS) & MCI_CID_RESERVED_ID_WBMASK;
;;;1627   
;;;1628   				cidValue->MDT = (respCmdValue[3] >> MCI_CID_MANUFACTURINGDATE_ID_WPOS) & MCI_CID_MANUFACTURINGDATE_ID_WBMASK;
;;;1629   
;;;1630   				cidValue->CRC = (respCmdValue[3] >> MCI_CID_CHECKSUM_ID_WPOS) & MCI_CID_CHECKSUM_ID_WBMASK;
;;;1631   
;;;1632   				cidValue->unused = (respCmdValue[3] >> MCI_CID_UNUSED_ID_WPOS) & MCI_CID_UNUSED_ID_WBMASK;
;;;1633   
;;;1634   			}
;;;1635   
;;;1636   			return	MCI_FUNC_OK; /* response is back and correct. */
;;;1637   		}
;;;1638   #endif
;;;1639   
;;;1640   		for ( i = 0; i < 0x20; i++ );
;;;1641   
;;;1642   		retryCount--;
;;;1643   	}
;;;1644   
;;;1645   	return MCI_FUNC_TIMEOUT;
;;;1646   }
000b0a  b005              ADD      sp,sp,#0x14
000b0c  bdf0              POP      {r4-r7,pc}
                  |L1.2830|
000b0e  2600              MOVS     r6,#0                 ;1640
000b10  e000              B        |L1.2836|
                  |L1.2834|
000b12  1c76              ADDS     r6,r6,#1              ;1640
                  |L1.2836|
000b14  2e20              CMP      r6,#0x20              ;1640
000b16  d3fc              BCC      |L1.2834|
000b18  1e7f              SUBS     r7,r7,#1              ;1642
                  |L1.2842|
000b1a  2f00              CMP      r7,#0                 ;1562
000b1c  d1c3              BNE      |L1.2726|
000b1e  1ef8              SUBS     r0,r7,#3              ;1645
000b20  e7f3              B        |L1.2826|
;;;1647   
                          ENDP

                  MCI_SetCardAddress PROC
;;;1657    ****************************************************************************/
;;;1658   int32_t MCI_SetCardAddress( void )
000b22  e92d41fc          PUSH     {r2-r8,lr}
;;;1659   {
;;;1660   	uint32_t i, retryCount;
;;;1661   	uint32_t respStatus;
;;;1662   	uint32_t respValue;
;;;1663   	uint32_t CmdArgument;
;;;1664   
;;;1665   	int32_t retval = MCI_FUNC_FAILED;
000b26  f04f38ff          MOV      r8,#0xffffffff
;;;1666   
;;;1667   	/* If it's a SD card, SET_RELATIVE_ADDR is to get the address
;;;1668   	from the card and use this value in RCA, if it's a MMC, set default
;;;1669   	RCA addr. 0x00010000. */
;;;1670   	if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
000b2a  4842              LDR      r0,|L1.3124|
000b2c  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000b2e  b138              CBZ      r0,|L1.2880|
;;;1671   		(MCI_CardType == MCI_SDSC_V2_CARD) ||
000b30  4840              LDR      r0,|L1.3124|
000b32  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000b34  2802              CMP      r0,#2
000b36  d003              BEQ      |L1.2880|
;;;1672   		(MCI_CardType == MCI_SDHC_SDXC_CARD))
000b38  483e              LDR      r0,|L1.3124|
000b3a  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000b3c  2803              CMP      r0,#3
000b3e  d101              BNE      |L1.2884|
                  |L1.2880|
;;;1673   	{
;;;1674   		CmdArgument = 0;
000b40  2600              MOVS     r6,#0
000b42  e001              B        |L1.2888|
                  |L1.2884|
;;;1675   	}
;;;1676   	else			/* If it's unknown or MMC_CARD, fix the RCA address */
;;;1677   	{
;;;1678   		CmdArgument = 0x00010000;
000b44  f44f3680          MOV      r6,#0x10000
                  |L1.2888|
;;;1679   	}
;;;1680   
;;;1681   	retryCount = 0x20;			/* reset retry counter */
000b48  2420              MOVS     r4,#0x20
;;;1682   
;;;1683   	while ( retryCount > 0 )
000b4a  e02b              B        |L1.2980|
                  |L1.2892|
;;;1684   	{
;;;1685   		/* Send CMD3 command repeatedly until the response is back correctly */
;;;1686   		respStatus = MCI_CmdResp(CMD3_SET_RELATIVE_ADDR, CmdArgument, EXPECT_SHORT_RESP, &respValue, ALLOW_CMD_TIMER);
000b4c  2001              MOVS     r0,#1
000b4e  ab01              ADD      r3,sp,#4
000b50  4602              MOV      r2,r0
000b52  4631              MOV      r1,r6
000b54  9000              STR      r0,[sp,#0]
000b56  2003              MOVS     r0,#3
000b58  f7fffffe          BL       MCI_CmdResp
000b5c  4605              MOV      r5,r0
;;;1687   
;;;1688   		if(respStatus & MCI_CMD_TIMEOUT)
000b5e  f0150f04          TST      r5,#4
000b62  d002              BEQ      |L1.2922|
;;;1689   		{
;;;1690   			retval = MCI_FUNC_TIMEOUT;
000b64  f06f0802          MVN      r8,#2
000b68  e016              B        |L1.2968|
                  |L1.2922|
;;;1691   		}
;;;1692   		else if(!(XSHIFT_(respValue, MCI_CARDSTATUS_READYFORDATA_P0S) & 0x01))
000b6a  9801              LDR      r0,[sp,#4]
000b6c  f3c02000          UBFX     r0,r0,#8,#1
000b70  b910              CBNZ     r0,|L1.2936|
;;;1693   		{
;;;1694   			retval = MCI_FUNC_NOT_READY;
000b72  f06f0804          MVN      r8,#4
000b76  e00f              B        |L1.2968|
                  |L1.2936|
;;;1695   		}
;;;1696   		else if((CARDSTATEOF(respValue) != MCI_CARDSTATE_IDENDTIFIED))
000b78  9801              LDR      r0,[sp,#4]
000b7a  f3c02043          UBFX     r0,r0,#9,#4
000b7e  2802              CMP      r0,#2
000b80  d002              BEQ      |L1.2952|
;;;1697   		{
;;;1698   			retval = MCI_FUNC_ERR_STATE;
000b82  f06f0803          MVN      r8,#3
000b86  e007              B        |L1.2968|
                  |L1.2952|
;;;1699   		}
;;;1700   		else
;;;1701   		{
;;;1702   			CardRCA = respValue & 0xFFFF0000;	/* Save the RCA value from SD card */
000b88  9801              LDR      r0,[sp,#4]
000b8a  f36f000f          BFC      r0,#0,#16
000b8e  4932              LDR      r1,|L1.3160|
000b90  6008              STR      r0,[r1,#0]  ; CardRCA
;;;1703   
;;;1704   			return (MCI_FUNC_OK);	/* response is back and correct. */
000b92  2000              MOVS     r0,#0
                  |L1.2964|
;;;1705   		}
;;;1706   
;;;1707   		for ( i = 0; i < 0x20; i++ );
;;;1708   
;;;1709   		retryCount--;
;;;1710   	}
;;;1711   
;;;1712   	return retval;
;;;1713   }
000b94  e8bd81fc          POP      {r2-r8,pc}
                  |L1.2968|
000b98  2700              MOVS     r7,#0                 ;1707
000b9a  e000              B        |L1.2974|
                  |L1.2972|
000b9c  1c7f              ADDS     r7,r7,#1              ;1707
                  |L1.2974|
000b9e  2f20              CMP      r7,#0x20              ;1707
000ba0  d3fc              BCC      |L1.2972|
000ba2  1e64              SUBS     r4,r4,#1              ;1709
                  |L1.2980|
000ba4  2c00              CMP      r4,#0                 ;1683
000ba6  d1d1              BNE      |L1.2892|
000ba8  4640              MOV      r0,r8                 ;1712
000baa  e7f3              B        |L1.2964|
;;;1714   
                          ENDP

                  MCI_GetCardAddress PROC
;;;1724    ****************************************************************************/
;;;1725   uint32_t MCI_GetCardAddress(void)
000bac  482a              LDR      r0,|L1.3160|
;;;1726   {
;;;1727   	return CardRCA;
000bae  6800              LDR      r0,[r0,#0]  ; CardRCA
;;;1728   }
000bb0  4770              BX       lr
;;;1729   
                          ENDP

                  MCI_GetCSD PROC
;;;1741    ****************************************************************************/
;;;1742   int32_t MCI_GetCSD(uint32_t* csdVal)
000bb2  e92d41f0          PUSH     {r4-r8,lr}
;;;1743   {
000bb6  b085              SUB      sp,sp,#0x14
000bb8  4604              MOV      r4,r0
;;;1744   	uint32_t i, retryCount;
;;;1745   	uint32_t respStatus;
;;;1746   	uint32_t respValue[4];
;;;1747   	uint32_t CmdArgument;
;;;1748   
;;;1749   	if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
000bba  481e              LDR      r0,|L1.3124|
000bbc  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000bbe  b138              CBZ      r0,|L1.3024|
;;;1750   		(MCI_CardType == MCI_SDSC_V2_CARD) ||
000bc0  481c              LDR      r0,|L1.3124|
000bc2  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000bc4  2802              CMP      r0,#2
000bc6  d003              BEQ      |L1.3024|
;;;1751   		(MCI_CardType == MCI_SDHC_SDXC_CARD))
000bc8  481a              LDR      r0,|L1.3124|
000bca  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000bcc  2803              CMP      r0,#3
000bce  d102              BNE      |L1.3030|
                  |L1.3024|
;;;1752   	{
;;;1753   		CmdArgument = CardRCA;
000bd0  4821              LDR      r0,|L1.3160|
000bd2  6806              LDR      r6,[r0,#0]  ; CardRCA
000bd4  e001              B        |L1.3034|
                  |L1.3030|
;;;1754   	}
;;;1755   	else			/* if MMC or unknown card type, use default RCA addr. */
;;;1756   	{
;;;1757   		CmdArgument = 0x00010000;
000bd6  f44f3680          MOV      r6,#0x10000
                  |L1.3034|
;;;1758   	}
;;;1759   
;;;1760   	retryCount = 0x20;
000bda  2520              MOVS     r5,#0x20
;;;1761   
;;;1762   	while ( retryCount > 0 )
000bdc  e025              B        |L1.3114|
                  |L1.3038|
;;;1763   	{
;;;1764   		/* Send SET_BLOCK_LEN command before read and write */
;;;1765   		LPC_MCI->CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
000bde  481c              LDR      r0,|L1.3152|
000be0  6b80              LDR      r0,[r0,#0x38]
000be2  f0400045          ORR      r0,r0,#0x45
000be6  491a              LDR      r1,|L1.3152|
000be8  6388              STR      r0,[r1,#0x38]
;;;1766   
;;;1767   		respStatus = MCI_CmdResp(CMD9_SEND_CSD, CmdArgument, EXPECT_LONG_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
000bea  2001              MOVS     r0,#1
000bec  ab01              ADD      r3,sp,#4
000bee  2202              MOVS     r2,#2
000bf0  4631              MOV      r1,r6
000bf2  9000              STR      r0,[sp,#0]
000bf4  2009              MOVS     r0,#9
000bf6  f7fffffe          BL       MCI_CmdResp
000bfa  4607              MOV      r7,r0
;;;1768   
;;;1769   		if ( !respStatus )
000bfc  b967              CBNZ     r7,|L1.3096|
;;;1770   		{
;;;1771   			if(csdVal != NULL)
000bfe  b13c              CBZ      r4,|L1.3088|
;;;1772   			{
;;;1773   				csdVal[0] = respValue[0];
000c00  9801              LDR      r0,[sp,#4]
000c02  6020              STR      r0,[r4,#0]
;;;1774   				csdVal[1] = respValue[1];
000c04  9802              LDR      r0,[sp,#8]
000c06  6060              STR      r0,[r4,#4]
;;;1775   				csdVal[2] = respValue[2];
000c08  9803              LDR      r0,[sp,#0xc]
000c0a  60a0              STR      r0,[r4,#8]
;;;1776   				csdVal[3] = respValue[3];
000c0c  9804              LDR      r0,[sp,#0x10]
000c0e  60e0              STR      r0,[r4,#0xc]
                  |L1.3088|
;;;1777   			}
;;;1778   
;;;1779   			return (MCI_FUNC_OK);
000c10  2000              MOVS     r0,#0
                  |L1.3090|
;;;1780   		}
;;;1781   
;;;1782   		for ( i = 0; i < 0x20; i++ );
;;;1783   
;;;1784   		retryCount--;
;;;1785   	}
;;;1786   
;;;1787   	return (MCI_FUNC_FAILED);
;;;1788   }
000c12  b005              ADD      sp,sp,#0x14
000c14  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3096|
000c18  f04f0800          MOV      r8,#0                 ;1782
000c1c  e001              B        |L1.3106|
                  |L1.3102|
000c1e  f1080801          ADD      r8,r8,#1              ;1782
                  |L1.3106|
000c22  f1b80f20          CMP      r8,#0x20              ;1782
000c26  d3fa              BCC      |L1.3102|
000c28  1e6d              SUBS     r5,r5,#1              ;1784
                  |L1.3114|
000c2a  2d00              CMP      r5,#0                 ;1762
000c2c  d1d7              BNE      |L1.3038|
000c2e  1e68              SUBS     r0,r5,#1              ;1787
000c30  e7ef              B        |L1.3090|
000c32  0000              DCW      0x0000
                  |L1.3124|
                          DCD      MCI_CardType
                  |L1.3128|
                          DCD      ||CCS||
                  |L1.3132|
                          DCD      0x4002c088
                  |L1.3136|
                          DCD      0x4002c000
                  |L1.3140|
                          DCD      0x20098000
                  |L1.3144|
                          DCD      0x400fc0c4
                  |L1.3148|
                          DCD      0x400fc000
                  |L1.3152|
                          DCD      0x400c0000
                  |L1.3156|
                          DCD      0x400fc1a0
                  |L1.3160|
                          DCD      CardRCA
                          ENDP

                  MCI_Cmd_SelectCard PROC
;;;1802    ****************************************************************************/
;;;1803   int32_t MCI_Cmd_SelectCard( void )
000c5c  e92d41f0          PUSH     {r4-r8,lr}
;;;1804   {
000c60  b085              SUB      sp,sp,#0x14
;;;1805   	uint32_t i, retryCount;
;;;1806   	uint32_t respStatus;
;;;1807   	uint32_t respValue[4];
;;;1808   	uint32_t CmdArgument;
;;;1809   
;;;1810   	int32_t retval = MCI_FUNC_FAILED;
000c62  f04f38ff          MOV      r8,#0xffffffff
;;;1811   
;;;1812   	if ((MCI_CardType == MCI_SDSC_V1_CARD) ||
000c66  48e7              LDR      r0,|L1.4100|
000c68  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000c6a  b138              CBZ      r0,|L1.3196|
;;;1813   			(MCI_CardType == MCI_SDSC_V2_CARD) ||
000c6c  48e5              LDR      r0,|L1.4100|
000c6e  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000c70  2802              CMP      r0,#2
000c72  d003              BEQ      |L1.3196|
;;;1814   			(MCI_CardType == MCI_SDHC_SDXC_CARD)) 
000c74  48e3              LDR      r0,|L1.4100|
000c76  7800              LDRB     r0,[r0,#0]  ; MCI_CardType
000c78  2803              CMP      r0,#3
000c7a  d102              BNE      |L1.3202|
                  |L1.3196|
;;;1815   	{
;;;1816   		CmdArgument = CardRCA;
000c7c  48e2              LDR      r0,|L1.4104|
000c7e  6806              LDR      r6,[r0,#0]  ; CardRCA
000c80  e001              B        |L1.3206|
                  |L1.3202|
;;;1817   	}
;;;1818   	else			/* if MMC or unknown card type, use default RCA addr. */
;;;1819   	{
;;;1820   		CmdArgument = 0x00010000;
000c82  f44f3680          MOV      r6,#0x10000
                  |L1.3206|
;;;1821   	}
;;;1822   
;;;1823   	retryCount = 0x20;
000c86  2420              MOVS     r4,#0x20
;;;1824   
;;;1825   	while ( retryCount > 0 )
000c88  e02b              B        |L1.3298|
                  |L1.3210|
;;;1826   	{
;;;1827   		/* Send CMD7_SELECT_CARD command before read and write */
;;;1828   		LPC_MCI->CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
000c8a  48e0              LDR      r0,|L1.4108|
000c8c  6b80              LDR      r0,[r0,#0x38]
000c8e  f0400045          ORR      r0,r0,#0x45
000c92  49de              LDR      r1,|L1.4108|
000c94  6388              STR      r0,[r1,#0x38]
;;;1829   
;;;1830   		respStatus = MCI_CmdResp(CMD7_SELECT_CARD, CmdArgument, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
000c96  2001              MOVS     r0,#1
000c98  ab01              ADD      r3,sp,#4
000c9a  4602              MOV      r2,r0
000c9c  4631              MOV      r1,r6
000c9e  9000              STR      r0,[sp,#0]
000ca0  2007              MOVS     r0,#7
000ca2  f7fffffe          BL       MCI_CmdResp
000ca6  4605              MOV      r5,r0
;;;1831   
;;;1832   		if(respStatus)
000ca8  b115              CBZ      r5,|L1.3248|
;;;1833   		{
;;;1834   			retval = MCI_FUNC_FAILED;
000caa  f04f38ff          MOV      r8,#0xffffffff
000cae  e012              B        |L1.3286|
                  |L1.3248|
;;;1835   		}
;;;1836   		else if(!(respValue[0] & _SHIFT(MCI_CARDSTATUS_READYFORDATA_P0S)))
000cb0  9801              LDR      r0,[sp,#4]
000cb2  f4107f80          TST      r0,#0x100
000cb6  d102              BNE      |L1.3262|
;;;1837   		{
;;;1838   			retval = MCI_FUNC_NOT_READY;
000cb8  f06f0804          MVN      r8,#4
000cbc  e00b              B        |L1.3286|
                  |L1.3262|
;;;1839   		}
;;;1840   		else if(CARDSTATEOF(respValue[0]) != MCI_CARDSTATE_STBY)
000cbe  9801              LDR      r0,[sp,#4]
000cc0  f3c02043          UBFX     r0,r0,#9,#4
000cc4  2803              CMP      r0,#3
000cc6  d002              BEQ      |L1.3278|
;;;1841   		{
;;;1842   			/* Should be in STANDBY state now and ready */
;;;1843   			retval = MCI_FUNC_ERR_STATE;
000cc8  f06f0803          MVN      r8,#3
000ccc  e003              B        |L1.3286|
                  |L1.3278|
;;;1844   		}
;;;1845   		else
;;;1846   		{
;;;1847   			return MCI_FUNC_OK;
000cce  2000              MOVS     r0,#0
                  |L1.3280|
;;;1848   		}
;;;1849   
;;;1850   		for ( i = 0; i < 0x20; i++ );
;;;1851   
;;;1852   		retryCount--;
;;;1853   	}
;;;1854   
;;;1855   	return retval;
;;;1856   }
000cd0  b005              ADD      sp,sp,#0x14
000cd2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3286|
000cd6  2700              MOVS     r7,#0                 ;1850
000cd8  e000              B        |L1.3292|
                  |L1.3290|
000cda  1c7f              ADDS     r7,r7,#1              ;1850
                  |L1.3292|
000cdc  2f20              CMP      r7,#0x20              ;1850
000cde  d3fc              BCC      |L1.3290|
000ce0  1e64              SUBS     r4,r4,#1              ;1852
                  |L1.3298|
000ce2  2c00              CMP      r4,#0                 ;1825
000ce4  d1d1              BNE      |L1.3210|
000ce6  4640              MOV      r0,r8                 ;1855
000ce8  e7f2              B        |L1.3280|
;;;1857   
                          ENDP

                  MCI_SetBlockLen PROC
;;;1937    ****************************************************************************/
;;;1938   int32_t MCI_SetBlockLen(uint32_t blockLength)
000cea  e92d41f0          PUSH     {r4-r8,lr}
;;;1939   {
000cee  b085              SUB      sp,sp,#0x14
000cf0  4605              MOV      r5,r0
;;;1940   	uint32_t i, retryCount;
;;;1941   	uint32_t respStatus;
;;;1942   	uint32_t respValue[4];
;;;1943   
;;;1944   	int32_t retval = MCI_FUNC_FAILED;
000cf2  f04f38ff          MOV      r8,#0xffffffff
;;;1945   
;;;1946   	retryCount = 0x20;
000cf6  2720              MOVS     r7,#0x20
;;;1947   	while ( retryCount > 0 )
000cf8  e02b              B        |L1.3410|
                  |L1.3322|
;;;1948   	{
;;;1949   		/* Send SET_BLOCK_LEN command before read and write */
;;;1950   		LPC_MCI->CLEAR |= (MCI_CMD_TIMEOUT | MCI_CMD_CRC_FAIL | MCI_CMD_RESP_END);
000cfa  48c4              LDR      r0,|L1.4108|
000cfc  6b80              LDR      r0,[r0,#0x38]
000cfe  f0400045          ORR      r0,r0,#0x45
000d02  49c2              LDR      r1,|L1.4108|
000d04  6388              STR      r0,[r1,#0x38]
;;;1951   
;;;1952   		respStatus = MCI_CmdResp(CMD16_SET_BLOCK_LEN, blockLength, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
000d06  2001              MOVS     r0,#1
000d08  ab01              ADD      r3,sp,#4
000d0a  4602              MOV      r2,r0
000d0c  4629              MOV      r1,r5
000d0e  9000              STR      r0,[sp,#0]
000d10  2010              MOVS     r0,#0x10
000d12  f7fffffe          BL       MCI_CmdResp
000d16  4604              MOV      r4,r0
;;;1953   
;;;1954   		if(respStatus)
000d18  b114              CBZ      r4,|L1.3360|
;;;1955   		{
;;;1956   			retval = MCI_FUNC_FAILED;
000d1a  f04f38ff          MOV      r8,#0xffffffff
000d1e  e012              B        |L1.3398|
                  |L1.3360|
;;;1957   		}
;;;1958   		else if(!(respValue[0] & _SHIFT(MCI_CARDSTATUS_READYFORDATA_P0S)))
000d20  9801              LDR      r0,[sp,#4]
000d22  f4107f80          TST      r0,#0x100
000d26  d102              BNE      |L1.3374|
;;;1959   		{
;;;1960   			retval = MCI_FUNC_NOT_READY;
000d28  f06f0804          MVN      r8,#4
000d2c  e00b              B        |L1.3398|
                  |L1.3374|
;;;1961   		}
;;;1962   		else if((CARDSTATEOF(respValue[0]) != MCI_CARDSTATE_TRAN))
000d2e  9801              LDR      r0,[sp,#4]
000d30  f3c02043          UBFX     r0,r0,#9,#4
000d34  2804              CMP      r0,#4
000d36  d002              BEQ      |L1.3390|
;;;1963   		{
;;;1964   			retval = MCI_FUNC_ERR_STATE;
000d38  f06f0803          MVN      r8,#3
000d3c  e003              B        |L1.3398|
                  |L1.3390|
;;;1965   		}
;;;1966   		else
;;;1967   		{
;;;1968   			return MCI_FUNC_OK;
000d3e  2000              MOVS     r0,#0
                  |L1.3392|
;;;1969   		}
;;;1970   
;;;1971   		for ( i = 0; i < 0x20; i++ );
;;;1972   
;;;1973   		retryCount--;
;;;1974   	}
;;;1975   
;;;1976   	return retval;
;;;1977   }
000d40  b005              ADD      sp,sp,#0x14
000d42  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3398|
000d46  2600              MOVS     r6,#0                 ;1971
000d48  e000              B        |L1.3404|
                  |L1.3402|
000d4a  1c76              ADDS     r6,r6,#1              ;1971
                  |L1.3404|
000d4c  2e20              CMP      r6,#0x20              ;1971
000d4e  d3fc              BCC      |L1.3402|
000d50  1e7f              SUBS     r7,r7,#1              ;1973
                  |L1.3410|
000d52  2f00              CMP      r7,#0                 ;1947
000d54  d1d1              BNE      |L1.3322|
000d56  4640              MOV      r0,r8                 ;1976
000d58  e7f2              B        |L1.3392|
;;;1978   
                          ENDP

                  MCI_GetDataXferEndState PROC
;;;2045    ****************************************************************************/
;;;2046   uint32_t MCI_GetDataXferEndState(void)
000d5a  48ad              LDR      r0,|L1.4112|
;;;2047   {
;;;2048   	return Mci_Data_Xfer_End;
000d5c  6800              LDR      r0,[r0,#0]  ; Mci_Data_Xfer_End
;;;2049   }
000d5e  4770              BX       lr
;;;2050   /************************************************************************//**
                          ENDP

                  MCI_GetXferErrState PROC
;;;2056    ****************************************************************************/
;;;2057   uint32_t MCI_GetXferErrState(void)
000d60  48ac              LDR      r0,|L1.4116|
;;;2058   {
;;;2059       return Mci_Data_Xfer_ERR;
000d62  6800              LDR      r0,[r0,#0]  ; Mci_Data_Xfer_ERR
;;;2060   }
000d64  4770              BX       lr
;;;2061   
                          ENDP

                  MCI_Cmd_StopTransmission PROC
;;;2070    ****************************************************************************/
;;;2071   int32_t MCI_Cmd_StopTransmission( void )
000d66  b5f0              PUSH     {r4-r7,lr}
;;;2072   {
000d68  b085              SUB      sp,sp,#0x14
;;;2073   	uint32_t i, retryCount;
;;;2074   	uint32_t respStatus;
;;;2075   	uint32_t respValue[4];
;;;2076   
;;;2077   	int32_t retval = MCI_FUNC_FAILED;
000d6a  f04f37ff          MOV      r7,#0xffffffff
;;;2078   
;;;2079   	retryCount = 0x20;
000d6e  2620              MOVS     r6,#0x20
;;;2080   
;;;2081   	while ( retryCount > 0 )
000d70  e020              B        |L1.3508|
                  |L1.3442|
;;;2082   	{
;;;2083   		LPC_MCI->CLEAR = 0x7FF;
000d72  f24070ff          MOV      r0,#0x7ff
000d76  49a5              LDR      r1,|L1.4108|
000d78  6388              STR      r0,[r1,#0x38]
;;;2084   
;;;2085   		respStatus = MCI_CmdResp(CMD12_STOP_TRANSMISSION, 0x00000000, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
000d7a  2001              MOVS     r0,#1
000d7c  ab01              ADD      r3,sp,#4
000d7e  4602              MOV      r2,r0
000d80  2100              MOVS     r1,#0
000d82  9000              STR      r0,[sp,#0]
000d84  200c              MOVS     r0,#0xc
000d86  f7fffffe          BL       MCI_CmdResp
000d8a  4604              MOV      r4,r0
;;;2086   
;;;2087   		if(respStatus)
000d8c  b114              CBZ      r4,|L1.3476|
;;;2088   		{
;;;2089   			retval = MCI_FUNC_FAILED;
000d8e  f04f37ff          MOV      r7,#0xffffffff
000d92  e009              B        |L1.3496|
                  |L1.3476|
;;;2090   		}
;;;2091   		else if(!(respValue[0] & _SHIFT(MCI_CARDSTATUS_READYFORDATA_P0S)))
000d94  9801              LDR      r0,[sp,#4]
000d96  f4107f80          TST      r0,#0x100
000d9a  d102              BNE      |L1.3490|
;;;2092   		{
;;;2093   			retval = MCI_FUNC_NOT_READY;
000d9c  f06f0704          MVN      r7,#4
000da0  e002              B        |L1.3496|
                  |L1.3490|
;;;2094   		}
;;;2095   		else
;;;2096   		{
;;;2097   			return MCI_FUNC_OK;
000da2  2000              MOVS     r0,#0
                  |L1.3492|
;;;2098   		}
;;;2099   
;;;2100   		for ( i = 0; i < 0x20; i++ );
;;;2101   
;;;2102   		retryCount--;
;;;2103   	}
;;;2104   
;;;2105   	return retval;
;;;2106   }
000da4  b005              ADD      sp,sp,#0x14
000da6  bdf0              POP      {r4-r7,pc}
                  |L1.3496|
000da8  2500              MOVS     r5,#0                 ;2100
000daa  e000              B        |L1.3502|
                  |L1.3500|
000dac  1c6d              ADDS     r5,r5,#1              ;2100
                  |L1.3502|
000dae  2d20              CMP      r5,#0x20              ;2100
000db0  d3fc              BCC      |L1.3500|
000db2  1e76              SUBS     r6,r6,#1              ;2102
                  |L1.3508|
000db4  2e00              CMP      r6,#0                 ;2081
000db6  d1dc              BNE      |L1.3442|
000db8  4638              MOV      r0,r7                 ;2105
000dba  e7f3              B        |L1.3492|
;;;2107   
                          ENDP

                  MCI_Cmd_WriteBlock PROC
;;;2122    ****************************************************************************/
;;;2123   int32_t MCI_Cmd_WriteBlock(uint32_t blockNum, uint32_t numOfBlock)
000dbc  e92d47f0          PUSH     {r4-r10,lr}
;;;2124   {
000dc0  b085              SUB      sp,sp,#0x14
000dc2  4607              MOV      r7,r0
000dc4  4688              MOV      r8,r1
;;;2125   	uint32_t i, retryCount;
;;;2126   	uint32_t respStatus;
;;;2127   	uint32_t respValue[4];
;;;2128   
;;;2129   	uint32_t commandID;
;;;2130   
;;;2131   	int32_t retval = MCI_FUNC_FAILED;
000dc6  f04f3aff          MOV      r10,#0xffffffff
;;;2132   
;;;2133   	if (numOfBlock > 1)
000dca  f1b80f01          CMP      r8,#1
000dce  d901              BLS      |L1.3540|
;;;2134   	{
;;;2135   		commandID = CMD25_WRITE_MULTIPLE_BLOCK;
000dd0  2619              MOVS     r6,#0x19
000dd2  e000              B        |L1.3542|
                  |L1.3540|
;;;2136   	}
;;;2137   	else
;;;2138   	{
;;;2139   		commandID = CMD24_WRITE_BLOCK;
000dd4  2618              MOVS     r6,#0x18
                  |L1.3542|
;;;2140   	}
;;;2141   	
;;;2142   	retryCount = 0x20;
000dd6  2420              MOVS     r4,#0x20
;;;2143   	while ( retryCount > 0 )
000dd8  e02c              B        |L1.3636|
                  |L1.3546|
;;;2144   	{
;;;2145   		LPC_MCI->CLEAR = 0x7FF;
000dda  f24070ff          MOV      r0,#0x7ff
000dde  498b              LDR      r1,|L1.4108|
000de0  6388              STR      r0,[r1,#0x38]
;;;2146   
;;;2147   		respStatus = MCI_CmdResp(commandID, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
000de2  2001              MOVS     r0,#1
000de4  0279              LSLS     r1,r7,#9
000de6  ab01              ADD      r3,sp,#4
000de8  4602              MOV      r2,r0
000dea  9000              STR      r0,[sp,#0]
000dec  4630              MOV      r0,r6
000dee  f7fffffe          BL       MCI_CmdResp
000df2  4605              MOV      r5,r0
;;;2148   
;;;2149   		if(respStatus)
000df4  b115              CBZ      r5,|L1.3580|
;;;2150   		{
;;;2151   			retval = MCI_FUNC_FAILED;
000df6  f04f3aff          MOV      r10,#0xffffffff
000dfa  e012              B        |L1.3618|
                  |L1.3580|
;;;2152   		}
;;;2153   		else if(!(XSHIFT_(respValue[0], MCI_CARDSTATUS_READYFORDATA_P0S) & 0x01))
000dfc  9801              LDR      r0,[sp,#4]
000dfe  f3c02000          UBFX     r0,r0,#8,#1
000e02  b910              CBNZ     r0,|L1.3594|
;;;2154   		{
;;;2155   			retval = MCI_FUNC_NOT_READY;
000e04  f06f0a04          MVN      r10,#4
000e08  e00b              B        |L1.3618|
                  |L1.3594|
;;;2156   		}
;;;2157   		else if((CARDSTATEOF(respValue[0]) != MCI_CARDSTATE_TRAN))
000e0a  9801              LDR      r0,[sp,#4]
000e0c  f3c02043          UBFX     r0,r0,#9,#4
000e10  2804              CMP      r0,#4
000e12  d002              BEQ      |L1.3610|
;;;2158   		{
;;;2159   			retval = MCI_FUNC_ERR_STATE;
000e14  f06f0a03          MVN      r10,#3
000e18  e003              B        |L1.3618|
                  |L1.3610|
;;;2160   		}
;;;2161   		else
;;;2162   		{
;;;2163   			/* ready and in TRAN state */
;;;2164   			return MCI_FUNC_OK;
000e1a  2000              MOVS     r0,#0
                  |L1.3612|
;;;2165   		}
;;;2166   
;;;2167   		for ( i = 0; i < 0x20; i++ );
;;;2168   
;;;2169   		retryCount--;
;;;2170   	}
;;;2171   
;;;2172   	return retval;				/* Fatal error */
;;;2173   }
000e1c  b005              ADD      sp,sp,#0x14
000e1e  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3618|
000e22  f04f0900          MOV      r9,#0                 ;2167
000e26  e001              B        |L1.3628|
                  |L1.3624|
000e28  f1090901          ADD      r9,r9,#1              ;2167
                  |L1.3628|
000e2c  f1b90f20          CMP      r9,#0x20              ;2167
000e30  d3fa              BCC      |L1.3624|
000e32  1e64              SUBS     r4,r4,#1              ;2169
                  |L1.3636|
000e34  2c00              CMP      r4,#0                 ;2143
000e36  d1d0              BNE      |L1.3546|
000e38  4650              MOV      r0,r10                ;2172
000e3a  e7ef              B        |L1.3612|
;;;2174   
                          ENDP

                  MCI_Cmd_ReadBlock PROC
;;;2191    ****************************************************************************/
;;;2192   int32_t MCI_Cmd_ReadBlock(uint32_t blockNum, uint32_t numOfBlock)
000e3c  e92d47f0          PUSH     {r4-r10,lr}
;;;2193   {
000e40  b085              SUB      sp,sp,#0x14
000e42  4607              MOV      r7,r0
000e44  4688              MOV      r8,r1
;;;2194   	uint32_t i, retryCount;
;;;2195   	uint32_t respStatus;
;;;2196   	uint32_t respValue[4];
;;;2197   	uint32_t commandID;
;;;2198   
;;;2199   	int32_t retval = MCI_FUNC_FAILED;
000e46  f04f3aff          MOV      r10,#0xffffffff
;;;2200   
;;;2201   	// To Do: Read Multi-Block
;;;2202   	if (numOfBlock > 1)
000e4a  f1b80f01          CMP      r8,#1
000e4e  d901              BLS      |L1.3668|
;;;2203   		commandID = CMD18_READ_MULTIPLE_BLOCK;
000e50  2612              MOVS     r6,#0x12
000e52  e000              B        |L1.3670|
                  |L1.3668|
;;;2204   	else
;;;2205   		commandID = CMD17_READ_SINGLE_BLOCK;
000e54  2611              MOVS     r6,#0x11
                  |L1.3670|
;;;2206   
;;;2207   	retryCount = 0x20;
000e56  2420              MOVS     r4,#0x20
;;;2208   	while ( retryCount > 0 )
000e58  e02c              B        |L1.3764|
                  |L1.3674|
;;;2209   	{
;;;2210   		LPC_MCI->CLEAR = 0x7FF;
000e5a  f24070ff          MOV      r0,#0x7ff
000e5e  496b              LDR      r1,|L1.4108|
000e60  6388              STR      r0,[r1,#0x38]
;;;2211   
;;;2212   		respStatus = MCI_CmdResp(commandID, blockNum * BLOCK_LENGTH, EXPECT_SHORT_RESP, (uint32_t *)&respValue[0], ALLOW_CMD_TIMER);
000e62  2001              MOVS     r0,#1
000e64  0279              LSLS     r1,r7,#9
000e66  ab01              ADD      r3,sp,#4
000e68  4602              MOV      r2,r0
000e6a  9000              STR      r0,[sp,#0]
000e6c  4630              MOV      r0,r6
000e6e  f7fffffe          BL       MCI_CmdResp
000e72  4605              MOV      r5,r0
;;;2213   
;;;2214   		if(respStatus)
000e74  b115              CBZ      r5,|L1.3708|
;;;2215   		{
;;;2216   			retval = MCI_FUNC_FAILED;
000e76  f04f3aff          MOV      r10,#0xffffffff
000e7a  e012              B        |L1.3746|
                  |L1.3708|
;;;2217   		}
;;;2218   		else if(!(respValue[0] & _SHIFT(MCI_CARDSTATUS_READYFORDATA_P0S)))
000e7c  9801              LDR      r0,[sp,#4]
000e7e  f4107f80          TST      r0,#0x100
000e82  d102              BNE      |L1.3722|
;;;2219   		{
;;;2220   			retval = MCI_FUNC_NOT_READY;
000e84  f06f0a04          MVN      r10,#4
000e88  e00b              B        |L1.3746|
                  |L1.3722|
;;;2221   		}
;;;2222   		else if((CARDSTATEOF(respValue[0]) != MCI_CARDSTATE_TRAN))//((CARDSTATEOF(respValue[0]) != MCI_CARDSTATE_READY))
000e8a  9801              LDR      r0,[sp,#4]
000e8c  f3c02043          UBFX     r0,r0,#9,#4
000e90  2804              CMP      r0,#4
000e92  d002              BEQ      |L1.3738|
;;;2223   		{
;;;2224   			retval = MCI_FUNC_ERR_STATE;
000e94  f06f0a03          MVN      r10,#3
000e98  e003              B        |L1.3746|
                  |L1.3738|
;;;2225   		}
;;;2226   		else
;;;2227   		{
;;;2228   			/* ready and in TRAN state */
;;;2229   			return MCI_FUNC_OK;
000e9a  2000              MOVS     r0,#0
                  |L1.3740|
;;;2230   		}
;;;2231   
;;;2232   		for ( i = 0; i < 0x20; i++ );
;;;2233   
;;;2234   		retryCount--;
;;;2235   	}
;;;2236   
;;;2237   	return retval;
;;;2238   }
000e9c  b005              ADD      sp,sp,#0x14
000e9e  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3746|
000ea2  f04f0900          MOV      r9,#0                 ;2232
000ea6  e001              B        |L1.3756|
                  |L1.3752|
000ea8  f1090901          ADD      r9,r9,#1              ;2232
                  |L1.3756|
000eac  f1b90f20          CMP      r9,#0x20              ;2232
000eb0  d3fa              BCC      |L1.3752|
000eb2  1e64              SUBS     r4,r4,#1              ;2234
                  |L1.3764|
000eb4  2c00              CMP      r4,#0                 ;2208
000eb6  d1d0              BNE      |L1.3674|
000eb8  4650              MOV      r0,r10                ;2237
000eba  e7ef              B        |L1.3740|
;;;2239   
                          ENDP

                  MCI_WriteBlock PROC
;;;2264    ****************************************************************************/
;;;2265   int32_t MCI_WriteBlock(uint8_t* memblock, uint32_t blockNum, uint32_t numOfBlock)
000ebc  e92d41f0          PUSH     {r4-r8,lr}
;;;2266   {
000ec0  4606              MOV      r6,r0
000ec2  4688              MOV      r8,r1
000ec4  4615              MOV      r5,r2
;;;2267   	uint32_t i;
;;;2268   	uint32_t DataCtrl = 0;
000ec6  2700              MOVS     r7,#0
;;;2269   
;;;2270   	dataSrcBlock = memblock;
000ec8  4853              LDR      r0,|L1.4120|
000eca  6006              STR      r6,[r0,#0]  ; dataSrcBlock
;;;2271   
;;;2272   	LPC_MCI->CLEAR = 0x7FF;
000ecc  f24070ff          MOV      r0,#0x7ff
000ed0  494e              LDR      r1,|L1.4108|
000ed2  6388              STR      r0,[r1,#0x38]
;;;2273   
;;;2274   	LPC_MCI->DATACTRL = 0;
000ed4  2000              MOVS     r0,#0
000ed6  62c8              STR      r0,[r1,#0x2c]
;;;2275   
;;;2276   	for ( i = 0; i < 0x10; i++ );
000ed8  2400              MOVS     r4,#0
000eda  e000              B        |L1.3806|
                  |L1.3804|
000edc  1c64              ADDS     r4,r4,#1
                  |L1.3806|
000ede  2c10              CMP      r4,#0x10
000ee0  d3fc              BCC      |L1.3804|
;;;2277   
;;;2278   	/* Below status check is redundant, but ensure card is in TRANS state
;;;2279   	before writing and reading to from the card. */
;;;2280   	if (MCI_CheckStatus() != MCI_FUNC_OK)
000ee2  f7fffffe          BL       MCI_CheckStatus
000ee6  b128              CBZ      r0,|L1.3828|
;;;2281   	{
;;;2282   		MCI_Cmd_StopTransmission();
000ee8  f7fffffe          BL       MCI_Cmd_StopTransmission
;;;2283   
;;;2284   		return(MCI_FUNC_FAILED);
000eec  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3824|
;;;2285   	}
;;;2286   
;;;2287   	LPC_MCI->DATATMR = DATA_TIMER_VALUE;
;;;2288   
;;;2289   	LPC_MCI->DATALEN = BLOCK_LENGTH*numOfBlock;
;;;2290   
;;;2291   	Mci_Data_Xfer_End = 1;
;;;2292       Mci_Data_Xfer_ERR = 0;
;;;2293       fifo_plane = 0;
;;;2294   
;;;2295   	txBlockCnt = 0;
;;;2296   
;;;2297   	MCI_TXEnable();
;;;2298   
;;;2299   	if (MCI_Cmd_WriteBlock(blockNum, numOfBlock) != MCI_FUNC_OK)
;;;2300   	{
;;;2301   		return ( MCI_FUNC_FAILED );
;;;2302   	}
;;;2303   
;;;2304   	//for(blockCnt = 0; blockCnt < numOfBlock; blockCnt++)
;;;2305   	{
;;;2306   #if MCI_DMA_ENABLED
;;;2307   		MCI_SettingDma((uint8_t*) dataSrcBlock, MCI_DMA_WRITE_CHANNEL, GPDMA_TRANSFERTYPE_M2P_DEST_CTRL);
;;;2308   		
;;;2309   		/* Write, block transfer, DMA, and data length */
;;;2310   		DataCtrl |= MCI_DATACTRL_ENABLE | MCI_DATACTRL_DIR_TO_CARD 
;;;2311   						| MCI_DATACTRL_DMA_ENABLE | MCI_DTATCTRL_BLOCKSIZE(DATA_BLOCK_LEN);
;;;2312   #else
;;;2313   		/* Write, block transfer, and data length */
;;;2314   		DataCtrl |= MCI_DATACTRL_ENABLE  | MCI_DATACTRL_DIR_TO_CARD  | MCI_DTATCTRL_BLOCKSIZE(DATA_BLOCK_LEN);
;;;2315   #endif
;;;2316   	}
;;;2317   
;;;2318   	LPC_MCI->DATACTRL = DataCtrl;
;;;2319   
;;;2320   	for ( i = 0; i < 0x10; i++ );
;;;2321   
;;;2322   	return MCI_FUNC_OK;
;;;2323   }
000ef0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3828|
000ef4  f44f3080          MOV      r0,#0x10000           ;2287
000ef8  4944              LDR      r1,|L1.4108|
000efa  6248              STR      r0,[r1,#0x24]         ;2287
000efc  0268              LSLS     r0,r5,#9              ;2289
000efe  6288              STR      r0,[r1,#0x28]         ;2289
000f00  2001              MOVS     r0,#1                 ;2291
000f02  4943              LDR      r1,|L1.4112|
000f04  6008              STR      r0,[r1,#0]            ;2291  ; Mci_Data_Xfer_End
000f06  2000              MOVS     r0,#0                 ;2292
000f08  4942              LDR      r1,|L1.4116|
000f0a  6008              STR      r0,[r1,#0]            ;2292  ; Mci_Data_Xfer_ERR
000f0c  4943              LDR      r1,|L1.4124|
000f0e  7008              STRB     r0,[r1,#0]            ;2293
000f10  4943              LDR      r1,|L1.4128|
000f12  6008              STR      r0,[r1,#0]            ;2295  ; txBlockCnt
000f14  f7fffffe          BL       MCI_TXEnable
000f18  4629              MOV      r1,r5                 ;2299
000f1a  4640              MOV      r0,r8                 ;2299
000f1c  f7fffffe          BL       MCI_Cmd_WriteBlock
000f20  b110              CBZ      r0,|L1.3880|
000f22  f04f30ff          MOV      r0,#0xffffffff        ;2301
000f26  e7e3              B        |L1.3824|
                  |L1.3880|
000f28  2205              MOVS     r2,#5                 ;2307
000f2a  2100              MOVS     r1,#0                 ;2307
000f2c  483a              LDR      r0,|L1.4120|
000f2e  6800              LDR      r0,[r0,#0]            ;2307  ; dataSrcBlock
000f30  f7fffffe          BL       MCI_SettingDma
000f34  f0470799          ORR      r7,r7,#0x99           ;2310
000f38  4834              LDR      r0,|L1.4108|
000f3a  62c7              STR      r7,[r0,#0x2c]         ;2318
000f3c  2400              MOVS     r4,#0                 ;2320
000f3e  e000              B        |L1.3906|
                  |L1.3904|
000f40  1c64              ADDS     r4,r4,#1              ;2320
                  |L1.3906|
000f42  2c10              CMP      r4,#0x10              ;2320
000f44  d3fc              BCC      |L1.3904|
000f46  2000              MOVS     r0,#0                 ;2322
000f48  e7d2              B        |L1.3824|
;;;2324   
                          ENDP

                  MCI_ReadBlock PROC
;;;2350    ****************************************************************************/
;;;2351   int32_t MCI_ReadBlock(uint8_t* destBlock, uint32_t blockNum, uint32_t numOfBlock)
000f4a  e92d41f0          PUSH     {r4-r8,lr}
;;;2352   {
000f4e  4606              MOV      r6,r0
000f50  4688              MOV      r8,r1
000f52  4615              MOV      r5,r2
;;;2353   	uint32_t i;
;;;2354   	uint32_t DataCtrl = 0;
000f54  2700              MOVS     r7,#0
;;;2355   
;;;2356   	dataDestBlock = destBlock;
000f56  4833              LDR      r0,|L1.4132|
000f58  6006              STR      r6,[r0,#0]  ; dataDestBlock
;;;2357   
;;;2358   	LPC_MCI->CLEAR = 0x7FF;
000f5a  f24070ff          MOV      r0,#0x7ff
000f5e  492b              LDR      r1,|L1.4108|
000f60  6388              STR      r0,[r1,#0x38]
;;;2359   
;;;2360   	LPC_MCI->DATACTRL = 0;
000f62  2000              MOVS     r0,#0
000f64  62c8              STR      r0,[r1,#0x2c]
;;;2361   
;;;2362   	for ( i = 0; i < 0x10; i++ );
000f66  2400              MOVS     r4,#0
000f68  e000              B        |L1.3948|
                  |L1.3946|
000f6a  1c64              ADDS     r4,r4,#1
                  |L1.3948|
000f6c  2c10              CMP      r4,#0x10
000f6e  d3fc              BCC      |L1.3946|
;;;2363   
;;;2364   	/* Below status check is redundant, but ensure card is in TRANS state
;;;2365   	before writing and reading to from the card. */
;;;2366   	if ( MCI_CheckStatus() != MCI_FUNC_OK )
000f70  f7fffffe          BL       MCI_CheckStatus
000f74  b128              CBZ      r0,|L1.3970|
;;;2367   	{
;;;2368   		MCI_Cmd_StopTransmission();
000f76  f7fffffe          BL       MCI_Cmd_StopTransmission
;;;2369   
;;;2370   		return(MCI_FUNC_FAILED);
000f7a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3966|
;;;2371   	}
;;;2372   
;;;2373   	MCI_RXEnable();
;;;2374   
;;;2375   	LPC_MCI->DATATMR = DATA_TIMER_VALUE;
;;;2376   
;;;2377   	LPC_MCI->DATALEN = BLOCK_LENGTH*numOfBlock;
;;;2378   
;;;2379   	Mci_Data_Xfer_End = 1;
;;;2380       Mci_Data_Xfer_ERR = 0;
;;;2381   	rxBlockCnt = 0;
;;;2382       fifo_plane = 0;
;;;2383   
;;;2384   	if ( MCI_Cmd_ReadBlock(blockNum, numOfBlock) != MCI_FUNC_OK )
;;;2385   	{
;;;2386   		return MCI_FUNC_FAILED;
;;;2387   	}
;;;2388   
;;;2389   	//for(blockCnt = 0; blockCnt < numOfBlock; blockCnt++)
;;;2390   	{		
;;;2391   #if MCI_DMA_ENABLED
;;;2392   		MCI_SettingDma((uint8_t*) dataDestBlock, MCI_DMA_READ_CHANNEL, GPDMA_TRANSFERTYPE_P2M_SRC_CTRL);
;;;2393   
;;;2394   		/* Write, block transfer, DMA, and data length */
;;;2395   		DataCtrl |= MCI_DATACTRL_ENABLE | MCI_DATACTRL_DIR_FROM_CARD
;;;2396   						| MCI_DATACTRL_DMA_ENABLE | MCI_DTATCTRL_BLOCKSIZE(DATA_BLOCK_LEN);
;;;2397   #else
;;;2398   		//Retrieving the result after reading the card is done by the FIFO handling for interrupt
;;;2399   		
;;;2400   		/* Read, enable, block transfer, and data length */
;;;2401   		DataCtrl |= MCI_DATACTRL_ENABLE | MCI_DATACTRL_DIR_FROM_CARD | MCI_DTATCTRL_BLOCKSIZE(DATA_BLOCK_LEN);
;;;2402   
;;;2403   #endif
;;;2404   	}
;;;2405   	
;;;2406   	LPC_MCI->DATACTRL = DataCtrl;
;;;2407   
;;;2408   	for ( i = 0; i < 0x10; i++ );
;;;2409   
;;;2410   	return MCI_FUNC_OK;
;;;2411   }
000f7e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3970|
000f82  f7fffffe          BL       MCI_RXEnable
000f86  f44f3080          MOV      r0,#0x10000           ;2375
000f8a  4920              LDR      r1,|L1.4108|
000f8c  6248              STR      r0,[r1,#0x24]         ;2375
000f8e  0268              LSLS     r0,r5,#9              ;2377
000f90  6288              STR      r0,[r1,#0x28]         ;2377
000f92  2001              MOVS     r0,#1                 ;2379
000f94  491e              LDR      r1,|L1.4112|
000f96  6008              STR      r0,[r1,#0]            ;2379  ; Mci_Data_Xfer_End
000f98  2000              MOVS     r0,#0                 ;2380
000f9a  491e              LDR      r1,|L1.4116|
000f9c  6008              STR      r0,[r1,#0]            ;2380  ; Mci_Data_Xfer_ERR
000f9e  4922              LDR      r1,|L1.4136|
000fa0  6008              STR      r0,[r1,#0]            ;2381  ; rxBlockCnt
000fa2  491e              LDR      r1,|L1.4124|
000fa4  7008              STRB     r0,[r1,#0]            ;2382
000fa6  4629              MOV      r1,r5                 ;2384
000fa8  4640              MOV      r0,r8                 ;2384
000faa  f7fffffe          BL       MCI_Cmd_ReadBlock
000fae  b110              CBZ      r0,|L1.4022|
000fb0  f04f30ff          MOV      r0,#0xffffffff        ;2386
000fb4  e7e3              B        |L1.3966|
                  |L1.4022|
000fb6  2206              MOVS     r2,#6                 ;2392
000fb8  2101              MOVS     r1,#1                 ;2392
000fba  481a              LDR      r0,|L1.4132|
000fbc  6800              LDR      r0,[r0,#0]            ;2392  ; dataDestBlock
000fbe  f7fffffe          BL       MCI_SettingDma
000fc2  f047079b          ORR      r7,r7,#0x9b           ;2395
000fc6  4811              LDR      r0,|L1.4108|
000fc8  62c7              STR      r7,[r0,#0x2c]         ;2406
000fca  2400              MOVS     r4,#0                 ;2408
000fcc  e000              B        |L1.4048|
                  |L1.4046|
000fce  1c64              ADDS     r4,r4,#1              ;2408
                  |L1.4048|
000fd0  2c10              CMP      r4,#0x10              ;2408
000fd2  d3fc              BCC      |L1.4046|
000fd4  2000              MOVS     r0,#0                 ;2410
000fd6  e7d2              B        |L1.3966|
;;;2412   
                          ENDP

                  MCI_PowerOff PROC
;;;2420    ****************************************************************************/
;;;2421   void MCI_PowerOff(void) 
000fd8  2100              MOVS     r1,#0
;;;2422   {
;;;2423   	uint32_t i;
;;;2424   
;;;2425   	LPC_MCI->POWER = 0;
000fda  4a0c              LDR      r2,|L1.4108|
000fdc  6011              STR      r1,[r2,#0]
;;;2426   	
;;;2427   	for (i = 0; i < 0x100; i++);
000fde  2000              MOVS     r0,#0
000fe0  e000              B        |L1.4068|
                  |L1.4066|
000fe2  1c40              ADDS     r0,r0,#1
                  |L1.4068|
000fe4  28ff              CMP      r0,#0xff
000fe6  d9fc              BLS      |L1.4066|
;;;2428   	
;;;2429   	return;
;;;2430   }
000fe8  4770              BX       lr
;;;2431   
                          ENDP

                  NVIC_EnableIRQ PROC
;;;1070    */
;;;1071   static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000fea  f000021f          AND      r2,r0,#0x1f
;;;1072   {
;;;1073   /*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
;;;1074     NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
000fee  2101              MOVS     r1,#1
000ff0  4091              LSLS     r1,r1,r2
000ff2  0942              LSRS     r2,r0,#5
000ff4  f04f23e0          MOV      r3,#0xe000e000
000ff8  eb030282          ADD      r2,r3,r2,LSL #2
000ffc  f8c21100          STR      r1,[r2,#0x100]
;;;1075   }
001000  4770              BX       lr
;;;1076   
                          ENDP

001002  0000              DCW      0x0000
                  |L1.4100|
                          DCD      MCI_CardType
                  |L1.4104|
                          DCD      CardRCA
                  |L1.4108|
                          DCD      0x400c0000
                  |L1.4112|
                          DCD      Mci_Data_Xfer_End
                  |L1.4116|
                          DCD      Mci_Data_Xfer_ERR
                  |L1.4120|
                          DCD      dataSrcBlock
                  |L1.4124|
                          DCD      fifo_plane
                  |L1.4128|
                          DCD      txBlockCnt
                  |L1.4132|
                          DCD      dataDestBlock
                  |L1.4136|
                          DCD      rxBlockCnt

                          AREA ||.data||, DATA, ALIGN=2

                  Mci_Data_Xfer_End
                          DCD      0x00000000
                  Mci_Data_Xfer_ERR
                          DCD      0x00000000
                  fifo_plane
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  dataSrcBlock
                          DCD      0x20000000
                  dataDestBlock
                          DCD      0x200003e8
                  txBlockCnt
                          DCD      0x00000000
                  rxBlockCnt
                          DCD      0x00000000
                  CardRCA
                          DCD      0x00000000
                  ||CCS||
000020  00                DCB      0x00
                  MCI_CardType
000021  000000            DCB      0x00,0x00,0x00
                  dmaWrCh_TermianalCnt
                          DCD      0x00000000
                  dmaWrCh_ErrorCnt
                          DCD      0x00000000
                  dmaRdCh_TermianalCnt
                          DCD      0x00000000
                  dmaRdCh_ErrorCnt
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\source\\lpc_mci.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_lpc_mci_c_21ab3756____REV16|
#line 115 "..\\..\\..\\..\\Core\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_lpc_mci_c_21ab3756____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_lpc_mci_c_21ab3756____REVSH|
#line 129
|__asm___9_lpc_mci_c_21ab3756____REVSH| PROC
#line 130

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
